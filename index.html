<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SigXFlow</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f10;
            color: #e0e0e0;
            font-size: 13px;
        }
        
        /* ===== HEADER ===== */
        .header {
            background: linear-gradient(180deg, #1e1e20 0%, #1a1a1c 100%);
            border-bottom: 1px solid #2a2a2e;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .logo {
            font-size: 16px;
            font-weight: 600;
            color: #60a5fa;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .logo-icon {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            padding: 5px 7px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .logo-icon::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 7px solid #4ade80;
        }
        
        .logo-icon::after {
            content: '';
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 7px solid #f87171;
        }
        
        /* Stats */
        .stats-row {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        .stat-compact {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            padding: 6px 10px;
            background: linear-gradient(135deg, #1a1a1c 0%, #1e1e20 100%);
            border: 1px solid #2a2a2e;
            border-radius: 6px;
        }
        
        .stat-compact span {
            margin-right: 3px;
            font-size: 14px;
        }
        
        .stat-compact.success { 
            color: #4ade80; 
            border-color: rgba(74, 222, 128, 0.2);
        }
        .stat-compact.success span {
            text-shadow: 0 0 8px rgba(74, 222, 128, 0.4);
        }
        .stat-compact.fail { 
            color: #f87171; 
            border-color: rgba(248, 113, 113, 0.2);
        }
        .stat-compact.fail span {
            text-shadow: 0 0 8px rgba(248, 113, 113, 0.4);
        }
        .stat-compact.win { 
            color: #fbbf24; 
            border-color: rgba(251, 191, 36, 0.2);
        }
        .stat-compact.win span {
            text-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
        }
        
        .stat {
            padding: 8px 16px;
            background: #1f1f22;
            border: 1px solid #2a2a2e;
            border-radius: 6px;
            text-align: center;
            min-width: 70px;
        }
        
        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 600;
        }
        
        .stat-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .stat.active .stat-value { color: #60a5fa; }
        .stat.success .stat-value { color: #22c55e; }
        .stat.fail .stat-value { color: #ef4444; }
        .stat.win .stat-value { color: #fbbf24; }
        
        /* Navigation */
        .nav-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .btn {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 500;
            padding: 8px 14px;
            border-radius: 6px;
            border: 1px solid #3a3a3e;
            background: #252528;
            color: #bbb;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .btn:hover {
            background: #303035;
            border-color: #4a4a4e;
        }
        
        /* Primary action - subtle gold theme */
        .btn.primary {
            background: linear-gradient(135deg, #252528 0%, #2a2a2e 100%);
            border: 1px solid rgba(251, 191, 36, 0.4);
            color: #fbbf24;
            font-weight: 600;
        }
        
        .btn.primary:hover {
            background: linear-gradient(135deg, #2a2a2e 0%, #333 100%);
            border-color: rgba(251, 191, 36, 0.7);
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.2);
        }
        
        /* Secondary action - muted style */
        .btn.secondary {
            background: linear-gradient(135deg, #1e1e20 0%, #252528 100%);
            border: 1px solid #333;
            color: #888;
            font-weight: 500;
        }
        
        .btn.secondary:hover {
            border-color: #444;
            color: #aaa;
            background: linear-gradient(135deg, #252528 0%, #2a2a2e 100%);
        }
        
        .btn.live {
            background: #dc2626;
            border-color: #dc2626;
            color: #fff;
        }
        
        .btn.inactive {
            background: #1a1a1c;
            border-color: #2a2a2e;
            color: #555;
        }
        
        .btn.explore-active {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #888;
            color: #fff;
        }
        
        /* Styled selects - cohesive dark theme */
        .select-styled {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #333;
            background: linear-gradient(135deg, #1a1a1c 0%, #222 100%);
            color: #888;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .select-styled:hover {
            border-color: #444;
            color: #aaa;
        }
        
        .select-styled:focus {
            outline: none;
            border-color: rgba(251, 191, 36, 0.5);
        }
        
        .divider {
            width: 1px;
            height: 24px;
            background: linear-gradient(180deg, transparent 0%, #3a3a3e 50%, transparent 100%);
            margin: 0 4px;
        }
        
        /* Settings group - load, refresh, latest */
        .settings-group {
            display: flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, #1a1a1c 0%, #1e1e20 100%);
            padding: 4px 6px;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
        }
        
        .settings-group .select-styled {
            border: none;
            background: transparent;
            padding: 6px 8px;
        }
        
        .settings-group .btn {
            padding: 6px 12px;
        }
        
        .settings-group .countdown {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #555;
            min-width: 24px;
            text-align: center;
        }
        
        /* ===== TOOLBAR ===== */
        .toolbar {
            background: linear-gradient(180deg, #1a1a1c 0%, #161618 100%);
            border-bottom: 1px solid #252528;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .filter-group {
            display: flex;
            gap: 4px;
            background: linear-gradient(135deg, #1e1e20 0%, #222 100%);
            padding: 3px;
            border-radius: 6px;
            border: 1px solid #2a2a2e;
        }
        
        .filter-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            padding: 5px 10px;
            border-radius: 4px;
            border: none;
            background: transparent;
            color: #666;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .filter-btn:hover {
            color: #999;
        }
        
        .filter-btn.active {
            background: #333;
            color: #ddd;
        }
        
        .filter-btn.nq.active { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .filter-btn.es.active { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        .filter-btn.bull.active { color: #22c55e; background: rgba(22, 163, 74, 0.2); }
        .filter-btn.bear.active { color: #f87171; background: rgba(220, 38, 38, 0.2); }
        
        .arrow-up, .arrow-down {
            display: inline-block;
            width: 0;
            height: 0;
            margin-right: 4px;
            vertical-align: middle;
        }
        
        .arrow-up {
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid currentColor;
        }
        
        .arrow-down {
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid currentColor;
        }
        
        .arrow-up-sm, .arrow-down-sm {
            display: inline-block;
            width: 0;
            height: 0;
            margin-left: 2px;
            vertical-align: middle;
        }
        
        .arrow-up-sm {
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-bottom: 5px solid currentColor;
        }
        
        .arrow-down-sm {
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-top: 5px solid currentColor;
        }
        
        .toolbar-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Breaker count badge - prominent display */
        .status-msg {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
            padding: 2px 8px;
            border-radius: 4px;
            transition: opacity 0.3s;
        }
        
        .status-msg.success {
            color: #4ade80;
        }
        
        .status-msg.error {
            color: #f87171;
        }
        
        /* ===== TIMELINE BAR ===== */
        .timeline-track {
            height: 6px;
            background: #252528;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            margin-bottom: 4px;
        }
        
        .timeline-viewport {
            position: absolute;
            height: 100%;
            background: #3b82f6;
            border-radius: 3px;
            cursor: grab;
            transition: background 0.15s;
        }
        
        .timeline-viewport:hover {
            background: #60a5fa;
        }
        
        .timeline-viewport:active {
            cursor: grabbing;
            background: #93c5fd;
        }
        
        /* ===== MAIN WRAPPER ===== */
        .main-wrapper {
            display: flex;
            height: calc(100vh - 130px);
            margin: 10px;
            gap: 10px;
        }
        
        /* ===== CHART AREA ===== */
        .chart-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #131315;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
            overflow: hidden;
            min-width: 0;
        }
        
        /* Fixed Header Row */
        .header-row {
            display: flex;
            flex-shrink: 0;
            background: #1a1a1c;
            border-bottom: 1px solid #2a2a2e;
        }
        
        .left-header {
            width: 195px;
            min-width: 195px;
            height: 48px;
            padding: 0 12px;
            display: flex;
            align-items: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: #888;
            box-sizing: border-box;
        }
        
        .time-header-wrapper {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 6px 10px 0 10px;
        }
        
        .time-header {
            height: 30px;
            position: relative;
            white-space: nowrap;
        }
        
        /* Unified Scroll Container */
        .scroll-container {
            flex-grow: 1;
            overflow: auto;
        }
        
        .scroll-inner {
            display: flex;
            min-width: fit-content;
        }
        
        /* Left Panel - labels */
        .left-panel {
            width: 195px;
            min-width: 195px;
            background: #151517;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 30;
            overflow: hidden;
        }
        
        /* TF section header */
        .tf-header {
            height: 4px;
            margin-top: 8px;
            position: sticky;
            top: 0;
            z-index: 5;
        }
        
        .tf-header.tf-4h { background: linear-gradient(90deg, #f87171 0%, transparent 100%); }
        .tf-header.tf-1h { background: linear-gradient(90deg, #fbbf24 0%, transparent 100%); }
        .tf-header.tf-15m { background: linear-gradient(90deg, #4ade80 0%, transparent 100%); }
        .tf-header.tf-5m { background: linear-gradient(90deg, #60a5fa 0%, transparent 100%); }
        .tf-header.tf-1m { background: linear-gradient(90deg, #c084fc 0%, transparent 100%); }
        
        .tf-header-chart {
            height: 2px;
            display: block;
            position: sticky;
            left: 0;
            z-index: 5;
            width: 100vw;
            max-width: calc(100vw - 195px);
            background-size: 75vw 100%; /* Gradient spans 75% of viewport */
            background-repeat: no-repeat;
        }
        
        .tf-spacer {
            height: 2px;
        }
        
        /* Left panel spacer - full gradient across the panel */
        .tf-spacer[data-tf="1m"] { background: linear-gradient(90deg, #c084fc 0%, rgba(192, 132, 252, 0.5) 100%); }
        .tf-spacer[data-tf="5m"] { background: linear-gradient(90deg, #60a5fa 0%, rgba(96, 165, 250, 0.5) 100%); }
        .tf-spacer[data-tf="15m"] { background: linear-gradient(90deg, #4ade80 0%, rgba(74, 222, 128, 0.5) 100%); }
        .tf-spacer[data-tf="1h"] { background: linear-gradient(90deg, #fbbf24 0%, rgba(251, 191, 36, 0.5) 100%); }
        .tf-spacer[data-tf="4h"] { background: linear-gradient(90deg, #f87171 0%, rgba(248, 113, 113, 0.5) 100%); }
        
        /* TF background tints for chart header - gradient uses background-size */
        .tf-header-chart[data-tf="1m"] { background-image: linear-gradient(90deg, rgba(192, 132, 252, 0.5) 0%, rgba(192, 132, 252, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="5m"] { background-image: linear-gradient(90deg, rgba(96, 165, 250, 0.5) 0%, rgba(96, 165, 250, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="15m"] { background-image: linear-gradient(90deg, rgba(74, 222, 128, 0.5) 0%, rgba(74, 222, 128, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="1h"] { background-image: linear-gradient(90deg, rgba(251, 191, 36, 0.5) 0%, rgba(251, 191, 36, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="4h"] { background-image: linear-gradient(90deg, rgba(248, 113, 113, 0.5) 0%, rgba(248, 113, 113, 0.2) 50%, transparent 100%); }
        
        /* Symbol Lane rows */
        .lane-label {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            transition: all 0.2s ease;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        /* TF Group container */
        .tf-group {
            display: flex;
            flex-direction: row;
            align-items: stretch;
        }
        
        .tf-group-accent {
            width: 30px;
            min-width: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        .tf-group-accent[data-tf="1m"] { background: #c084fc; color: #1a1a1c; }
        .tf-group-accent[data-tf="5m"] { background: #60a5fa; color: #1a1a1c; }
        .tf-group-accent[data-tf="15m"] { background: #4ade80; color: #1a1a1c; }
        .tf-group-accent[data-tf="1h"] { background: #fbbf24; color: #1a1a1c; }
        .tf-group-accent[data-tf="4h"] { background: #f87171; color: #1a1a1c; }
        
        .tf-group-lanes {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .lane-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            gap: 8px;
            box-sizing: border-box;
            min-height: 68px;
            overflow: hidden;
        }
        
        .lane-row[data-symbol="ES"] {
            box-shadow: inset 0 0 0 1000px rgba(0,0,0,0.1);
        }
        
        .lane-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }
        
        .lane-stat-row {
            display: flex;
            align-items: center;
            gap: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
        }
        
        .lane-stat-dir {
            width: 10px;
            font-size: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .lane-stat-dir.bull::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid #22c55e;
        }
        
        .lane-stat-dir.bear::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid #ef4444;
        }
        
        .lane-stat-counts {
            color: #888;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .lane-stat-bar {
            flex: 1;
            min-width: 20px;
            height: 6px;
            background: #252528;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .lane-stat-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .lane-stat-fill.bull {
            background: linear-gradient(90deg, #22c55e, #4ade80);
        }
        
        .lane-stat-fill.bear {
            background: linear-gradient(90deg, #ef4444, #f87171);
        }
        
        .lane-stat-pct {
            text-align: right;
            font-weight: 600;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .lane-stat-pct.bull { color: #4ade80; }
        .lane-stat-pct.bear { color: #f87171; }
        .lane-stat-pct.neutral { color: #555; }
        
        .lane-row.has-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-row.has-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Timeframe background tints for left panel */
        .tf-group[data-tf="1m"] .tf-group-lanes { background: rgba(192, 132, 252, 0.03); }
        .tf-group[data-tf="5m"] .tf-group-lanes { background: rgba(96, 165, 250, 0.03); }
        .tf-group[data-tf="15m"] .tf-group-lanes { background: rgba(74, 222, 128, 0.03); }
        .tf-group[data-tf="1h"] .tf-group-lanes { background: rgba(251, 191, 36, 0.03); }
        .tf-group[data-tf="4h"] .tf-group-lanes { background: rgba(248, 113, 113, 0.03); }
        
        .symbol-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 4px;
            min-width: 28px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .symbol-badge.nq { background: rgba(37, 99, 235, 0.25); color: #60a5fa; border: 1px solid rgba(37, 99, 235, 0.4); }
        .symbol-badge.es { background: rgba(6, 182, 212, 0.25); color: #22d3ee; border: 1px solid rgba(6, 182, 212, 0.4); }
        
        /* Right Panel - chart */
        .right-panel {
            flex-grow: 1;
            position: relative;
        }
        
        .time-tick-label {
            position: absolute;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #555;
            top: 50%;
            transform: translateY(-50%);
            white-space: nowrap;
        }
        
        /* Date separator - vertical line marking day boundaries */
        .date-separator {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, #60a5fa 0%, rgba(96, 165, 250, 0.3) 100%);
            z-index: 5;
        }
        
        .date-separator-label {
            position: absolute;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: #60a5fa;
            background: rgba(15, 15, 18, 0.95);
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid rgba(96, 165, 250, 0.4);
            top: 2px;
            transform: translateX(-50%);
            white-space: nowrap;
            z-index: 10;
        }
        
        /* Sticky date indicator */
        .sticky-date {
            position: fixed;
            top: 130px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: #60a5fa;
            background: rgba(15, 15, 18, 0.95);
            padding: 6px 16px;
            border-radius: 20px;
            border: 1px solid rgba(96, 165, 250, 0.4);
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .sticky-date.visible {
            opacity: 1;
        }
        
        .chart-inner {
            position: relative;
            overflow: visible;
        }
        
        /* Swimlane row */
        .swimlane {
            position: relative;
            box-sizing: border-box;
            min-height: 68px;
        }
        
        /* Timeframe background tints for swimlanes */
        .swimlane[data-tf="1m"] { background: rgba(192, 132, 252, 0.02); }
        .swimlane[data-tf="5m"] { background: rgba(96, 165, 250, 0.02); }
        .swimlane[data-tf="15m"] { background: rgba(74, 222, 128, 0.02); }
        .swimlane[data-tf="1h"] { background: rgba(251, 191, 36, 0.02); }
        .swimlane[data-tf="4h"] { background: rgba(248, 113, 113, 0.02); }
        
        /* ES rows slightly darker for visual separation */
        .swimlane[data-symbol="ES"] {
            box-shadow: inset 0 0 0 1000px rgba(0,0,0,0.1);
        }
        
        /* ===== BREAKER BARS ===== */
        .breaker-bar {
            position: absolute;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 5px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: rgba(255,255,255,0.95);
            overflow: hidden;
            min-width: 6px;
        }
        
        .bar-right-group {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .breaker-bar:hover {
            z-index: 20;
            filter: brightness(1.15);
            box-shadow: 0 0 12px rgba(255,255,255,0.2);
        }
        
        .breaker-bar.selected {
            box-shadow: 0 0 0 2px #fff;
            z-index: 21;
        }
        
        /* NQ Bull = Forest Green */
        .breaker-bar.nq.bull { background: #16a34a; }
        /* NQ Bear = Crimson Red */
        .breaker-bar.nq.bear { background: #dc2626; }
        /* ES Bull = Forest Green with bottom stripe */
        .breaker-bar.es.bull { background: #16a34a; }
        /* ES Bear = Crimson Red with bottom stripe */
        .breaker-bar.es.bear { background: #dc2626; }
        
        /* ES indicator - white bottom stripe */
        .breaker-bar.es::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 0 0 4px 4px;
        }
        
        /* Completed = slightly faded */
        .breaker-bar.completed {
            opacity: 0.75;
        }
        
        .breaker-bar.completed:hover {
            opacity: 1;
        }
        
        /* Fib label */
        .bar-fib {
            flex-shrink: 0;
        }
        
        /* Status dot */
        .status-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 700;
            flex-shrink: 0;
            border: 2px solid rgba(255,255,255,0.95);
            color: #fff;
        }
        
        .status-dot.success {
            background: #16a34a;
        }
        
        .status-dot.fail {
            background: #dc2626;
        }
        
        /* Active at entry highlight (for selection - yellow crisp) */
        .breaker-bar.active-at-entry {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 25;
            opacity: 1 !important;
        }
        
        /* Cursor hover highlight (yellow - crisp) */
        .breaker-bar.cursor-active {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 24;
            opacity: 1 !important;
        }
        
        .lane-row.cursor-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-row.cursor-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Live mode highlight (yellow - same as cursor) */
        .breaker-bar.live-active {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 23;
            opacity: 1 !important;
        }
        
        .lane-row.live-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-row.live-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Entry lines */
        .entry-line {
            position: absolute;
            top: 0;
            width: 2px;
            background: rgba(251, 191, 36, 0.4);
            z-index: 15;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        /* Wider invisible hit area for easier clicking */
        .entry-line::after {
            content: '';
            position: absolute;
            top: 0;
            left: -12px;
            width: 26px;
            height: 100%;
            background: transparent;
        }
        
        .entry-line:hover {
            background: #fbbf24;
            width: 6px;
            margin-left: -2px;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        .entry-line.selected {
            background: #fbbf24;
            width: 4px;
            margin-left: -1px;
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.8);
        }
        
        /* Cursor line */
        .cursor-line {
            position: absolute;
            top: 0;
            width: 1px;
            border-left: 1px dashed rgba(255, 255, 255, 0.5);
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        .cursor-line.visible {
            opacity: 1;
        }
        
        .cursor-time {
            position: fixed;
            display: none;
            background: #fbbf24;
            color: #000;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
        }
        
        /* ===== SMT MARKERS ===== */
        .smt-marker {
            position: absolute;
            width: 6px;
            z-index: 50;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        /* Invisible hit area for easier clicking */
        .smt-marker::before {
            content: '';
            position: absolute;
            top: 0;
            left: -12px;
            width: 30px;
            height: 100%;
            background: transparent;
        }
        
        .smt-marker.bull {
            background: linear-gradient(180deg, #4ade80, rgba(74, 222, 128, 0.4));
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.7), 0 0 24px rgba(74, 222, 128, 0.4);
        }
        
        .smt-marker.bear {
            background: linear-gradient(180deg, #f87171, rgba(248, 113, 113, 0.4));
            box-shadow: 0 0 12px rgba(248, 113, 113, 0.7), 0 0 24px rgba(248, 113, 113, 0.4);
        }
        
        .smt-marker:hover {
            width: 10px;
            margin-left: -2px;
            z-index: 60;
        }
        
        .smt-marker.bull:hover {
            box-shadow: 0 0 20px rgba(74, 222, 128, 1), 0 0 40px rgba(74, 222, 128, 0.6);
            background: linear-gradient(180deg, #4ade80, rgba(74, 222, 128, 0.6));
        }
        
        .smt-marker.bear:hover {
            box-shadow: 0 0 20px rgba(248, 113, 113, 1), 0 0 40px rgba(248, 113, 113, 0.6);
            background: linear-gradient(180deg, #f87171, rgba(248, 113, 113, 0.6));
        }
        
        .smt-marker:hover .smt-diamond {
            width: 16px;
            height: 16px;
            border-width: 3px;
        }
        
        .smt-marker:hover .smt-score {
            font-size: 11px;
            font-weight: 800;
        }
        
        .smt-marker.selected {
            width: 10px;
            margin-left: -2px;
            z-index: 61;
        }
        
        .smt-marker.selected.bull {
            box-shadow: 0 0 0 2px #fff, 0 0 24px rgba(74, 222, 128, 1), 0 0 48px rgba(74, 222, 128, 0.5);
            background: linear-gradient(180deg, #4ade80, rgba(74, 222, 128, 0.6));
        }
        
        .smt-marker.selected.bear {
            box-shadow: 0 0 0 2px #fff, 0 0 24px rgba(248, 113, 113, 1), 0 0 48px rgba(248, 113, 113, 0.5);
            background: linear-gradient(180deg, #f87171, rgba(248, 113, 113, 0.6));
        }
        
        .smt-marker.selected .smt-diamond {
            width: 16px;
            height: 16px;
            border-width: 3px;
        }
        
        .smt-marker.selected .smt-score {
            font-size: 11px;
            font-weight: 800;
        }
        
        .smt-marker .smt-diamond {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 12px;
            height: 12px;
            border: 2px solid;
            border-radius: 2px;
            background: #1a1a1f;
            transition: all 0.15s;
        }
        
        .smt-marker.bull .smt-diamond {
            border-color: #4ade80;
            box-shadow: 0 0 6px rgba(74, 222, 128, 0.5);
        }
        
        .smt-marker.bear .smt-diamond {
            border-color: #f87171;
            box-shadow: 0 0 6px rgba(248, 113, 113, 0.5);
        }
        
        .smt-marker .smt-score {
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            white-space: nowrap;
            transition: all 0.15s;
            text-shadow: 0 0 4px rgba(0,0,0,0.8);
        }
        
        .smt-marker.bull .smt-score {
            color: #4ade80;
        }
        
        .smt-marker.bear .smt-score {
            color: #f87171;
        }
        
        /* ═══════════════════════════════════════════════════════════════════════
           SMT DASHBOARD - World Class Signal Analysis Panel
           ═══════════════════════════════════════════════════════════════════════ */
        
        /* Headline */
        .smt-headline {
            font-size: 14px;
            font-weight: 700;
            text-align: center;
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 4px;
            letter-spacing: 0.5px;
        }
        
        .smt-headline.bull {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.1) 100%);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.3);
        }
        
        .smt-headline.bear {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.1) 100%);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.3);
        }
        
        .smt-story-summary {
            text-align: center;
            font-size: 11px;
            color: #888;
            font-style: italic;
            margin-bottom: 4px;
        }
        
        /* Divergence Grid */
        .smt-divergence-grid {
            display: flex;
            gap: 6px;
            align-items: stretch;
        }
        
        .smt-divergence-vs {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #555;
            padding: 0 2px;
        }
        
        /* Swing Cards */
        .smt-swing-card {
            flex: 1;
            background: #0f0f12;
            border-radius: 8px;
            padding: 10px;
            border: 1px solid #2a2a2f;
        }
        
        .smt-swing-card.trap {
            border-color: rgba(248, 113, 113, 0.4);
        }
        
        .smt-swing-card.truth {
            border-color: rgba(74, 222, 128, 0.4);
        }
        
        .smt-swing-label {
            font-size: 8px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            margin-bottom: 4px;
        }
        
        .smt-swing-card.trap .smt-swing-label { color: #f87171; }
        .smt-swing-card.truth .smt-swing-label { color: #4ade80; }
        
        .smt-swing-asset {
            font-size: 13px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .smt-swing-asset.nq { color: #a78bfa; }
        .smt-swing-asset.es { color: #22d3ee; }
        
        .smt-swing-timeline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .smt-swing-point {
            text-align: center;
        }
        
        .smt-swing-point.current .smt-swing-price {
            font-weight: 700;
            color: #fff;
        }
        
        .smt-swing-time {
            display: block;
            font-size: 9px;
            color: #666;
            font-family: 'JetBrains Mono', monospace;
            margin-bottom: 2px;
        }
        
        .smt-swing-price {
            display: block;
            font-size: 11px;
            color: #aaa;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .smt-swing-connector {
            padding: 0 4px;
        }
        
        .smt-swing-arrow {
            font-size: 16px;
        }
        
        .smt-swing-connector.bullish .smt-swing-arrow { color: #4ade80; }
        .smt-swing-connector.bearish .smt-swing-arrow { color: #f87171; }
        
        .smt-swing-result {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 6px;
            border-radius: 4px;
        }
        
        .smt-swing-result.bullish {
            background: rgba(74, 222, 128, 0.15);
        }
        
        .smt-swing-result.bearish {
            background: rgba(248, 113, 113, 0.15);
        }
        
        .smt-swing-structure {
            font-size: 14px;
            font-weight: 800;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .smt-swing-result.bullish .smt-swing-structure { color: #4ade80; }
        .smt-swing-result.bearish .smt-swing-structure { color: #f87171; }
        
        .smt-swing-delta {
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            color: #888;
        }
        
        /* Timing Bar */
        .smt-timing-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
        }
        
        .smt-timing-endpoint {
            font-size: 10px;
            color: #888;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .smt-timing-connector {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
        }
        
        .smt-timing-line {
            flex: 1;
            height: 2px;
            background: linear-gradient(90deg, #333 0%, #555 50%, #333 100%);
            border-radius: 1px;
        }
        
        .smt-timing-delta {
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .smt-timing-delta.sync {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }
        
        .smt-timing-delta.partial {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }
        
        .smt-timing-delta.async {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }
        
        .smt-timing-label {
            text-align: center;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 4px 12px;
            border-radius: 4px;
            margin: 0 auto;
            display: inline-block;
        }
        
        .smt-timing-label.sync {
            background: rgba(74, 222, 128, 0.15);
            color: #4ade80;
        }
        
        .smt-timing-label.partial {
            background: rgba(251, 191, 36, 0.15);
            color: #fbbf24;
        }
        
        .smt-timing-label.async {
            background: rgba(248, 113, 113, 0.15);
            color: #f87171;
        }
        
        /* Entry Section */
        .smt-entry-section {
            background: #0f0f12;
            border-radius: 6px;
            padding: 10px 12px;
        }
        
        .smt-entry-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 6px 0;
            border-bottom: 1px solid #1a1a1f;
        }
        
        .smt-entry-row:last-child {
            border-bottom: none;
        }
        
        .smt-entry-row.fvg {
            flex-direction: column;
            gap: 6px;
        }
        
        .smt-entry-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .smt-entry-value {
            font-size: 11px;
            color: #ccc;
            font-family: 'JetBrains Mono', monospace;
            text-align: right;
        }
        
        .smt-entry-value.smt-fvg-present {
            color: #4ade80;
            font-weight: 600;
        }
        
        .smt-fvg-list {
            width: 100%;
        }
        
        .smt-fvg-item {
            font-size: 11px;
            color: #4ade80;
            font-family: 'JetBrains Mono', monospace;
            padding: 4px 8px;
            background: rgba(74, 222, 128, 0.1);
            border-radius: 4px;
            margin-top: 4px;
        }
        
        .smt-fvg-size {
            color: #666;
            font-size: 10px;
        }
        
        /* Strength/Weakness Matrix */
        .smt-matrix {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background: #2a2a2f;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .smt-matrix-header {
            padding: 8px 10px;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .smt-matrix-header.strength {
            background: rgba(74, 222, 128, 0.15);
            color: #4ade80;
        }
        
        .smt-matrix-header.weakness {
            background: rgba(248, 113, 113, 0.15);
            color: #f87171;
        }
        
        .smt-matrix-cell {
            padding: 5px 8px;
            font-size: 10px;
            background: #0f0f12;
            min-height: 24px;
            display: flex;
            align-items: center;
        }
        
        .smt-matrix-cell.strength { color: #4ade80; }
        .smt-matrix-cell.weakness { color: #f87171; }
        
        .smt-matrix-bullet {
            margin-right: 5px;
            font-weight: 700;
        }
        
        /* Quality Section */
        .smt-quality-section {
            background: #0f0f12;
            border-radius: 6px;
            padding: 10px;
        }
        
        .smt-quality-main {
            margin-bottom: 8px;
        }
        
        .smt-quality-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .smt-quality-track {
            flex: 1;
            height: 8px;
            background: #2a2a2f;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .smt-quality-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
        
        .smt-quality-fill.high { background: linear-gradient(90deg, #22c55e, #4ade80); }
        .smt-quality-fill.med { background: linear-gradient(90deg, #eab308, #fbbf24); }
        .smt-quality-fill.low { background: linear-gradient(90deg, #dc2626, #f87171); }
        
        .smt-quality-value {
            font-size: 18px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            min-width: 32px;
            text-align: right;
        }
        
        .smt-quality-value.high { color: #4ade80; }
        .smt-quality-value.med { color: #fbbf24; }
        .smt-quality-value.low { color: #f87171; }
        
        .smt-quality-breakdown {
            display: flex;
            justify-content: space-around;
            padding-top: 8px;
            border-top: 1px solid #1a1a1f;
        }
        
        .smt-quality-item {
            text-align: center;
        }
        
        .smt-quality-item-label {
            display: block;
            font-size: 9px;
            color: #555;
            text-transform: uppercase;
            margin-bottom: 2px;
        }
        
        .smt-quality-item-value {
            font-size: 12px;
            font-weight: 600;
            color: #888;
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Meta Footer */
        .smt-meta-footer {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin-top: 4px;
            border-top: 1px solid #2a2a2f;
            font-size: 9px;
            color: #555;
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* ===== DETAIL PANEL ===== */
        .detail-panel {
            width: 320px;
            min-width: 320px;
            background: #1a1a1c;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-header {
            padding: 10px 16px;
            background: #1f1f22;
            border-bottom: 1px solid #2a2a2e;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .panel-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            color: #fbbf24;
        }
        
        .panel-type {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .panel-type.live {
            color: #f87171;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .panel-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #555;
            text-align: center;
            padding: 20px;
        }
        
        .panel-empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        
        .panel-empty-text {
            font-size: 13px;
            line-height: 1.5;
        }
        
        /* Breaker Detail View */
        .detail-section {
            margin-bottom: 20px;
        }
        
        .detail-section:last-child {
            margin-bottom: 0;
        }
        
        .detail-section-title {
            font-size: 10px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #2a2a2e;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .live-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #60a5fa;
            animation: pulse-live 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-live {
            0%, 100% { opacity: 1; box-shadow: 0 0 6px #60a5fa; }
            50% { opacity: 0.6; box-shadow: 0 0 3px #60a5fa; }
        }
        
        .detail-id {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
        }
        
        .detail-badges {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .detail-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 4px;
        }
        
        .detail-badge.nq { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .detail-badge.es { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        .detail-badge.bull { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .detail-badge.bear { background: rgba(249, 115, 22, 0.2); color: #fb923c; }
        .detail-badge.active { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .detail-badge.success { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
        .detail-badge.fail { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #222;
        }
        
        .detail-row:last-child {
            border-bottom: none;
        }
        
        .detail-label {
            color: #888;
            font-size: 12px;
        }
        
        .detail-value {
            font-family: 'JetBrains Mono', monospace;
            color: #ddd;
            font-size: 12px;
            font-weight: 500;
        }
        
        .detail-value.large {
            font-size: 18px;
            color: #fff;
        }
        
        /* Entry Context View */
        .context-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: 16px;
        }
        
        .context-grid {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .context-row {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            background: #151517;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .context-row.active {
            background: rgba(251, 191, 36, 0.12);
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
        }
        
        .context-row.live-active-row {
            background: rgba(251, 191, 36, 0.12);
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
        }
        
        .context-tf {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            width: 36px;
            color: #888;
        }
        
        .context-symbol {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            width: 28px;
            padding: 2px 4px;
            border-radius: 3px;
            text-align: center;
            margin-right: 10px;
        }
        
        .context-symbol.nq { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .context-symbol.es { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        
        .context-dir {
            font-size: 11px;
            font-weight: 600;
            width: 50px;
        }
        
        .context-dir.bull { color: #60a5fa; }
        .context-dir.bear { color: #fb923c; }
        .context-dir.none { color: #555; }
        
        .context-header {
            display: flex;
            align-items: center;
            padding: 4px 10px;
            font-size: 9px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #2a2a2e;
            margin-bottom: 4px;
        }
        
        .context-header span:nth-child(1) { width: 36px; }
        .context-header span:nth-child(2) { width: 38px; }
        .context-header span:nth-child(3) { width: 50px; }
        .context-header span:nth-child(4) { flex: 1; }
        .context-header span:nth-child(5) { width: 24px; text-align: center; }
        
        .context-fib {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #aaa;
            flex: 1;
        }
        
        .context-status-icon {
            font-size: 11px;
            width: 24px;
            text-align: center;
        }
        
        .context-status-icon.active { color: #60a5fa; }
        .context-status-icon.success { color: #4ade80; }
        .context-status-icon.fail { color: #f87171; }
        .context-status-icon.none { color: #444; }
        
        .arrow-bull { color: #4ade80; }
        .arrow-bear { color: #f87171; }
        
        .context-summary {
            margin-top: 16px;
            padding: 12px;
            background: #151517;
            border-radius: 6px;
        }
        
        .context-summary-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }
        
        .context-summary-label {
            color: #888;
            font-size: 12px;
        }
        
        .context-summary-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 12px;
        }
        
        .context-summary-value.good { color: #4ade80; }
        .context-summary-value.bad { color: #f87171; }
        .context-summary-value.neutral { color: #fbbf24; }
        
        /* Fib Chart */
        .fib-chart-container {
            margin-top: 8px;
            background: #151517;
            border-radius: 6px;
            padding: 12px;
        }
        
        .fib-chart {
            width: 100%;
            height: 120px;
        }
        
        .fib-chart-axis {
            stroke: #333;
            stroke-width: 1;
        }
        
        .fib-chart-grid {
            stroke: #222;
            stroke-width: 1;
            stroke-dasharray: 2, 4;
        }
        
        .fib-chart-line {
            fill: none;
            stroke: #60a5fa;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        .fib-chart-area {
            fill: url(#fibGradient);
            opacity: 0.3;
        }
        
        .fib-chart-dot {
            fill: #60a5fa;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .fib-chart-dot:hover {
            fill: #fff;
            r: 5;
        }
        
        .fib-chart-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            fill: #666;
        }
        
        .fib-chart-value-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            fill: #888;
        }
        
        .fib-chart-peak {
            fill: #4ade80;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .fib-peak-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            fill: #4ade80;
            font-weight: 600;
        }
        
        .fib-chart-container {
            position: relative;
        }
        
        .fib-cursor-line {
            stroke: #fbbf24;
            stroke-width: 1;
            stroke-dasharray: 3, 3;
            opacity: 0;
            pointer-events: none;
        }
        
        .fib-cursor-dot {
            fill: #fbbf24;
            opacity: 0;
            pointer-events: none;
        }
        
        .fib-cursor-tooltip {
            position: absolute;
            background: #252528;
            border: 1px solid #3a3a3e;
            border-radius: 4px;
            padding: 6px 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 10;
            white-space: nowrap;
        }
        
        .fib-cursor-tooltip .fib-val {
            color: #60a5fa;
            font-weight: 600;
        }
        
        .fib-cursor-tooltip .time-val {
            color: #888;
            margin-left: 8px;
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .toast.error { background: #dc2626; }
        .toast.success { background: #16a34a; }
        
        /* Legend */
        .legend {
            display: flex;
            gap: 12px;
            align-items: center;
            font-size: 11px;
            color: #888;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-swatch {
            width: 18px;
            height: 14px;
            border-radius: 3px;
            position: relative;
        }
        
        .legend-swatch.nq-bull { background: #16a34a; }
        .legend-swatch.nq-bear { background: #dc2626; }
        .legend-swatch.es-bull { background: #16a34a; }
        .legend-swatch.es-bear { background: #dc2626; }
        
        /* ES legend swatches get bottom stripe */
        .legend-swatch.es-bull::after,
        .legend-swatch.es-bear::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 0 0 3px 3px;
        }
        
        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 700;
            border: 2px solid rgba(255,255,255,0.8);
            color: #fff;
        }
        
        .legend-dot.win { 
            background: #16a34a;
        }
        .legend-dot.loss { 
            background: #dc2626;
        }
        
        .legend-swatch.entry { 
            background: #fbbf24; 
            width: 3px; 
            height: 16px;
        }
        
        .legend-divider {
            width: 1px;
            height: 16px;
            background: #3a3a3e;
            margin: 0 4px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1c;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #3a3a3e;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a4e;
        }
        
        /* Analysis Modal - Redesigned */
        .analysis-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
        }
        
        .analysis-modal-overlay.visible { display: flex; }
        
        .analysis-modal {
            background: linear-gradient(180deg, #1a1a1c 0%, #0f0f11 100%);
            border-radius: 16px;
            border: 1px solid #333;
            width: calc(100% - 40px);
            max-width: none;
            height: calc(100% - 40px);
            max-height: none;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.7);
            position: relative;
        }
        
        /* Hero Section */
        .analysis-hero {
            padding: 28px 32px 20px;
            background: linear-gradient(135deg, rgba(35, 35, 40, 0.9) 0%, rgba(25, 25, 30, 0.9) 100%);
            border-bottom: 1px solid #333;
            position: relative;
        }
        
        .analysis-hero-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(255,255,255,0.08);
            border: none;
            color: #666;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.2s;
        }
        
        .analysis-hero-close:hover { background: rgba(255,255,255,0.12); color: #fff; }
        
        .analysis-hero-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .analysis-hero-decision {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .analysis-decision-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: 800;
            padding: 14px 32px;
            border-radius: 10px;
            letter-spacing: 3px;
        }
        
        .analysis-decision-badge.execute {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.08) 100%);
            color: #4ade80;
            border: 2px solid rgba(74, 222, 128, 0.3);
            box-shadow: 0 0 40px rgba(74, 222, 128, 0.15);
        }
        
        .analysis-decision-badge.caution {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2) 0%, rgba(251, 191, 36, 0.08) 100%);
            color: #fbbf24;
            border: 2px solid rgba(251, 191, 36, 0.3);
            box-shadow: 0 0 40px rgba(251, 191, 36, 0.15);
        }
        
        .analysis-decision-badge.skip, .analysis-decision-badge.blocked {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.08) 100%);
            color: #f87171;
            border: 2px solid rgba(248, 113, 113, 0.3);
            box-shadow: 0 0 40px rgba(248, 113, 113, 0.15);
        }
        
        .analysis-hero-id {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: #94a3b8;
        }
        
        .analysis-hero-meta {
            font-size: 12px;
            color: #64748b;
            margin-top: 2px;
        }
        
        .analysis-hero-score {
            text-align: right;
        }
        
        .analysis-score-big {
            font-family: 'JetBrains Mono', monospace;
            font-size: 36px;
            font-weight: 700;
            color: #fff;
        }
        
        .analysis-score-label {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Category Tabs */
        .analysis-tabs {
            display: flex;
            background: rgba(15, 15, 18, 0.6);
            border-bottom: 1px solid #333;
            padding: 0 24px;
        }
        
        .analysis-tab {
            padding: 16px 24px;
            font-size: 12px;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -1px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .analysis-tab:hover { color: #94a3b8; background: rgba(255,255,255,0.02); }
        
        .analysis-tab.active {
            color: #fff;
            border-bottom-color: #60a5fa;
            background: rgba(96, 165, 250, 0.05);
        }
        
        .analysis-tab-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 10px;
        }
        
        .analysis-tab-count.all-pass { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-tab-count.has-warn { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-tab-count.has-fail { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        .analysis-tab-count.has-error { background: rgba(248, 113, 113, 0.4); color: #fff; }
        
        /* Content Area */
        .analysis-content {
            flex: 1;
            overflow-y: auto;
            padding: 28px;
        }
        
        .analysis-panel { display: none; }
        .analysis-panel.active { display: block; }
        
        /* Dimension Cards */
        .analysis-cards {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        
        .analysis-card {
            background: rgba(30, 30, 35, 0.5);
            border: 1px solid #2a2a30;
            border-radius: 12px;
            padding: 20px 24px;
            transition: all 0.2s;
        }
        
        .analysis-card:hover {
            border-color: #3a3a45;
            background: rgba(40, 40, 48, 0.5);
        }
        
        .analysis-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        
        .analysis-card-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .analysis-card-code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.12);
            padding: 4px 10px;
            border-radius: 5px;
        }
        
        .analysis-card-name {
            font-size: 14px;
            font-weight: 600;
            color: #e2e8f0;
        }
        
        .analysis-card-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 700;
            padding: 6px 16px;
            border-radius: 5px;
        }
        
        .analysis-card-value.pass { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-card-value.warn { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-card-value.fail { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        .analysis-card-value.error { background: rgba(248, 113, 113, 0.3); color: #f87171; font-size: 9px; }
        
        .analysis-card.error-card {
            border: 1px solid rgba(248, 113, 113, 0.5);
            background: rgba(248, 113, 113, 0.05);
        }
        
        /* Visual breakdown section */
        .analysis-card-visual {
            margin-bottom: 16px;
        }
        
        /* Bias row for direction dimensions */
        .analysis-bias-row {
            display: flex;
            gap: 8px;
        }
        
        .analysis-bias-item {
            flex: 1;
            background: rgba(0,0,0,0.25);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }
        
        .analysis-bias-tf {
            font-size: 10px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .analysis-bias-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 600;
        }
        
        .analysis-bias-value.bullish { color: #4ade80; }
        .analysis-bias-value.bearish { color: #f87171; }
        .analysis-bias-value.neutral { color: #fbbf24; }
        
        /* TF count bars for support/resistance */
        .analysis-tf-bars {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            height: 60px;
            padding: 0 10px;
        }
        
        .analysis-tf-bar {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .analysis-tf-bar-fill {
            width: 100%;
            border-radius: 4px 4px 0 0;
            min-height: 4px;
            transition: height 0.3s;
        }
        
        .analysis-tf-bar-fill.support { background: linear-gradient(180deg, #4ade80 0%, #22c55e 100%); }
        .analysis-tf-bar-fill.resistance { background: linear-gradient(180deg, #f87171 0%, #ef4444 100%); }
        .analysis-tf-bar-fill.empty { background: rgba(255,255,255,0.08); height: 4px !important; }
        
        .analysis-tf-bar-label {
            font-size: 10px;
            color: #64748b;
            font-weight: 600;
        }
        
        .analysis-tf-bar-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #ccc;
            font-weight: 600;
        }
        
        /* Metric row for energy/gate */
        .analysis-metric-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .analysis-metric {
            background: rgba(0,0,0,0.25);
            border-radius: 6px;
            padding: 10px 14px;
            flex: 1;
            min-width: 70px;
        }
        
        .analysis-metric-label {
            font-size: 9px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .analysis-metric-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            font-weight: 600;
            color: #e2e8f0;
        }
        
        .analysis-metric-value.pass { color: #4ade80; }
        .analysis-metric-value.warn { color: #fbbf24; }
        .analysis-metric-value.fail { color: #f87171; }
        
        /* Calculation explanation */
        .analysis-card-calc {
            margin-top: 14px;
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.06);
        }
        
        .analysis-calc-title {
            font-size: 9px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }
        
        .analysis-calc-text {
            font-size: 12px;
            color: #94a3b8;
            line-height: 1.5;
        }
        
        /* Failed breakers visual */
        .analysis-failed-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .analysis-failed-item {
            background: rgba(0,0,0,0.25);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            border: 1px solid transparent;
        }
        
        .analysis-failed-item.failed {
            border-color: rgba(74, 222, 128, 0.3);
            background: rgba(74, 222, 128, 0.1);
        }
        
        .analysis-failed-item-label {
            font-size: 9px;
            color: #64748b;
            margin-bottom: 4px;
        }
        
        .analysis-failed-item-status {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
        }
        
        .analysis-failed-item.failed .analysis-failed-item-status { color: #4ade80; }
        .analysis-failed-item:not(.failed) .analysis-failed-item-status { color: #64748b; }
        
        /* Premium/Discount gauge */
        .analysis-gauge {
            position: relative;
            height: 20px;
            background: linear-gradient(90deg, #4ade80 0%, #fbbf24 50%, #f87171 100%);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .analysis-gauge-marker {
            position: absolute;
            top: 2px;
            bottom: 2px;
            width: 4px;
            background: #fff;
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(0,0,0,0.5);
        }
        
        .analysis-gauge-labels {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #64748b;
            margin-top: 6px;
        }
        
        /* Progress bar for burn/ratios */
        .analysis-progress {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .analysis-progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
        
        .analysis-progress-fill.good { background: linear-gradient(90deg, #4ade80, #22c55e); }
        .analysis-progress-fill.warn { background: linear-gradient(90deg, #fbbf24, #f59e0b); }
        .analysis-progress-fill.bad { background: linear-gradient(90deg, #f87171, #ef4444); }
        
        
        
        .analysis-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #333;
            background: linear-gradient(135deg, #1e1e20 0%, #252528 100%);
        }
        
        .analysis-modal-title {
            font-size: 16px;
            font-weight: 600;
            color: #60a5fa;
        }
        
        .analysis-modal-subtitle {
            font-size: 12px;
            color: #888;
            margin-top: 2px;
        }
        
        .analysis-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .analysis-modal-close:hover {
            background: #333;
            color: #fff;
        }
        
        .analysis-modal-body {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .analysis-categories {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr auto;
            gap: 16px;
            flex: 1;
            min-height: 0;
        }
        
        .analysis-category.gate {
            grid-column: 1 / -1;
            min-height: auto;
            max-height: fit-content;
        }
        
        .analysis-category.gate .analysis-category-body {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .analysis-category.gate .analysis-dimension {
            margin-bottom: 0;
        }
        
        .analysis-category.gate .analysis-dimension .analysis-dimension-detail {
            display: none;
        }
        
        .analysis-category.gate .analysis-dimension.expanded .analysis-dimension-detail {
            display: block;
        }
        
        .analysis-category {
            background: rgba(30, 30, 32, 0.6);
            border-radius: 8px;
            border: 1px solid #333;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .analysis-category-header {
            padding: 10px 14px;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .analysis-category-toggle {
            font-size: 10px;
            color: #666;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 3px;
            background: rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        
        .analysis-category-toggle:hover {
            background: rgba(0,0,0,0.4);
            color: #aaa;
        }
        
        .analysis-category.gate .analysis-category-header {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.15) 0%, rgba(251, 191, 36, 0.05) 100%);
            color: #fbbf24;
        }
        
        .analysis-category.direction .analysis-category-header {
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.15) 0%, rgba(96, 165, 250, 0.05) 100%);
            color: #60a5fa;
        }
        
        .analysis-category.support .analysis-category-header {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
            color: #4ade80;
        }
        
        .analysis-category.resistance .analysis-category-header {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.15) 0%, rgba(248, 113, 113, 0.05) 100%);
            color: #f87171;
        }
        
        .analysis-category.energy .analysis-category-header {
            background: linear-gradient(135deg, rgba(192, 132, 252, 0.15) 0%, rgba(192, 132, 252, 0.05) 100%);
            color: #c084fc;
        }
        
        .analysis-category-body {
            padding: 10px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }
        
        .analysis-dimension {
            border-radius: 4px;
            margin-bottom: 6px;
            background: rgba(40, 40, 44, 0.4);
            overflow: hidden;
        }
        
        .analysis-dimension:last-child {
            margin-bottom: 0;
        }
        
        .analysis-dimension-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .analysis-dimension-header:hover {
            background: rgba(60, 60, 64, 0.4);
        }
        
        .analysis-dimension-left {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .analysis-dimension-name {
            font-size: 12px;
            color: #ccc;
        }
        
        .analysis-dimension-code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #666;
            background: rgba(0,0,0,0.2);
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .analysis-dimension-expand {
            color: #666;
            font-size: 10px;
            transition: transform 0.2s;
        }
        
        .analysis-dimension.expanded .analysis-dimension-expand {
            transform: rotate(180deg);
        }
        
        .analysis-dimension-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            padding: 3px 10px;
            border-radius: 3px;
            min-width: 80px;
            text-align: center;
        }
        
        .analysis-dimension-value.pass,
        .analysis-dimension-value.aligned,
        .analysis-dimension-value.converged,
        .analysis-dimension-value.strong,
        .analysis-dimension-value.confirms,
        .analysis-dimension-value.clear,
        .analysis-dimension-value.high,
        .analysis-dimension-value.powered,
        .analysis-dimension-value.discount,
        .analysis-dimension-value.available {
            background: rgba(74, 222, 128, 0.15);
            color: #4ade80;
        }
        
        .analysis-dimension-value.warn,
        .analysis-dimension-value.moderate,
        .analysis-dimension-value.partial,
        .analysis-dimension-value.neutral,
        .analysis-dimension-value.friction,
        .analysis-dimension-value.equilibrium,
        .analysis-dimension-value.limited {
            background: rgba(251, 191, 36, 0.15);
            color: #fbbf24;
        }
        
        .analysis-dimension-value.fail,
        .analysis-dimension-value.opposed,
        .analysis-dimension-value.diverged,
        .analysis-dimension-value.weak,
        .analysis-dimension-value.none,
        .analysis-dimension-value.conflicts,
        .analysis-dimension-value.blocked,
        .analysis-dimension-value.low,
        .analysis-dimension-value.exhausted,
        .analysis-dimension-value.premium {
            background: rgba(248, 113, 113, 0.15);
            color: #f87171;
        }
        
        .analysis-dimension-detail {
            display: none;
            padding: 12px 14px;
            background: rgba(20, 20, 22, 0.6);
            border-top: 1px solid rgba(255,255,255,0.05);
            font-size: 11px;
            line-height: 1.6;
        }
        
        .analysis-dimension.expanded .analysis-dimension-detail {
            display: block;
        }
        
        .analysis-detail-question {
            color: #888;
            font-style: italic;
            margin-bottom: 10px;
        }
        
        .analysis-detail-reason {
            font-size: 12px;
            color: #e2e8f0;
            padding: 10px 12px;
            margin-bottom: 10px;
            background: rgba(96, 165, 250, 0.1);
            border-left: 3px solid #60a5fa;
            border-radius: 0 4px 4px 0;
        }
        
        .analysis-detail-calc {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 10px 12px;
            margin-bottom: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
        }
        
        .analysis-detail-calc-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .analysis-detail-calc-row:last-child {
            border-bottom: none;
            padding-top: 6px;
            margin-top: 4px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-weight: 600;
        }
        
        .analysis-detail-calc-label {
            color: #888;
        }
        
        .analysis-detail-calc-value {
            color: #ccc;
        }
        
        .analysis-detail-calc-value.pass { color: #4ade80; background: rgba(74, 222, 128, 0.15); padding: 1px 6px; border-radius: 3px; }
        .analysis-detail-calc-value.fail { color: #f87171; background: rgba(248, 113, 113, 0.15); padding: 1px 6px; border-radius: 3px; }
        .analysis-detail-calc-value.warn { color: #fbbf24; background: rgba(251, 191, 36, 0.15); padding: 1px 6px; border-radius: 3px; }
        
        .analysis-detail-logic {
            margin-top: 10px;
        }
        
        .analysis-detail-logic-title {
            color: #666;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        .analysis-detail-logic-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .analysis-detail-logic-table th,
        .analysis-detail-logic-table td {
            padding: 4px 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 10px;
        }
        
        .analysis-detail-logic-table th {
            color: #666;
            font-weight: 500;
        }
        
        .analysis-detail-logic-table td {
            color: #aaa;
        }
        
        .analysis-detail-logic-table tr.active {
            background: rgba(96, 165, 250, 0.1);
        }
        
        .analysis-detail-logic-table tr.active td {
            color: #60a5fa;
        }
        
        /* Zone visualization */
        .analysis-zones {
            margin-top: 12px;
        }
        
        .analysis-zones-title {
            color: #666;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .analysis-zones-entry {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
            padding: 2px 8px;
            border-radius: 3px;
        }
        
        .analysis-zone-stack {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .analysis-zone {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: rgba(30, 30, 34, 0.6);
            border-radius: 4px;
            border-left: 3px solid #444;
            font-size: 10px;
        }
        
        .analysis-zone.tf-4h { border-left-color: #c084fc; }
        .analysis-zone.tf-1h { border-left-color: #60a5fa; }
        .analysis-zone.tf-15m { border-left-color: #4ade80; }
        .analysis-zone.tf-5m { border-left-color: #fbbf24; }
        .analysis-zone.tf-1m { border-left-color: #f87171; }
        
        .analysis-zone-tf {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            min-width: 32px;
            padding: 2px 6px;
            border-radius: 3px;
            text-align: center;
            font-size: 9px;
        }
        
        .analysis-zone.tf-4h .analysis-zone-tf { background: rgba(192, 132, 252, 0.2); color: #c084fc; }
        .analysis-zone.tf-1h .analysis-zone-tf { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .analysis-zone.tf-15m .analysis-zone-tf { background: rgba(74, 222, 128, 0.2); color: #4ade80; }
        .analysis-zone.tf-5m .analysis-zone-tf { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
        .analysis-zone.tf-1m .analysis-zone-tf { background: rgba(248, 113, 113, 0.2); color: #f87171; }
        
        .analysis-zone-type {
            color: #888;
            min-width: 50px;
        }
        
        .analysis-zone-type.bull { color: #4ade80; }
        .analysis-zone-type.bear { color: #f87171; }
        
        .analysis-zone-range {
            font-family: 'JetBrains Mono', monospace;
            color: #ccc;
            min-width: 120px;
        }
        
        .analysis-zone-fib {
            font-family: 'JetBrains Mono', monospace;
            padding: 2px 6px;
            border-radius: 3px;
            min-width: 55px;
            text-align: center;
        }
        
        .analysis-zone-fib.fresh { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-zone-fib.tested { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-zone-fib.extended { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        
        .analysis-zone-dist {
            font-family: 'JetBrains Mono', monospace;
            color: #888;
            min-width: 60px;
            text-align: right;
        }
        
        .analysis-zone-status {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            min-width: 50px;
            text-align: center;
        }
        
        .analysis-zone-status.active { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-zone-status.touched { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-zone-status.broken { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        
        /* ===== ENHANCED VISUALS ===== */
        
        /* Price Ladder - Unified Support/Resistance View */
        .price-ladder {
            position: relative;
            margin: 12px 0;
            padding: 16px;
            background: linear-gradient(180deg, rgba(15,15,18,0.95) 0%, rgba(20,20,25,0.9) 100%);
            border-radius: 10px;
            border: 1px solid #333;
            min-height: 280px;
        }
        
        .price-ladder-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .price-ladder-title {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .price-ladder-legend {
            display: flex;
            gap: 12px;
            font-size: 9px;
            color: #888;
        }
        
        .price-ladder-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .price-ladder-legend-swatch {
            width: 12px;
            height: 8px;
            border-radius: 2px;
        }
        
        .price-ladder-legend-swatch.breaker-support { background: rgba(74, 222, 128, 0.4); border: 1px solid #4ade80; }
        .price-ladder-legend-swatch.fvg-support { background: rgba(74, 222, 128, 0.2); border: 1px dashed rgba(74, 222, 128, 0.5); }
        .price-ladder-legend-swatch.breaker-resist { background: rgba(248, 113, 113, 0.4); border: 1px solid #f87171; }
        .price-ladder-legend-swatch.fvg-resist { background: rgba(248, 113, 113, 0.2); border: 1px dashed rgba(248, 113, 113, 0.5); }
        
        .price-ladder-body {
            display: flex;
            height: 240px;
        }
        
        .price-ladder-axis {
            width: 60px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            border-right: 1px solid #333;
            padding-right: 8px;
            margin-right: 12px;
        }
        
        .price-ladder-axis-tick {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: #555;
            text-align: right;
        }
        
        .price-ladder-axis-tick.entry { color: #60a5fa; font-weight: 600; }
        .price-ladder-axis-tick.target { color: #4ade80; font-weight: 600; }
        .price-ladder-axis-tick.stop { color: #f87171; font-weight: 600; }
        
        .price-ladder-chart {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        /* Price level lines */
        .price-ladder-level {
            position: absolute;
            left: 0;
            right: 80px;
            height: 2px;
            display: flex;
            align-items: center;
        }
        
        .price-ladder-level-line {
            flex: 1;
            height: 100%;
        }
        
        .price-ladder-level.entry .price-ladder-level-line {
            background: #60a5fa;
            box-shadow: 0 0 10px rgba(96, 165, 250, 0.6);
        }
        
        .price-ladder-level.target .price-ladder-level-line {
            background: repeating-linear-gradient(90deg, #4ade80 0, #4ade80 6px, transparent 6px, transparent 10px);
        }
        
        .price-ladder-level.stop .price-ladder-level-line {
            background: #f87171;
            box-shadow: 0 0 8px rgba(248, 113, 113, 0.5);
        }
        
        .price-ladder-level-label {
            position: absolute;
            right: 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            padding: 3px 8px;
            border-radius: 3px;
            white-space: nowrap;
        }
        
        .price-ladder-level.entry .price-ladder-level-label {
            background: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
            border: 1px solid rgba(96, 165, 250, 0.4);
        }
        
        .price-ladder-level.target .price-ladder-level-label {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .price-ladder-level.stop .price-ladder-level-label {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        /* Zone blocks */
        .price-ladder-zone {
            position: absolute;
            left: 0;
            right: 85px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            transition: all 0.15s;
            cursor: default;
        }
        
        .price-ladder-zone:hover {
            transform: translateX(4px);
            z-index: 10;
        }
        
        .price-ladder-zone.support-breaker {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.35) 0%, rgba(74, 222, 128, 0.15) 100%);
            border: 1px solid rgba(74, 222, 128, 0.6);
            border-left: 3px solid #4ade80;
            color: #4ade80;
        }
        
        .price-ladder-zone.support-fvg {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.08) 100%);
            border: 1px dashed rgba(74, 222, 128, 0.5);
            color: rgba(74, 222, 128, 0.9);
        }
        
        .price-ladder-zone.resist-breaker {
            background: linear-gradient(90deg, rgba(248, 113, 113, 0.35) 0%, rgba(248, 113, 113, 0.15) 100%);
            border: 1px solid rgba(248, 113, 113, 0.6);
            border-left: 3px solid #f87171;
            color: #f87171;
        }
        
        .price-ladder-zone.resist-fvg {
            background: linear-gradient(90deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.08) 100%);
            border: 1px dashed rgba(248, 113, 113, 0.5);
            color: rgba(248, 113, 113, 0.9);
        }
        
        /* TF badge colors */
        .price-ladder-zone .zone-tf {
            font-weight: 600;
            padding: 1px 4px;
            border-radius: 2px;
            margin-right: 6px;
            font-size: 8px;
        }
        
        .price-ladder-zone.tf-4h .zone-tf { background: rgba(192, 132, 252, 0.3); color: #c084fc; }
        .price-ladder-zone.tf-1h .zone-tf { background: rgba(96, 165, 250, 0.3); color: #60a5fa; }
        .price-ladder-zone.tf-15m .zone-tf { background: rgba(74, 222, 128, 0.3); color: #4ade80; }
        .price-ladder-zone.tf-5m .zone-tf { background: rgba(251, 191, 36, 0.3); color: #fbbf24; }
        
        .price-ladder-zone .zone-info {
            margin-left: auto;
            opacity: 0.7;
            font-size: 8px;
        }
        
        /* Current price arrow */
        .price-ladder-current {
            position: absolute;
            left: -6px;
            width: 0;
            height: 0;
            border-top: 7px solid transparent;
            border-bottom: 7px solid transparent;
            border-left: 10px solid #60a5fa;
            filter: drop-shadow(0 0 4px rgba(96, 165, 250, 0.8));
            z-index: 20;
        }
        
        /* R:R sidebar */
        .price-ladder-rr {
            position: absolute;
            right: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        
        .price-ladder-rr-segment {
            width: 14px;
            border-radius: 2px;
        }
        
        .price-ladder-rr-segment.reward { background: linear-gradient(180deg, #4ade80, rgba(74, 222, 128, 0.3)); }
        .price-ladder-rr-segment.risk { background: linear-gradient(0deg, #f87171, rgba(248, 113, 113, 0.3)); }
        
        .price-ladder-rr-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            color: #4ade80;
            margin: 4px 0;
        }
        
        /* Direction Flow Visual */
        .direction-flow {
            margin: 8px 0;
        }
        
        .direction-flow-row {
            display: flex;
            align-items: center;
            padding: 8px 0;
        }
        
        .direction-flow-symbol {
            width: 36px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            color: #888;
        }
        
        .direction-flow-tfs {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .direction-flow-tf {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .direction-flow-tf-label {
            font-size: 9px;
            color: #666;
            margin-bottom: 4px;
        }
        
        .direction-flow-tf-box {
            width: 44px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            position: relative;
        }
        
        .direction-flow-tf-box.bullish {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.25) 0%, rgba(74, 222, 128, 0.1) 100%);
            border: 1px solid rgba(74, 222, 128, 0.5);
            color: #4ade80;
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.2);
        }
        
        .direction-flow-tf-box.bearish {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.25) 0%, rgba(248, 113, 113, 0.1) 100%);
            border: 1px solid rgba(248, 113, 113, 0.5);
            color: #f87171;
            box-shadow: 0 0 12px rgba(248, 113, 113, 0.2);
        }
        
        .direction-flow-tf-box.neutral {
            background: rgba(100, 100, 100, 0.15);
            border: 1px solid rgba(150, 150, 150, 0.3);
            color: #888;
        }
        
        .direction-flow-arrow {
            width: 24px;
            height: 2px;
            margin: 0 -4px;
            position: relative;
            top: 4px;
        }
        
        .direction-flow-arrow::after {
            content: '';
            position: absolute;
            right: 0;
            top: -3px;
            border: 4px solid transparent;
        }
        
        .direction-flow-arrow.aligned {
            background: #4ade80;
        }
        
        .direction-flow-arrow.aligned::after {
            border-left-color: #4ade80;
        }
        
        .direction-flow-arrow.mixed {
            background: linear-gradient(90deg, #fbbf24, #f87171);
        }
        
        .direction-flow-arrow.mixed::after {
            border-left-color: #f87171;
        }
        
        .direction-flow-result {
            width: 85px;
            text-align: center;
            padding: 6px 10px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 600;
        }
        
        .direction-flow-result.aligned {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.08) 100%);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .direction-flow-result.partial {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2) 0%, rgba(251, 191, 36, 0.08) 100%);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.4);
        }
        
        .direction-flow-result.opposed, .direction-flow-result.diverged {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.08) 100%);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        /* Inversion Grid */
        .inversion-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin: 8px 0;
        }
        
        .inversion-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
            transition: all 0.2s;
        }
        
        .inversion-cell.failed {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
            border-color: rgba(74, 222, 128, 0.4);
        }
        
        .inversion-cell.active {
            background: rgba(60, 60, 60, 0.2);
            border-color: #444;
        }
        
        .inversion-cell-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: #888;
            margin-bottom: 6px;
        }
        
        .inversion-cell-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        .inversion-cell.failed .inversion-cell-icon { color: #4ade80; }
        .inversion-cell.active .inversion-cell-icon { color: #666; }
        
        .inversion-cell-status {
            font-size: 8px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .inversion-cell.failed .inversion-cell-status { color: #4ade80; }
        .inversion-cell.active .inversion-cell-status { color: #666; }
        
        /* ADR Burn Gauges */
        .burn-gauges {
            display: flex;
            gap: 24px;
            justify-content: center;
            padding: 8px 0;
        }
        
        .burn-gauge {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .burn-gauge-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            color: #888;
            margin-bottom: 8px;
        }
        
        .burn-gauge-ring {
            position: relative;
            width: 80px;
            height: 80px;
        }
        
        .burn-gauge-ring svg {
            transform: rotate(-90deg);
        }
        
        .burn-gauge-bg {
            fill: none;
            stroke: #333;
            stroke-width: 6;
        }
        
        .burn-gauge-fill {
            fill: none;
            stroke-width: 6;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }
        
        .burn-gauge-fill.available { stroke: #4ade80; }
        .burn-gauge-fill.limited { stroke: #fbbf24; }
        .burn-gauge-fill.exhausted { stroke: #f87171; }
        
        .burn-gauge-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 700;
        }
        
        .burn-gauge-value.available { color: #4ade80; }
        .burn-gauge-value.limited { color: #fbbf24; }
        .burn-gauge-value.exhausted { color: #f87171; }
        
        .burn-gauge-status {
            margin-top: 6px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .burn-gauge-status.available { color: #4ade80; }
        .burn-gauge-status.limited { color: #fbbf24; }
        .burn-gauge-status.exhausted { color: #f87171; }
        
        /* Formation Visual - FVG + Sweep */
        .formation-visual {
            position: relative;
            margin: 8px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
            height: 120px;
        }
        
        .formation-visual-bar {
            position: absolute;
            left: 30%;
            width: 40%;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
        }
        
        .formation-visual-bar.breaker {
            background: linear-gradient(90deg, rgba(96, 165, 250, 0.3) 0%, rgba(96, 165, 250, 0.15) 100%);
            border: 1px solid rgba(96, 165, 250, 0.5);
            color: #60a5fa;
        }
        
        .formation-visual-bar.fvg {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.4) 0%, rgba(74, 222, 128, 0.2) 100%);
            border: 1px solid rgba(74, 222, 128, 0.6);
            color: #4ade80;
        }
        
        .formation-visual-sweep {
            position: absolute;
            left: 15%;
            width: 2px;
            background: #fbbf24;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.5);
        }
        
        .formation-visual-sweep::before {
            content: '⚡';
            position: absolute;
            left: -8px;
            top: -10px;
            font-size: 12px;
        }
        
        .formation-visual-label {
            position: absolute;
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            color: #888;
        }
        
        /* Attraction Zone Visual */
        .attraction-visual {
            margin: 8px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .attraction-visual-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .attraction-visual-tf {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 4px;
        }
        
        .attraction-visual-tf.bullish {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .attraction-visual-tf.bearish {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        .attraction-visual-sd {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .attraction-visual-sd-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 700;
        }
        
        .attraction-visual-sd-label {
            font-size: 9px;
            color: #888;
        }
        
        .attraction-visual-phase {
            padding: 4px 10px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 600;
        }
        
        .attraction-visual-phase.fresh {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .attraction-visual-phase.tested {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.4);
        }
        
        .attraction-visual-phase.exhausted {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        .attraction-visual-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .attraction-visual-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
        
        .attraction-visual-bar-fill.bullish { background: linear-gradient(90deg, #4ade80, rgba(74, 222, 128, 0.5)); }
        .attraction-visual-bar-fill.bearish { background: linear-gradient(90deg, #f87171, rgba(248, 113, 113, 0.5)); }
        
        /* R:R Visual for Gate */
        .rr-visual {
            margin: 8px 0;
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .rr-visual-prices {
            display: flex;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        
        .rr-visual-price {
            text-align: center;
        }
        
        .rr-visual-price-label {
            font-size: 9px;
            color: #888;
            margin-bottom: 4px;
        }
        
        .rr-visual-price-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 600;
        }
        
        .rr-visual-price.entry .rr-visual-price-value { color: #60a5fa; }
        .rr-visual-price.stop .rr-visual-price-value { color: #f87171; }
        .rr-visual-price.target .rr-visual-price-value { color: #4ade80; }
        
        .rr-visual-bar {
            position: relative;
            height: 32px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        
        .rr-visual-bar-risk {
            position: absolute;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, #f87171, rgba(248, 113, 113, 0.3));
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #f87171;
        }
        
        .rr-visual-bar-reward {
            position: absolute;
            right: 0;
            height: 100%;
            background: linear-gradient(270deg, #4ade80, rgba(74, 222, 128, 0.3));
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #4ade80;
        }
        
        .rr-visual-bar-entry {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #60a5fa;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.8);
        }
        
        .rr-visual-ratio {
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 700;
        }
        
        .rr-visual-ratio.pass { color: #4ade80; }
        .rr-visual-ratio.fail { color: #f87171; }
        
        /* VIX Gauge */
        .vix-gauge {
            margin: 8px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .vix-gauge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .vix-gauge-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: 700;
        }
        
        .vix-gauge-value.stable { color: #4ade80; }
        .vix-gauge-value.elevated { color: #fbbf24; }
        .vix-gauge-value.high { color: #f87171; }
        
        .vix-gauge-ratio {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 4px;
        }
        
        .vix-gauge-ratio.stable {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }
        
        .vix-gauge-ratio.elevated {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }
        
        .vix-gauge-ratio.high {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }
        
        .vix-gauge-bar {
            height: 6px;
            background: linear-gradient(90deg, #4ade80 0%, #fbbf24 50%, #f87171 100%);
            border-radius: 3px;
            position: relative;
        }
        
        .vix-gauge-marker {
            position: absolute;
            top: -4px;
            width: 4px;
            height: 14px;
            background: #fff;
            border-radius: 2px;
            transform: translateX(-50%);
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.5);
        }
        
        /* Premium/Discount Gauge */
        .pd-gauge {
            margin: 8px 0;
        }
        
        .pd-gauge-bar {
            position: relative;
            height: 24px;
            background: linear-gradient(90deg, 
                rgba(74, 222, 128, 0.3) 0%, 
                rgba(74, 222, 128, 0.15) 35%,
                rgba(251, 191, 36, 0.15) 35%,
                rgba(251, 191, 36, 0.15) 65%,
                rgba(248, 113, 113, 0.15) 65%,
                rgba(248, 113, 113, 0.3) 100%
            );
            border-radius: 4px;
            border: 1px solid #444;
        }
        
        .pd-gauge-marker {
            position: absolute;
            top: -2px;
            width: 4px;
            height: 28px;
            background: #fff;
            border-radius: 2px;
            transform: translateX(-50%);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
        }
        
        .pd-gauge-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 9px;
            color: #888;
        }
        
        .pd-gauge-labels span:first-child { color: #4ade80; }
        .pd-gauge-labels span:last-child { color: #f87171; }
        
        /* Session Indicator */
        .session-visual {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .session-visual-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 600;
            color: #fff;
        }
        
        .session-visual-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
        }
        
        .session-visual-badge.active {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.25) 0%, rgba(74, 222, 128, 0.1) 100%);
            border: 1px solid rgba(74, 222, 128, 0.5);
            color: #4ade80;
        }
        
        .session-visual-badge.inactive {
            background: rgba(100, 100, 100, 0.2);
            border: 1px solid #555;
            color: #888;
        }
        
        /* Visual Zone Chart */
        .analysis-zone-chart {
            position: relative;
            margin: 16px 0;
            padding: 12px;
            background: rgba(15, 15, 18, 0.8);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .analysis-zone-chart-title {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        
        .analysis-zone-chart-inner {
            position: relative;
            height: 280px;
            display: flex;
        }
        
        .analysis-zone-chart-axis {
            width: 70px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px 0;
            border-right: 1px solid #333;
            margin-right: 12px;
        }
        
        .analysis-zone-chart-price {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: #666;
            text-align: right;
            padding-right: 8px;
        }
        
        .analysis-zone-chart-price.entry { color: #60a5fa; font-weight: 600; }
        .analysis-zone-chart-price.target { color: #4ade80; font-weight: 600; }
        .analysis-zone-chart-price.stop { color: #f87171; font-weight: 600; }
        
        .analysis-zone-chart-body {
            flex: 1;
            position: relative;
        }
        
        .analysis-zone-chart-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: #333;
        }
        
        .analysis-zone-chart-line.entry {
            background: #60a5fa;
            height: 2px;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.5);
        }
        
        .analysis-zone-chart-line.target {
            background: #4ade80;
            height: 2px;
            border-style: dashed;
            box-shadow: 0 0 8px rgba(74, 222, 128, 0.5);
        }
        
        .analysis-zone-chart-line.stop {
            background: #f87171;
            height: 2px;
            box-shadow: 0 0 8px rgba(248, 113, 113, 0.5);
        }
        
        .analysis-zone-chart-label {
            position: absolute;
            right: 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            transform: translateY(-50%);
        }
        
        .analysis-zone-chart-label.entry {
            background: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
        }
        
        .analysis-zone-chart-label.target {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }
        
        .analysis-zone-chart-label.stop {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }
        
        .analysis-zone-chart-zone {
            position: absolute;
            left: 80px;
            right: 60px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding-left: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            opacity: 0.9;
            transition: opacity 0.2s;
        }
        
        .analysis-zone-chart-zone:hover {
            opacity: 1;
        }
        
        .analysis-zone-chart-zone.bull {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.3) 0%, rgba(74, 222, 128, 0.1) 100%);
            border-left: 3px solid #4ade80;
            color: #4ade80;
        }
        
        .analysis-zone-chart-zone.bear {
            background: linear-gradient(90deg, rgba(248, 113, 113, 0.3) 0%, rgba(248, 113, 113, 0.1) 100%);
            border-left: 3px solid #f87171;
            color: #f87171;
        }
        
        .analysis-zone-chart-zone-tf {
            font-weight: 600;
            min-width: 28px;
        }
        
        .analysis-zone-chart-zone.tf-4h { border-left-color: #c084fc; }
        .analysis-zone-chart-zone.tf-1h { border-left-color: #60a5fa; }
        .analysis-zone-chart-zone.tf-15m { border-left-color: #4ade80; }
        .analysis-zone-chart-zone.tf-5m { border-left-color: #fbbf24; }
        
        .analysis-zone-chart-zone.tf-4h .analysis-zone-chart-zone-tf { color: #c084fc; }
        .analysis-zone-chart-zone.tf-1h .analysis-zone-chart-zone-tf { color: #60a5fa; }
        .analysis-zone-chart-zone.tf-15m .analysis-zone-chart-zone-tf { color: #4ade80; }
        .analysis-zone-chart-zone.tf-5m .analysis-zone-chart-zone-tf { color: #fbbf24; }
        
        .analysis-zone-chart-current {
            position: absolute;
            left: 75px;
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 8px solid #60a5fa;
            transform: translateY(-50%);
        }
        
        .analysis-zones-summary {
            margin-top: 8px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-size: 10px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .analysis-zones-summary-result {
            font-weight: 600;
        }
        
        .analysis-zones-summary-result.strong { color: #4ade80; }
        .analysis-zones-summary-result.moderate { color: #fbbf24; }
        .analysis-zones-summary-result.weak { color: #f87171; }
        
        .analysis-zone-ladder {
            position: relative;
            margin: 12px 0;
            padding-left: 20px;
            border-left: 2px solid #333;
        }
        
        .analysis-zone-ladder-entry {
            position: relative;
            padding: 6px 0 6px 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #60a5fa;
        }
        
        .analysis-zone-ladder-entry::before {
            content: '►';
            position: absolute;
            left: -8px;
            color: #60a5fa;
            font-size: 8px;
        }
        
        .analysis-zone-ladder-target {
            position: relative;
            padding: 6px 0 6px 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #4ade80;
        }
        
        .analysis-zone-ladder-target::before {
            content: '◆';
            position: absolute;
            left: -8px;
            color: #4ade80;
            font-size: 8px;
        }
        
        .analysis-zone-ladder-stop {
            position: relative;
            padding: 6px 0 6px 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #f87171;
        }
        
        .analysis-zone-ladder-stop::before {
            content: '■';
            position: absolute;
            left: -7px;
            color: #f87171;
            font-size: 8px;
        }
        
        .analysis-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #1e1e20 0%, #252528 100%);
        }
        
        .analysis-decision {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .analysis-decision-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .analysis-decision-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            padding: 6px 16px;
            border-radius: 4px;
        }
        
        .analysis-decision-value.execute {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.1) 100%);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.3);
        }
        
        .analysis-decision-value.caution {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2) 0%, rgba(251, 191, 36, 0.1) 100%);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }
        
        .analysis-decision-value.skip {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.1) 100%);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.3);
        }
        
        .analysis-decision-value.blocked {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.3) 0%, rgba(180, 50, 50, 0.2) 100%);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.5);
        }
        
        .analysis-score {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .analysis-score-bar {
            width: 120px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .analysis-score-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .analysis-score-fill.high { background: #4ade80; }
        .analysis-score-fill.moderate { background: #fbbf24; }
        .analysis-score-fill.low { background: #f87171; }
        
        .analysis-score-text {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #888;
        }
        
        .analysis-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: #60a5fa;
            font-size: 11px;
            cursor: pointer;
            padding: 6px 10px;
            border-radius: 4px;
            background: rgba(96, 165, 250, 0.1);
            border: 1px solid rgba(96, 165, 250, 0.2);
            transition: all 0.2s;
            margin-top: 12px;
        }
        
        .analysis-link:hover {
            background: rgba(96, 165, 250, 0.2);
            border-color: rgba(96, 165, 250, 0.4);
        }
        
        .analysis-link-disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .analysis-link-disabled:hover {
            background: rgba(96, 165, 250, 0.1);
            border-color: rgba(96, 165, 250, 0.2);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-left">
            <div class="logo"><span class="logo-icon"></span> SigXFlow</div>
            <div class="stats-row">
                <div class="stat-compact success"><span id="stat-success">-</span> S</div>
                <div class="stat-compact fail"><span id="stat-fail">-</span> F</div>
                <div class="stat-compact win"><span id="stat-winrate">-</span></div>
            </div>
        </div>
        
        <div class="nav-group">
            <button class="btn inactive" id="mode-explore" onclick="setMode('explore')">🔍 Explore</button>
            <button class="btn live" id="mode-live" onclick="setMode('live')">🔴 Live</button>
            <div class="divider"></div>
            <div class="settings-group">
                <select class="select-styled" id="load-limit" onchange="loadData(true)">
                    <option value="8">Load 8hr</option>
                    <option value="12">Load 12hr</option>
                    <option value="24" selected>Load 1 day</option>
                    <option value="48">Load 2 days</option>
                    <option value="72">Load 3 days</option>
                    <option value="96">Load 4 days</option>
                    <option value="120">Load 5 days</option>
                    <option value="144">Load 6 days</option>
                </select>
                <select class="select-styled" id="refresh-interval" onchange="setRefreshInterval()">
                    <option value="0">Auto: Off</option>
                    <option value="30" selected>Auto: 30s</option>
                    <option value="60">Auto: 1m</option>
                    <option value="300">Auto: 5m</option>
                </select>
                <span class="countdown" id="countdown"></span>
                <button class="btn secondary" onclick="loadData(true)">↻</button>
                <button class="btn primary" onclick="goToLatest()">Latest →|</button>
            </div>
        </div>
    </div>
    
    <!-- Toolbar -->
    <div class="toolbar">
        <div class="legend">
            <div class="legend-item"><div class="legend-swatch nq-bull"></div>NQ Bull</div>
            <div class="legend-item"><div class="legend-swatch nq-bear"></div>NQ Bear</div>
            <div class="legend-item"><div class="legend-swatch es-bull"></div>ES Bull</div>
            <div class="legend-item"><div class="legend-swatch es-bear"></div>ES Bear</div>
            <div class="legend-divider"></div>
            <div class="legend-item"><div class="legend-dot win">S</div>Success</div>
            <div class="legend-item"><div class="legend-dot loss">F</div>Failure</div>
            <div class="legend-divider"></div>
            <div class="legend-item"><div class="legend-swatch entry"></div>Entry</div>
        </div>
        
        <div class="toolbar-right">
            <span class="status-msg" id="status-msg"></span>
            <div class="filter-group">
                <button class="filter-btn nq active" id="filter-nq" onclick="toggleFilter('nq')">NQ</button>
                <button class="filter-btn es active" id="filter-es" onclick="toggleFilter('es')">ES</button>
            </div>
            <div class="filter-group">
                <button class="filter-btn bull active" id="filter-bull" onclick="toggleFilter('bull')"><span class="arrow-up"></span> Bull</button>
                <button class="filter-btn bear active" id="filter-bear" onclick="toggleFilter('bear')"><span class="arrow-down"></span> Bear</button>
            </div>
        </div>
    </div>
    
    <!-- Main Wrapper -->
    <div class="main-wrapper">
        <!-- Chart Area -->
        <div class="chart-area">
            <div class="header-row">
                <div class="left-header" id="data-start">--</div>
                <div class="time-header-wrapper">
                    <div class="timeline-track" id="timeline-track">
                        <div class="timeline-viewport" id="viewport-indicator"></div>
                    </div>
                    <div class="time-header" id="time-header"></div>
                </div>
            </div>
            <div class="scroll-container" id="scroll-container">
                <div class="scroll-inner">
                    <div class="left-panel" id="left-panel"></div>
                    <div class="right-panel">
                        <div class="chart-inner" id="chart-inner"></div>
                    </div>
                </div>
            </div>
            <div class="sticky-date" id="sticky-date"></div>
        </div>
        
        <!-- Detail Panel -->
        <div class="detail-panel">
            <div class="panel-header">
                <span class="panel-time" id="panel-time"></span>
                <span class="panel-type" id="panel-type">Details</span>
            </div>
            <div class="panel-content" id="panel-content">
                <div class="panel-empty">
                    <div class="panel-empty-icon">📋</div>
                    <div class="panel-empty-text">
                        Click a breaker bar or entry line to see details
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>
    
    <!-- Analysis Modal -->
    <div class="analysis-modal-overlay" id="analysis-modal" onclick="closeAnalysisModal(event)">
        <div class="analysis-modal" onclick="event.stopPropagation()">
            <!-- Hero Section with Decision -->
            <div class="analysis-hero">
                <button class="analysis-hero-close" onclick="closeAnalysisModal()">&times;</button>
                <div class="analysis-hero-top">
                    <div class="analysis-hero-decision">
                        <span class="analysis-decision-badge" id="analysis-decision-badge">EXECUTE</span>
                        <div>
                            <div class="analysis-hero-id" id="analysis-hero-id">NQ_1m_20250115_1205</div>
                            <div class="analysis-hero-meta" id="analysis-hero-meta">10:05 AM ET</div>
                        </div>
                    </div>
                    <div class="analysis-hero-score">
                        <div class="analysis-score-big" id="analysis-score-big">18/21</div>
                        <div class="analysis-score-label">Dimensions Passed</div>
                    </div>
                </div>
            </div>
            
            <!-- Category Tabs -->
            <div class="analysis-tabs" id="analysis-tabs">
                <!-- Tabs generated by JS -->
            </div>
            
            <!-- Content Area -->
            <div class="analysis-content" id="analysis-content">
                <!-- Category panels generated by JS -->
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIG =====
        const FIREBASE_URL = "https://sigxflow-default-rtdb.firebaseio.com/snapshots.json";
        const SMT_FIREBASE_URL = "https://sigxflow-default-rtdb.firebaseio.com/smt_signals.json";
        const PIXELS_PER_MINUTE = 30;
        const BAR_HEIGHT = 26;  // Height of breaker bars
        const BAR_GAP = 3;      // Gap between stacked bars
        const LANE_PADDING = 6; // Top/bottom padding in swimlanes
        const TF_HEADER_HEIGHT = 2;
        const LEFT_PANEL_MIN_HEIGHT = 68; // Minimum based on left panel content
        
        const TF_ORDER = ['1m', '5m', '15m', '1h', '4h'];
        const TF_DISPLAY = { '4h': '4H', '1h': '1H', '15m': '15m', '5m': '5m', '1m': '1m' };
        const SYMBOLS = ['NQ', 'ES'];
        
        // ===== STATE =====
        let allData = [];
        let smtData = [];  // SMT signals
        let breakerCache = {}; // For incremental updates
        let windowStartMin = 0;
        let windowEndMin = 0;
        let dataMinTime = 0;
        let dataMaxTime = 0;
        let isLive = true;
        let isFirstLoad = true;
        let lastFetchedTime = null; // Track last observation_time for incremental fetch
        let lastLoadLimit = null; // Track if limit changed (requires full reload)
        let refreshTimer = null;
        let countdownTimer = null;
        let countdownSecs = 0;
        let selectedEntryMin = null;
        let selectedBreakerId = null;
        let entryTimes = [];
        let chartAbortController = null; // For cleaning up event listeners
        let renderedBars = []; // Cached bar elements for fast highlight
        let renderedLaneLabels = []; // Cached lane labels
        let laneStats = {}; // Stats per tf/symbol/direction
        
        const filters = {
            nq: true, es: true,
            bull: true, bear: true
        };
        
        // ===== UTILITIES =====
        function datetimeToMin(datetime) {
            const parts = datetime.replace('T', ' ').split(' ');
            const dateParts = parts[0].split('-');
            const timeParts = (parts[1] || '00:00').split(':');
            const d = new Date(
                parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]),
                parseInt(timeParts[0]), parseInt(timeParts[1])
            );
            return Math.floor(d.getTime() / 60000);
        }
        
        function minToTime(m) {
            const d = new Date(m * 60000);
            return d.getHours().toString().padStart(2, '0') + ':' + 
                   d.getMinutes().toString().padStart(2, '0');
        }
        
        function minToDateTime(m) {
            const d = new Date(m * 60000);
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            return months[d.getMonth()] + ' ' + d.getDate() + ', ' + minToTime(m);
        }
        
        function minToDateStr(m) {
            const d = new Date(m * 60000);
            const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            return days[d.getDay()] + ' ' + months[d.getMonth()] + ' ' + d.getDate();
        }
        
        function minToDateKey(m) {
            // Returns YYYY-MM-DD for comparison
            const d = new Date(m * 60000);
            return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
        }
        
        function minToShortDateTime(m) {
            // Returns compact date+time like "1/14 10:05"
            const d = new Date(m * 60000);
            return (d.getMonth() + 1) + '/' + d.getDate() + ' ' + 
                   d.getHours().toString().padStart(2, '0') + ':' + 
                   d.getMinutes().toString().padStart(2, '0');
        }
        
        function minToDuration(startMin, endMin) {
            const mins = endMin - startMin;
            if (mins < 60) return mins + 'm';
            const hrs = Math.floor(mins / 60);
            const rem = mins % 60;
            return rem > 0 ? `${hrs}h ${rem}m` : `${hrs}h`;
        }
        
        let toastTimeout = null;
        
        function showToast(msg, type = '') {
            const el = document.getElementById('status-msg');
            el.textContent = msg;
            el.className = 'status-msg ' + type;
            // Clear previous timeout and set new one
            if (toastTimeout) clearTimeout(toastTimeout);
            if (type !== 'error') {
                toastTimeout = setTimeout(() => {
                    el.textContent = '';
                    toastTimeout = null;
                }, 5000);
            }
        }
        
        // ===== STACKING ALGORITHM =====
        function assignStackPositions(breakers) {
            if (!breakers.length) return [];
            
            const sorted = [...breakers].sort((a, b) => a.startMin - b.startMin);
            const stackEnds = [];
            
            sorted.forEach(b => {
                let stackIdx = 0;
                while (stackIdx < stackEnds.length && stackEnds[stackIdx] > b.startMin) {
                    stackIdx++;
                }
                
                b.stackIdx = stackIdx;
                stackEnds[stackIdx] = b.endMin + 1;
            });
            
            return sorted;
        }
        
        // ===== WINDOW MANAGEMENT =====
        function setWindow(startMin, endMin, label) {
            windowStartMin = startMin;
            windowEndMin = endMin;
            
            updateViewportIndicator();
        }
        
        function updateMiniTimeline() {
            updateViewportIndicator();
        }
        
        function setMode(mode) {
            isLive = (mode === 'live');
            
            const exploreBtn = document.getElementById('mode-explore');
            const liveBtn = document.getElementById('mode-live');
            
            if (isLive) {
                liveBtn.classList.remove('inactive');
                exploreBtn.classList.remove('explore-active');
                exploreBtn.classList.add('inactive');
                // Show live confluence if data exists and nothing selected
                if (allData.length > 0 && !selectedBreakerId && !selectedEntryMin) {
                    showLiveConfluence();
                }
            } else {
                exploreBtn.classList.remove('inactive');
                exploreBtn.classList.add('explore-active');
                liveBtn.classList.add('inactive');
                // Clear live highlights
                clearLiveHighlight();
                // Only show empty panel if nothing selected
                if (!selectedBreakerId && !selectedEntryMin) {
                    showEmptyPanel();
                }
            }
            
            loadData();
        }
        
        function goToLatest() {
            if (dataMaxTime === 0) {
                showToast('No data loaded', 'error');
                return;
            }
            
            const container = document.getElementById('scroll-container');
            container.scrollLeft = container.scrollWidth;
        }
        
        function shiftWindow(direction) {
            if (dataMinTime === 0 || dataMaxTime === 0) {
                showToast('No data loaded', 'error');
                return;
            }
            
            const windowHours = getLoadHours();
            const shift = direction * windowHours * 60;
            let newStart = windowStartMin + shift;
            let newEnd = windowEndMin + shift;
            
            if (newStart < dataMinTime) {
                newStart = dataMinTime;
                newEnd = newStart + windowHours * 60;
            }
            if (newEnd > dataMaxTime) {
                newEnd = dataMaxTime;
                newStart = Math.max(dataMinTime, newEnd - windowHours * 60);
            }
            
            if (newStart === windowStartMin && newEnd === windowEndMin) {
                showToast('No more data in that direction', 'error');
                return;
            }
            
            windowStartMin = newStart;
            windowEndMin = newEnd;
            setWindow(windowStartMin, windowEndMin, 'Custom ' + windowHours + 'hr');
            renderChart();
            
            setTimeout(() => {
                const container = document.getElementById('scroll-container');
                if (direction > 0) {
                    container.scrollLeft = 0;
                } else {
                    container.scrollLeft = container.scrollWidth;
                }
            }, 50);
        }
        
        function advanceLiveWindow() {
            // Get current time in minutes (matching how datetimeToMin works)
            const now = new Date();
            const nowMin = Math.floor(now.getTime() / 60000);
            
            // Extend dataMaxTime to now if it's behind
            if (nowMin > dataMaxTime) {
                dataMaxTime = nowMin;
            }
            
            // In live mode, keep window at the latest edge
            const windowSize = windowEndMin - windowStartMin;
            windowEndMin = dataMaxTime;
            windowStartMin = Math.max(dataMinTime, dataMaxTime - windowSize);
            
            setWindow(windowStartMin, windowEndMin, 'Live');
            renderChart();
            
            // Scroll to right edge and show live confluence (only if nothing selected)
            setTimeout(() => {
                const container = document.getElementById('scroll-container');
                container.scrollLeft = container.scrollWidth;
                if (!selectedBreakerId && !selectedEntryMin) {
                    showLiveConfluence();
                }
            }, 50);
        }
        
        // ===== FILTERS =====
        function toggleFilter(key) {
            filters[key] = !filters[key];
            // Convert camelCase to kebab-case for button ID
            const btnId = 'filter-' + key.replace(/([A-Z])/g, '-$1').toLowerCase();
            const btn = document.getElementById(btnId);
            if (btn) btn.classList.toggle('active', filters[key]);
            renderChart();
        }
        
        // ===== DATA LOADING =====
        function getLoadHours() {
            const el = document.getElementById('load-limit');
            return el ? parseInt(el.value) : 8;
        }
        
        function loadData(forceFullLoad = false) {
            const currentHours = getLoadHours();
            
            const needsFullLoad = forceFullLoad || 
                                  !lastFetchedTime || 
                                  lastLoadLimit !== currentHours ||
                                  Object.keys(breakerCache).length === 0;
            
            lastLoadLimit = currentHours;
            
            if (needsFullLoad) {
                // Full load with server-side time filtering
                showToast('Loading...', '');
                
                // Also reload SMT data
                loadSmtData();
                
                // For multi-day loads during market closures, always use fallback
                // (indexed query uses wall clock time which misses old data when market is closed)
                const useFullLoad = currentHours >= 24;
                
                if (useFullLoad) {
                    // Load all data and filter client-side based on LATEST DATA TIME
                    console.log(`📊 Loading ${currentHours} hours - using full load for accuracy`);
                    
                    fetch(FIREBASE_URL)
                        .then(r => {
                            if (!r.ok) throw new Error('HTTP ' + r.status);
                            return r.json();
                        })
                        .then(data => {
                            if (!data) throw new Error('No data');
                            
                            let entries = Object.entries(data)
                                .filter(([k, v]) => v && v.observation_time);
                            
                            if (entries.length === 0) throw new Error('No valid data');
                            
                            // Find the latest observation time
                            let latestTime = '';
                            let earliestTime = 'Z';
                            entries.forEach(([k, v]) => {
                                if (v.observation_time > latestTime) latestTime = v.observation_time;
                                if (v.observation_time < earliestTime) earliestTime = v.observation_time;
                            });
                            
                            console.log(`📊 Full data range: ${earliestTime} to ${latestTime}`);
                            
                            // Calculate cutoff from LATEST DATA TIME (not wall clock)
                            const latestMin = datetimeToMin(latestTime);
                            const cutoffMin = latestMin - (currentHours * 60);
                            
                            console.log(`📊 Filtering to ${currentHours} hours before latest data (cutoff: ${minToDateTime(cutoffMin)})`);
                            
                            // Filter to only include snapshots within time range
                            const beforeFilter = entries.length;
                            entries = entries.filter(([k, v]) => {
                                const snapMin = datetimeToMin(v.observation_time);
                                return snapMin >= cutoffMin;
                            });
                            
                            console.log(`📊 After filter: ${entries.length} snapshots (removed ${beforeFilter - entries.length})`);
                            
                            // Sort by time
                            entries.sort((a, b) => {
                                const tsA = a[1].observation_time || '';
                                const tsB = b[1].observation_time || '';
                                return tsA.localeCompare(tsB);
                            });
                            
                            const limited = {};
                            entries.forEach(([k, v]) => limited[k] = v);
                            
                            processFirebaseData(limited, true);
                        })
                        .catch(err => {
                            showToast('Error: ' + err.message, 'error');
                            console.error(err);
                        });
                } else {
                    // For short time ranges (<24h), use indexed query with wall clock time
                    const now = new Date();
                    const cutoffDate = new Date(now.getTime() - (currentHours * 60 * 60 * 1000));
                    
                    const pad = n => n.toString().padStart(2, '0');
                    const cutoffISO = `${cutoffDate.getFullYear()}-${pad(cutoffDate.getMonth()+1)}-${pad(cutoffDate.getDate())}T${pad(cutoffDate.getHours())}:${pad(cutoffDate.getMinutes())}:${pad(cutoffDate.getSeconds())}`;
                    
                    console.log(`📊 Loading ${currentHours} hours of data`);
                    console.log(`📊 Cutoff: ${cutoffISO}`);
                    
                    const filteredUrl = FIREBASE_URL + 
                        '?orderBy="observation_time"&startAt="' + cutoffISO + '"';
                    
                    fetch(filteredUrl)
                        .then(r => {
                            if (!r.ok) throw new Error('HTTP ' + r.status);
                            return r.json();
                        })
                        .then(data => {
                            if (!data) throw new Error('No data');
                            
                            let entries = Object.entries(data)
                                .filter(([k, v]) => v && v.observation_time);
                            
                            if (entries.length === 0) throw new Error('No valid data');
                            
                            const times = entries.map(([k, v]) => v.observation_time).sort();
                            console.log(`✓ Indexed query returned ${entries.length} snapshots`);
                            console.log(`✓ Data range: ${times[0]} to ${times[times.length-1]}`);
                            
                            entries.sort((a, b) => {
                                const tsA = a[1].observation_time || '';
                                const tsB = b[1].observation_time || '';
                                return tsA.localeCompare(tsB);
                            });
                            
                            const limited = {};
                            entries.forEach(([k, v]) => limited[k] = v);
                            
                            processFirebaseData(limited, true);
                        })
                        .catch(err => {
                            showToast('Error: ' + err.message, 'error');
                            console.error(err);
                        });
                }
            } else {
                // Incremental load - only fetch newer data from Firebase
                const url = FIREBASE_URL + 
                    '?orderBy="observation_time"&startAfter="' + lastFetchedTime + '"';
                
                console.log('Incremental fetch:', url);
                
                fetch(url)
                    .then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.json();
                    })
                    .then(data => {
                        if (!data || Object.keys(data).length === 0) {
                            // In Live mode, advance window to current time even if no data
                            if (isLive) {
                                advanceLiveWindow();
                                showToast('Live - no new data', '');
                            } else {
                                showToast('No new data', '');
                            }
                            return;
                        }
                        
                        console.log('Incremental data:', Object.keys(data).length, 'snapshots');
                        processIncrementalData(data);
                    })
                    .catch(err => {
                        // If query fails (no index), show error with instructions
                        console.error('Incremental fetch failed:', err);
                        showToast('Index needed - see console', 'error');
                    });
            }
        }
        
        function processFirebaseData(snapshots, isFullLoad = true) {
            if (isFullLoad) {
                breakerCache = {}; // Reset cache on full load
            }
            
            let snapshotList = Array.isArray(snapshots) 
                ? snapshots 
                : Object.values(snapshots).filter(s => s);
            
            if (snapshotList.length === 0) {
                showToast('No data', 'error');
                return;
            }
            
            snapshotList.sort((a, b) => {
                const tsA = a.observation_time || '';
                const tsB = b.observation_time || '';
                return tsA.localeCompare(tsB);
            });
            
            // Track the latest observation time for incremental fetches
            const latestSnap = snapshotList[snapshotList.length - 1];
            lastFetchedTime = latestSnap.observation_time;
            
            let minTime = Infinity, maxTime = 0;
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                if (ts) {
                    const min = datetimeToMin(ts);
                    if (min < minTime) minTime = min;
                    if (min > maxTime) maxTime = min;
                }
            });
            
            dataMinTime = minTime;
            dataMaxTime = maxTime;
            
            console.log(`📊 Processing ${snapshotList.length} snapshots`);
            console.log(`📊 Time range: ${minToDateTime(minTime)} to ${minToDateTime(maxTime)}`);
            console.log(`📊 Duration: ${((maxTime - minTime) / 60).toFixed(1)} hours`);
            
            // Show all loaded data (use load limit, not hardcoded 8hr)
            windowEndMin = dataMaxTime;
            windowStartMin = dataMinTime;
            
            setWindow(windowStartMin, windowEndMin, 'Latest');
            
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                const datetime = ts.replace('T', ' ');
                const absMin = datetimeToMin(ts);
                
                Object.entries(snap.breakers || {}).forEach(([id, b]) => {
                    if (!breakerCache[id]) {
                        breakerCache[id] = {
                            id,
                            displayId: b.display_id || id,
                            tf: b.tf.toLowerCase(),
                            dir: b.dir.toLowerCase(),
                            status: 'active',
                            events: [],
                            maxFib: 0
                        };
                    }
                    
                    // Update display_id if we get a newer one
                    if (b.display_id) {
                        breakerCache[id].displayId = b.display_id;
                    }
                    
                    const fib = b.fib || 1;
                    // Avoid duplicate events (same timestamp)
                    if (!breakerCache[id].events.some(e => e.absMin === absMin)) {
                        breakerCache[id].events.push({ datetime, absMin, fib });
                    }
                    breakerCache[id].maxFib = Math.max(breakerCache[id].maxFib, fib);
                    
                    if (b.status === 'success' || b.status === 'fail') {
                        breakerCache[id].status = b.status;
                    }
                });
            });
            
            finalizeBreakers();
            
            showToast('Loaded ' + allData.length + ' breakers', 'success');
        }
        
        function processIncrementalData(snapshots) {
            let snapshotList = Array.isArray(snapshots) 
                ? snapshots 
                : Object.values(snapshots).filter(s => s);
            
            if (snapshotList.length === 0) {
                showToast('No new data', '');
                return;
            }
            
            snapshotList.sort((a, b) => {
                const tsA = a.observation_time || '';
                const tsB = b.observation_time || '';
                return tsA.localeCompare(tsB);
            });
            
            // Update lastFetchedTime
            const latestSnap = snapshotList[snapshotList.length - 1];
            lastFetchedTime = latestSnap.observation_time;
            
            // Update max time
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                if (ts) {
                    const min = datetimeToMin(ts);
                    if (min > dataMaxTime) dataMaxTime = min;
                }
            });
            
            // Merge into cache
            let newBreakers = 0;
            
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                const datetime = ts.replace('T', ' ');
                const absMin = datetimeToMin(ts);
                
                Object.entries(snap.breakers || {}).forEach(([id, b]) => {
                    if (!breakerCache[id]) {
                        breakerCache[id] = {
                            id,
                            displayId: b.display_id || id,
                            tf: b.tf.toLowerCase(),
                            dir: b.dir.toLowerCase(),
                            status: 'active',
                            events: [],
                            maxFib: 0
                        };
                        newBreakers++;
                    }
                    
                    // Update display_id if we get a newer one
                    if (b.display_id) {
                        breakerCache[id].displayId = b.display_id;
                    }
                    
                    const fib = b.fib || 1;
                    // Avoid duplicate events (same timestamp)
                    if (!breakerCache[id].events.some(e => e.absMin === absMin)) {
                        breakerCache[id].events.push({ datetime, absMin, fib });
                    }
                    breakerCache[id].maxFib = Math.max(breakerCache[id].maxFib, fib);
                    
                    if (b.status === 'success' || b.status === 'fail') {
                        breakerCache[id].status = b.status;
                    }
                });
            });
            
            // Update window to include new data
            // In live mode, keep window size fixed and slide it
            if (isLive) {
                const windowSize = windowEndMin - windowStartMin;
                windowEndMin = dataMaxTime;
                windowStartMin = Math.max(dataMinTime, dataMaxTime - windowSize);
            } else {
                windowEndMin = dataMaxTime;
            }
            setWindow(windowStartMin, windowEndMin, 'Latest');
            
            finalizeBreakers();
            
            showToast(`+${snapshotList.length} snapshots, ${newBreakers} new breakers`, 'success');
        }
        
        // Prune data outside retention window to prevent memory growth
        function pruneOldData() {
            if (dataMaxTime === 0) return;
            
            // Use load limit + 30 min buffer as retention window
            const loadHours = getLoadHours();
            const retentionMinutes = (loadHours * 60) + 30;
            const cutoffMin = dataMaxTime - retentionMinutes;
            
            console.log(`📊 Prune check: retention=${loadHours}h, cutoff=${minToDateTime(cutoffMin)}, maxTime=${minToDateTime(dataMaxTime)}`);
            
            let pruned = 0;
            
            for (const id in breakerCache) {
                const breaker = breakerCache[id];
                // Remove breakers that ended before the cutoff
                if (breaker.endMin && breaker.endMin < cutoffMin) {
                    delete breakerCache[id];
                    pruned++;
                }
            }
            
            // Update dataMinTime
            if (pruned > 0) {
                const remaining = Object.values(breakerCache);
                if (remaining.length > 0) {
                    dataMinTime = Math.min(...remaining.map(d => d.startMin || d.events[0]?.absMin || dataMaxTime));
                }
            }
        }
        
        function finalizeBreakers() {
            // First, set startMin/endMin on all breakers in cache
            for (const id in breakerCache) {
                const d = breakerCache[id];
                if (d.events.length > 0) {
                    d.events.sort((a, b) => a.absMin - b.absMin);
                    d.startMin = d.events[0]?.absMin || 0;
                    d.endMin = d.events[d.events.length - 1]?.absMin || 0;
                }
            }
            
            const beforePrune = Object.keys(breakerCache).length;
            
            // Prune old data (needs endMin to be set first)
            pruneOldData();
            
            const afterPrune = Object.keys(breakerCache).length;
            if (beforePrune !== afterPrune) {
                console.log(`📊 Pruned ${beforePrune - afterPrune} old breakers`);
            }
            
            allData = Object.values(breakerCache);
            allData.forEach(d => {
                // Limit events per breaker to prevent huge fib charts
                if (d.events.length > 500) {
                    d.events = d.events.slice(-500);
                }
                d.symbol = d.id.toUpperCase().includes('NQ') ? 'NQ' : 'ES';
            });
            
            // Extract 1M NQ Bull entry times
            entryTimes = allData
                .filter(d => d.symbol === 'NQ' && d.tf === '1m' && d.dir === 'bull')
                .map(d => d.startMin);
            
            updateStats();
            renderChart();
            
            // In live mode: always scroll to latest and show live confluence
            // In explore mode: only scroll on first load
            if (isLive || isFirstLoad) {
                setTimeout(() => {
                    const container = document.getElementById('scroll-container');
                    container.scrollLeft = container.scrollWidth;
                    updateViewportIndicator();
                    // Only show live confluence if nothing selected
                    if (isLive && !selectedBreakerId && !selectedEntryMin) {
                        showLiveConfluence();
                    }
                }, 50);
                isFirstLoad = false;
            }
        }
        
        // ===== STATS =====
        function updateStats() {
            // Calculate overall stats (NQ Bull 1M only - the primary trading signal)
            const primary = { success: 0, fail: 0 };
            
            // Calculate stats per tf/symbol/direction
            laneStats = {};
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    ['bull', 'bear'].forEach(dir => {
                        laneStats[`${tf}-${symbol}-${dir}`] = { success: 0, fail: 0 };
                    });
                });
            });
            
            allData.forEach(d => {
                const status = d.status.toLowerCase();
                const tf = d.tf.replace('hr', 'h');
                const key = `${tf}-${d.symbol}-${d.dir}`;
                
                // Primary stats: NQ Bull 1M only
                if (tf === '1m' && d.symbol === 'NQ' && d.dir === 'bull') {
                    if (status === 'success') primary.success++;
                    else if (status === 'fail') primary.fail++;
                }
                
                // Per-lane stats
                if (laneStats[key]) {
                    if (status === 'success') laneStats[key].success++;
                    else if (status === 'fail') laneStats[key].fail++;
                }
            });
            
            const completed = primary.success + primary.fail;
            const winRate = completed > 0 ? Math.round(primary.success / completed * 100) : 0;
            
            document.getElementById('stat-success').textContent = primary.success;
            document.getElementById('stat-fail').textContent = primary.fail;
            document.getElementById('stat-winrate').textContent = winRate + '%';
        }
        
        function getLaneStats(tf, symbol, dir) {
            const key = `${tf}-${symbol}-${dir}`;
            const stats = laneStats[key] || { success: 0, fail: 0 };
            const total = stats.success + stats.fail;
            const pct = total > 0 ? Math.round(stats.success / total * 100) : 0;
            return { wins: stats.success, losses: stats.fail, total, pct };
        }
        
        // ===== RENDERING =====
        function renderChart() {
            // Clean up previous event listeners
            if (chartAbortController) {
                chartAbortController.abort();
                chartAbortController = null;
            }
            chartAbortController = new AbortController();
            const signal = chartAbortController.signal;
            
            const leftPanel = document.getElementById('left-panel');
            const chartInner = document.getElementById('chart-inner');
            const timeHeader = document.getElementById('time-header');
            
            leftPanel.innerHTML = '';
            chartInner.innerHTML = '';
            timeHeader.innerHTML = '';
            
            // Clear cached element arrays
            renderedBars = [];
            renderedLaneLabels = [];
            
            // Preserve selections across re-renders (both explore and live mode)
            const preservedEntryMin = selectedEntryMin;
            const preservedBreakerId = selectedBreakerId;
            const preservedSmtId = selectedSmtId;
            
            selectedEntryMin = null;
            selectedBreakerId = null;
            selectedSmtId = null;
            
            // Calculate chart width based on data, add padding for future fade effect
            const chartWidth = (windowEndMin - windowStartMin) * PIXELS_PER_MINUTE + (PIXELS_PER_MINUTE * 2);
            
            chartInner.style.width = chartWidth + 'px';
            timeHeader.style.width = chartWidth + 'px';
            
            // Time header ticks - snap to 5-minute boundaries
            const tickInterval = 5;
            const firstTick = Math.ceil(windowStartMin / tickInterval) * tickInterval;
            
            // Track dates for separators
            let lastDateKey = null;
            const dateSeparators = []; // Store positions for chart separators
            
            // For multi-day views, show date in time labels
            const loadHours = getLoadHours();
            const showDateInLabels = loadHours >= 24;
            
            for (let m = firstTick; m <= windowEndMin; m += tickInterval) {
                const x = (m - windowStartMin) * PIXELS_PER_MINUTE;
                const currentDateKey = minToDateKey(m);
                
                // Add date separator when day changes
                if (lastDateKey !== null && currentDateKey !== lastDateKey) {
                    // Store for chart vertical line
                    dateSeparators.push({ x: x, date: minToDateStr(m) });
                }
                lastDateKey = currentDateKey;
                
                const tick = document.createElement('div');
                tick.className = 'time-tick-label';
                tick.style.left = x + 'px';
                
                // Show date+time for multi-day views, just time for single day
                if (showDateInLabels) {
                    tick.textContent = minToShortDateTime(m);
                } else {
                    tick.textContent = minToTime(m);
                }
                timeHeader.appendChild(tick);
            }
            
            // Add date separators to chart (vertical lines spanning full height)
            dateSeparators.forEach(sep => {
                const line = document.createElement('div');
                line.className = 'date-separator';
                line.style.left = sep.x + 'px';
                chartInner.appendChild(line);
            });
            
            // Store date separators for sticky date calculation
            window.dateSeparatorPositions = dateSeparators;
            
            // Filter data for window
            let windowData = allData.filter(d => {
                if (d.endMin < windowStartMin || d.startMin > windowEndMin) return false;
                if (d.symbol === 'NQ' && !filters.nq) return false;
                if (d.symbol === 'ES' && !filters.es) return false;
                if (d.dir === 'bull' && !filters.bull) return false;
                if (d.dir === 'bear' && !filters.bear) return false;
                return true;
            });
            
            // Limit total bars to prevent browser crash (prioritize recent)
            const MAX_BARS = 500;
            if (windowData.length > MAX_BARS) {
                windowData.sort((a, b) => b.endMin - a.endMin);
                windowData = windowData.slice(0, MAX_BARS);
            }
            
            // Group by TF → Symbol
            const grouped = {};
            TF_ORDER.forEach(tf => {
                grouped[tf] = { NQ: [], ES: [] };
            });
            
            windowData.forEach(d => {
                const tf = d.tf.replace('hr', 'h');
                if (grouped[tf] && grouped[tf][d.symbol]) {
                    grouped[tf][d.symbol].push(d);
                }
            });
            
            // Determine which symbols are visible
            const visibleSymbols = SYMBOLS.filter(s => filters[s.toLowerCase()]);
            
            let totalHeight = 0;
            
            // Render TF sections
            TF_ORDER.forEach((tf, tfIndex) => {
                // TF divider spacer for left panel (matches chart divider height)
                const tfSpacer = document.createElement('div');
                tfSpacer.className = 'tf-spacer';
                tfSpacer.dataset.tf = tf;
                leftPanel.appendChild(tfSpacer);
                
                // TF divider - chart
                const tfHeaderChart = document.createElement('div');
                tfHeaderChart.className = 'tf-header-chart';
                // Width set via CSS to be viewport-based
                tfHeaderChart.dataset.tf = tf;
                chartInner.appendChild(tfHeaderChart);
                
                // TF_HEADER_HEIGHT for divider
                totalHeight += TF_HEADER_HEIGHT;
                
                // Calculate lane heights for all symbols in this TF first
                const laneHeights = {};
                let tfGroupHeight = 0;
                
                visibleSymbols.forEach((symbol, idx) => {
                    const breakers = grouped[tf][symbol];
                    const stackedBreakers = assignStackPositions(breakers);
                    const maxStack = stackedBreakers.length > 0 
                        ? Math.max(...stackedBreakers.map(b => b.stackIdx)) + 1 
                        : 1;
                    
                    // Calculate height needed for breaker stacking
                    const breakerStackHeight = LANE_PADDING * 2 + maxStack * (BAR_HEIGHT + BAR_GAP) - BAR_GAP;
                    
                    // Use the larger of left panel minimum or breaker stack needs
                    const laneHeight = Math.max(LEFT_PANEL_MIN_HEIGHT, breakerStackHeight);
                    
                    laneHeights[symbol] = laneHeight;
                    tfGroupHeight += laneHeight;
                });
                
                // Create TF group container for left panel
                const tfGroup = document.createElement('div');
                tfGroup.className = 'tf-group';
                // Height determined by children via flexbox
                tfGroup.dataset.tf = tf;
                
                // TF accent bar spanning all symbols
                const tfLabel = tf.toUpperCase();
                const tfAccent = document.createElement('div');
                tfAccent.className = 'tf-group-accent';
                tfAccent.dataset.tf = tf;
                tfAccent.textContent = tfLabel;
                tfGroup.appendChild(tfAccent);
                
                // Lanes container
                const tfLanes = document.createElement('div');
                tfLanes.className = 'tf-group-lanes';
                
                // Symbol lanes within this TF
                visibleSymbols.forEach((symbol, symbolIdx) => {
                    const breakers = grouped[tf][symbol];
                    const stackedBreakers = assignStackPositions(breakers);
                    const laneHeight = laneHeights[symbol];
                    
                    // Get stats for this lane
                    const bullStats = getLaneStats(tf, symbol, 'bull');
                    const bearStats = getLaneStats(tf, symbol, 'bear');
                    
                    // Lane row
                    const laneRow = document.createElement('div');
                    laneRow.className = 'lane-row';
                    // Only set explicit height if breakers need more than minimum
                    if (laneHeight > LEFT_PANEL_MIN_HEIGHT) {
                        laneRow.style.height = laneHeight + 'px';
                    }
                    laneRow.dataset.tf = tf;
                    laneRow.dataset.symbol = symbol;
                    
                    // Horizontal layout: symbol left, stats right
                    laneRow.innerHTML = `
                        <span class="symbol-badge ${symbol.toLowerCase()}">${symbol}</span>
                        <div class="lane-stats">
                            <div class="lane-stat-row">
                                <span class="lane-stat-dir bull"></span>
                                <span class="lane-stat-counts">${bullStats.wins}/${bullStats.losses}</span>
                                <div class="lane-stat-bar">
                                    <div class="lane-stat-fill bull" style="width: ${bullStats.pct}%"></div>
                                </div>
                                <span class="lane-stat-pct ${bullStats.total > 0 ? 'bull' : 'neutral'}">${bullStats.total > 0 ? bullStats.pct + '%' : '-'}</span>
                            </div>
                            <div class="lane-stat-row">
                                <span class="lane-stat-dir bear"></span>
                                <span class="lane-stat-counts">${bearStats.wins}/${bearStats.losses}</span>
                                <div class="lane-stat-bar">
                                    <div class="lane-stat-fill bear" style="width: ${bearStats.pct}%"></div>
                                </div>
                                <span class="lane-stat-pct ${bearStats.total > 0 ? 'bear' : 'neutral'}">${bearStats.total > 0 ? bearStats.pct + '%' : '-'}</span>
                            </div>
                        </div>
                    `;
                    
                    tfLanes.appendChild(laneRow);
                    
                    // Cache lane row for highlighting
                    renderedLaneLabels.push({ el: laneRow, tf: tf, symbol: symbol });
                    
                    // Swimlane
                    const swimlane = document.createElement('div');
                    swimlane.className = 'swimlane';
                    swimlane.style.width = chartWidth + 'px';
                    // Only set explicit height if breakers need more than minimum
                    if (laneHeight > LEFT_PANEL_MIN_HEIGHT) {
                        swimlane.style.height = laneHeight + 'px';
                    }
                    swimlane.dataset.symbol = symbol;
                    swimlane.dataset.tf = tf;
                    
                    // Render breaker bars with stacking
                    stackedBreakers.forEach(b => {
                        const bar = createBreakerBar(b, laneHeight);
                        swimlane.appendChild(bar);
                        // Cache bar with its time data for fast highlight
                        renderedBars.push({
                            el: bar,
                            startMin: b.startMin,
                            endMin: b.endMin,
                            tf: tf,
                            symbol: symbol
                        });
                    });
                    
                    // Render SMT markers in defensive asset lane
                    const tfNorm = tf.replace('hr', 'h').toLowerCase();
                    const smtForLane = smtData.filter(smt => {
                        const smtTfNorm = smt.tf.replace('m', 'm').replace('h', 'h').toLowerCase();
                        return smtTfNorm === tfNorm && 
                               smt.defensiveAsset === symbol &&
                               smt.smtMin >= windowStartMin && 
                               smt.smtMin <= windowEndMin;
                    });
                    
                    smtForLane.forEach(smt => {
                        const marker = createSmtMarker(smt, 0, laneHeight);
                        swimlane.appendChild(marker);
                    });
                    
                    chartInner.appendChild(swimlane);
                    totalHeight += laneHeight;
                });
                
                tfGroup.appendChild(tfLanes);
                leftPanel.appendChild(tfGroup);
            });
            
            // Render entry lines spanning full chart height
            // Subtract a few pixels for perfect alignment
            totalHeight -= 3;
            
            const windowEntries = entryTimes
                .filter(t => t >= windowStartMin && t <= windowEndMin)
                .slice(-100); // Limit entry lines
            
            windowEntries.forEach(entryMin => {
                const x = (entryMin - windowStartMin) * PIXELS_PER_MINUTE;
                
                // Entry line in chart
                const entryLine = document.createElement('div');
                entryLine.className = 'entry-line';
                entryLine.style.left = x + 'px';
                entryLine.style.height = totalHeight + 'px';
                entryLine.dataset.entryMin = entryMin;
                entryLine.title = 'Entry: ' + minToTime(entryMin);
                entryLine.onclick = () => selectEntry(entryMin);
                chartInner.appendChild(entryLine);
            });
            
            // Add cursor line
            const cursorLine = document.createElement('div');
            cursorLine.className = 'cursor-line';
            cursorLine.id = 'cursor-line';
            cursorLine.style.height = totalHeight + 'px';
            chartInner.appendChild(cursorLine);
            
            // Set chart inner height so absolute positioned elements span correctly
            chartInner.style.height = totalHeight + 'px';
            
            // Add cursor time tooltip to body (so it's not clipped)
            let cursorTime = document.getElementById('cursor-time');
            if (!cursorTime) {
                cursorTime = document.createElement('div');
                cursorTime.className = 'cursor-time';
                cursorTime.id = 'cursor-time';
                document.body.appendChild(cursorTime);
            }
            
            // Cursor line event handlers on scroll container
            const scrollContainer = document.getElementById('scroll-container');
            let lastClientX = null;
            let lastCursorMin = null;
            let cursorUpdatePending = false;
            
            function updateCursorPosition(clientX, isScroll = false) {
                const scrollRect = scrollContainer.getBoundingClientRect();
                const leftPanelWidth = 195; // matches .left-panel width
                
                // Check if mouse is actually over the chart area (not left panel)
                const mouseOverChart = clientX > scrollRect.left + leftPanelWidth;
                
                const x = clientX - scrollRect.left - leftPanelWidth + scrollContainer.scrollLeft;
                if (mouseOverChart && x >= 0 && x <= chartWidth) {
                    cursorLine.style.left = x + 'px';
                    cursorLine.classList.add('visible');
                    
                    // Calculate cursor time
                    const cursorMin = Math.round(windowStartMin + x / PIXELS_PER_MINUTE);
                    
                    // Always update tooltip position
                    cursorTime.textContent = minToTime(cursorMin);
                    cursorTime.style.display = 'block';
                    cursorTime.style.left = (clientX - 30) + 'px';
                    cursorTime.style.top = (scrollRect.top - 30) + 'px';
                    
                    // Only update panel and highlights if cursor minute changed
                    // Skip heavy operations during scroll - only update on mousemove
                    if (cursorMin !== lastCursorMin && !isScroll) {
                        lastCursorMin = cursorMin;
                        
                        // Show confluence at cursor position in right panel (only if nothing selected)
                        if (!selectedBreakerId && !selectedEntryMin && !selectedSmtId) {
                            showCursorConfluence(cursorMin);
                        }
                        
                        // Highlight bars at cursor (yellow)
                        highlightCursorActive(cursorMin);
                    }
                } else {
                    cursorLine.classList.remove('visible');
                    cursorTime.style.display = 'none';
                    
                    // Clear cursor highlights when leaving chart area
                    if (!isScroll) {
                        clearCursorHighlight();
                    }
                }
            }
            
            scrollContainer.addEventListener('mousemove', (e) => {
                lastClientX = e.clientX;
                updateCursorPosition(e.clientX, false);
            }, { signal });
            
            scrollContainer.addEventListener('scroll', () => {
                if (lastClientX !== null && !cursorUpdatePending) {
                    cursorUpdatePending = true;
                    requestAnimationFrame(() => {
                        updateCursorPosition(lastClientX, true);
                        cursorUpdatePending = false;
                    });
                }
            }, { signal });
            
            scrollContainer.addEventListener('mouseleave', () => {
                lastClientX = null;
                cursorLine.classList.remove('visible');
                cursorTime.style.display = 'none';
                
                // Clear cursor highlights
                clearCursorHighlight();
                
                // Restore appropriate panel state (selection takes priority over live mode)
                if (selectedBreakerId) {
                    showBreakerDetail(selectedBreakerId);
                } else if (selectedEntryMin) {
                    showEntryContext(selectedEntryMin);
                } else if (selectedSmtId) {
                    showSmtDetail(selectedSmtId);
                } else if (isLive) {
                    showLiveConfluence();
                } else {
                    showEmptyPanel();
                }
            }, { signal });
            
            // Click on chart to select time (but not on breakers or entry lines)
            chartInner.addEventListener('click', (e) => {
                // Only handle clicks directly on chart or swimlanes
                if (e.target.classList.contains('breaker-bar') || 
                    e.target.classList.contains('entry-line') ||
                    e.target.classList.contains('smt-marker') ||
                    e.target.closest('.breaker-bar') ||
                    e.target.closest('.entry-line') ||
                    e.target.closest('.smt-marker')) {
                    return;
                }
                
                const rect = chartInner.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const clickedMin = Math.round(windowStartMin + x / PIXELS_PER_MINUTE);
                selectTimeContext(clickedMin);
            }, { signal });
            
            // Update scroll listener
            const container = document.getElementById('scroll-container');
            container.removeEventListener('scroll', onScroll);
            container.addEventListener('scroll', onScroll, { signal });
            
            // Setup viewport drag handlers
            setupViewportHandlers();
            
            // Restore selections (both explore and live mode)
            if (preservedBreakerId) {
                selectedBreakerId = preservedBreakerId;
                document.querySelectorAll(`.breaker-bar[data-breaker-id="${preservedBreakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                showBreakerDetail(preservedBreakerId);
            } else if (preservedEntryMin) {
                selectedEntryMin = preservedEntryMin;
                highlightActiveAtEntry(preservedEntryMin);
                showEntryContext(preservedEntryMin);
                // Highlight entry line and markers if they exist
                document.querySelectorAll('.entry-line').forEach(el => {
                    if (parseInt(el.dataset.entryMin) === preservedEntryMin) {
                        el.classList.add('selected');
                    }
                });
            } else if (preservedSmtId) {
                selectedSmtId = preservedSmtId;
                document.querySelectorAll(`.smt-marker[data-smt-id="${preservedSmtId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                showSmtDetail(preservedSmtId);
            } else if (isLive) {
                // In live mode, show current confluence
                showLiveConfluence();
            } else {
                // In explore mode with no selection, show empty panel
                clearEntryHighlight();
                showEmptyPanel();
            }
            
            // Update viewport indicator after DOM is ready
            setTimeout(updateViewportIndicator, 50);
        }
        
        // ===== SMT DATA LOADING =====
        function loadSmtData() {
            console.log('📊 Loading SMT signals...');
            
            return fetch(SMT_FIREBASE_URL)
                .then(r => r.json())
                .then(data => {
                    if (!data) {
                        console.log('📊 No SMT signals found');
                        smtData = [];
                        return;
                    }
                    
                    // Convert to array and parse
                    smtData = [];
                    const errors = [];
                    
                    Object.entries(data).forEach(([key, smt]) => {
                        // Validate required fields
                        const missing = [];
                        if (!smt.smt_id) missing.push('smt_id');
                        if (!smt.dir) missing.push('dir');
                        if (!smt.tf) missing.push('tf');
                        if (!smt.smt_time) missing.push('smt_time');
                        if (!smt.roles) missing.push('roles');
                        if (!smt.es) missing.push('es');
                        if (!smt.nq) missing.push('nq');
                        if (!smt.classification) missing.push('classification');
                        if (!smt.quality) missing.push('quality');
                        if (!smt.validation) missing.push('validation');
                        if (!smt.price) missing.push('price');
                        
                        if (missing.length > 0) {
                            errors.push(`${key}: Missing fields: ${missing.join(', ')}`);
                            return;
                        }
                        
                        // Validate nested required fields
                        const nestedMissing = [];
                        if (!smt.roles.defensive) nestedMissing.push('roles.defensive');
                        if (!smt.roles.sweep) nestedMissing.push('roles.sweep');
                        if (smt.es.structure === undefined) nestedMissing.push('es.structure');
                        if (smt.nq.structure === undefined) nestedMissing.push('nq.structure');
                        if (!smt.classification.sync_label) nestedMissing.push('classification.sync_label');
                        if (smt.quality.total === undefined) nestedMissing.push('quality.total');
                        
                        if (nestedMissing.length > 0) {
                            errors.push(`${key}: Missing nested fields: ${nestedMissing.join(', ')}`);
                            return;
                        }
                        
                        // Parse smt_time to minutes
                        const smtMin = datetimeToMin(smt.smt_time);
                        if (isNaN(smtMin)) {
                            errors.push(`${key}: Invalid smt_time format: ${smt.smt_time}`);
                            return;
                        }
                        
                        // Build parsed object matching actual schema
                        const parsed = {
                            id: key,
                            smtId: smt.smt_id,
                            dir: smt.dir.toLowerCase(),
                            tf: smt.tf.toLowerCase(),
                            smtTime: smt.smt_time,
                            smtMin: smtMin,
                            
                            // Roles
                            defensiveAsset: smt.roles.defensive,
                            sweepAsset: smt.roles.sweep,
                            leadingAsset: smt.roles.leading,
                            
                            // ES swing data
                            es: {
                                prevPrice: smt.es.prev_price,
                                currPrice: smt.es.curr_price,
                                prevTime: smt.es.prev_time,
                                currTime: smt.es.curr_time,
                                structure: smt.es.structure
                            },
                            
                            // NQ swing data
                            nq: {
                                prevPrice: smt.nq.prev_price,
                                currPrice: smt.nq.curr_price,
                                prevTime: smt.nq.prev_time,
                                currTime: smt.nq.curr_time,
                                structure: smt.nq.structure
                            },
                            
                            // Classification (was timing)
                            classification: {
                                syncLabel: smt.classification.sync_label,
                                category: smt.classification.category,
                                isHtf: smt.classification.is_htf || false,
                                sweptLevel: smt.classification.swept_level
                            },
                            
                            // Quality scores
                            quality: {
                                score: smt.quality.total,
                                correspondence: smt.quality.correspondence || 0,
                                sweep: smt.quality.sweep || 0,
                                structure: smt.quality.structure || 0
                            },
                            
                            // Validation flags
                            validation: {
                                fvgPresent: smt.validation.fvg_present,
                                defensiveHeld: smt.validation.defensive_held,
                                sweepMagnitudeOk: smt.validation.sweep_magnitude_ok
                            },
                            
                            // Price data
                            price: {
                                defensive: smt.price.defensive,
                                sweepDepthAtr: smt.price.sweep_depth_atr
                            }
                        };
                        
                        smtData.push(parsed);
                    });
                    
                    // Log results
                    if (errors.length > 0) {
                        console.error(`❌ SMT Schema Errors (${errors.length}):`);
                        errors.forEach(e => console.error(`   ${e}`));
                    }
                    
                    console.log(`📊 Loaded ${smtData.length} valid SMT signals`);
                    if (smtData.length > 0) {
                        console.log('📊 Sample SMT:', smtData[0]);
                    }
                })
                .catch(err => {
                    console.error('❌ Error loading SMT data:', err);
                    smtData = [];
                });
        }
        
        function createSmtMarker(smt, laneTop, laneHeight) {
            const x = (smt.smtMin - windowStartMin) * PIXELS_PER_MINUTE;
            
            const marker = document.createElement('div');
            marker.className = 'smt-marker ' + smt.dir;
            marker.style.left = x + 'px';
            marker.style.top = laneTop + 'px';
            marker.style.height = laneHeight + 'px';
            marker.dataset.smtId = smt.id;
            
            // Diamond in center
            const diamond = document.createElement('div');
            diamond.className = 'smt-diamond';
            marker.appendChild(diamond);
            
            // Score at bottom
            const score = document.createElement('div');
            score.className = 'smt-score';
            score.textContent = Math.round(smt.quality.score);
            marker.appendChild(score);
            
            // Click handler
            marker.addEventListener('click', (e) => {
                e.stopPropagation();
                selectSmt(smt.id);
            });
            
            return marker;
        }
        
        let selectedSmtId = null;
        
        function selectSmt(smtId) {
            // Clear previous selections
            document.querySelectorAll('.breaker-bar.selected').forEach(el => el.classList.remove('selected'));
            document.querySelectorAll('.smt-marker.selected').forEach(el => el.classList.remove('selected'));
            clearEntryHighlight();
            selectedEntryMin = null;
            selectedBreakerId = null;
            
            // Toggle selection
            if (selectedSmtId === smtId) {
                selectedSmtId = null;
                showEmptyPanel();
            } else {
                selectedSmtId = smtId;
                document.querySelectorAll(`.smt-marker[data-smt-id="${smtId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                showSmtDetail(smtId);
            }
        }
        
        function showSmtDetail(smtId) {
            const smt = smtData.find(s => s.id === smtId);
            if (!smt) return;
            
            document.getElementById('panel-time').textContent = minToTime(smt.smtMin);
            document.getElementById('panel-type').textContent = 'SMT Signal';
            document.getElementById('panel-type').classList.remove('live');
            
            // Format helpers
            const formatTime = (t) => {
                if (!t) return '-';
                const timePart = t.split('T')[1] || t;
                return timePart.substring(0, 5); // HH:MM
            };
            const formatPrice = (asset, p) => {
                if (p === null || p === undefined) return '-';
                return asset === 'NQ' ? p.toFixed(0) : p.toFixed(2);
            };
            const formatDelta = (val) => {
                if (val === null || val === undefined) return '-';
                const sign = val >= 0 ? '+' : '';
                return sign + val.toFixed(val < 10 ? 2 : 0);
            };
            
            // Get sweep and defensive data
            const sweepAsset = smt.sweepAsset;
            const defAsset = smt.defensiveAsset;
            const sweepData = sweepAsset === 'NQ' ? smt.nq : smt.es;
            const defData = defAsset === 'NQ' ? smt.nq : smt.es;
            
            // Calculate price changes
            const sweepDelta = sweepData.currPrice - sweepData.prevPrice;
            const defDelta = defData.currPrice - defData.prevPrice;
            
            // Swept level from classification
            const sweptLevel = smt.classification.sweptLevel;
            const category = smt.classification.category;
            
            // Build headline
            const dirLabel = smt.dir === 'bull' ? 'BULLISH' : 'BEARISH';
            let headline = dirLabel;
            if (sweptLevel) {
                headline = `${dirLabel} @ ${sweptLevel}`;
            } else if (category) {
                headline = `${dirLabel} • ${category}`;
            }
            
            // Narrative
            const trapAction = smt.dir === 'bull' ? 'swept low' : 'swept high';
            const truthAction = smt.dir === 'bull' ? 'held higher' : 'held lower';
            
            // FVG info (boolean only in this schema)
            const hasFvg = smt.validation.fvgPresent;
            
            // Sync label
            const syncLabel = smt.classification.syncLabel;
            const syncClass = syncLabel === 'SYNC' ? 'sync' : 
                              syncLabel === 'PARTIAL' ? 'partial' : 'async';
            
            // Build strength/weakness matrix
            const strengths = [];
            const weaknesses = [];
            
            // Timing
            if (syncLabel === 'SYNC') {
                strengths.push('SYNC timing');
            } else if (syncLabel === 'ASYNC') {
                weaknesses.push('ASYNC timing');
            } else if (syncLabel === 'PARTIAL') {
                strengths.push('PARTIAL sync');
            }
            
            // FVG
            if (hasFvg) {
                strengths.push('FVG present');
            } else {
                weaknesses.push('No FVG');
            }
            
            // Swept level / Category
            if (sweptLevel) {
                strengths.push(`Swept ${sweptLevel}`);
            } else if (category && category !== 'STH/STL') {
                strengths.push(category);
            } else {
                weaknesses.push('No key level');
            }
            
            // Sweep magnitude
            if (smt.validation.sweepMagnitudeOk) {
                strengths.push(`Clean sweep (${smt.price.sweepDepthAtr?.toFixed(1) || '-'} ATR)`);
            } else if (smt.validation.sweepMagnitudeOk === false) {
                weaknesses.push(`Weak sweep (${smt.price.sweepDepthAtr?.toFixed(1) || '-'} ATR)`);
            }
            
            // Defensive held
            if (smt.validation.defensiveHeld) {
                strengths.push('Defensive held');
            } else if (smt.validation.defensiveHeld === false) {
                weaknesses.push('Defensive violated');
            }
            
            // HTF
            if (smt.classification.isHtf) {
                strengths.push('HTF signal');
            }
            
            // Quality
            if (smt.quality.score >= 75) {
                strengths.push(`High quality (${smt.quality.score.toFixed(0)})`);
            } else if (smt.quality.score < 50) {
                weaknesses.push(`Low quality (${smt.quality.score.toFixed(0)})`);
            }
            
            // Build matrix HTML
            const maxRows = Math.max(strengths.length, weaknesses.length, 1);
            let matrixRows = '';
            for (let i = 0; i < maxRows; i++) {
                const s = strengths[i] || '';
                const w = weaknesses[i] || '';
                matrixRows += `
                    <div class="smt-matrix-cell strength">${s ? `<span class="smt-matrix-bullet">✓</span> ${s}` : ''}</div>
                    <div class="smt-matrix-cell weakness">${w ? `<span class="smt-matrix-bullet">✗</span> ${w}` : ''}</div>
                `;
            }
            
            // Quality score class
            const qClass = smt.quality.score >= 75 ? 'high' : smt.quality.score >= 50 ? 'med' : 'low';
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="smt-headline ${smt.dir}">${headline}</div>
                    <div class="smt-story-summary">
                        ${sweepAsset} ${trapAction}, ${defAsset} ${truthAction}
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="smt-divergence-grid">
                        <div class="smt-swing-card trap">
                            <div class="smt-swing-label">THE TRAP</div>
                            <div class="smt-swing-asset ${sweepAsset.toLowerCase()}">${sweepAsset}</div>
                            <div class="smt-swing-timeline">
                                <div class="smt-swing-point">
                                    <span class="smt-swing-time">${formatTime(sweepData.prevTime)}</span>
                                    <span class="smt-swing-price">${formatPrice(sweepAsset, sweepData.prevPrice)}</span>
                                </div>
                                <div class="smt-swing-connector ${smt.dir === 'bull' ? 'bearish' : 'bullish'}">
                                    <span class="smt-swing-arrow">${smt.dir === 'bull' ? '↘' : '↗'}</span>
                                </div>
                                <div class="smt-swing-point current">
                                    <span class="smt-swing-time">${formatTime(sweepData.currTime)}</span>
                                    <span class="smt-swing-price">${formatPrice(sweepAsset, sweepData.currPrice)}</span>
                                </div>
                            </div>
                            <div class="smt-swing-result ${smt.dir === 'bull' ? 'bearish' : 'bullish'}">
                                <span class="smt-swing-structure">${sweepData.structure}</span>
                                <span class="smt-swing-delta">${formatDelta(sweepDelta)}</span>
                            </div>
                        </div>
                        
                        <div class="smt-divergence-vs">⇄</div>
                        
                        <div class="smt-swing-card truth">
                            <div class="smt-swing-label">THE TRUTH</div>
                            <div class="smt-swing-asset ${defAsset.toLowerCase()}">${defAsset}</div>
                            <div class="smt-swing-timeline">
                                <div class="smt-swing-point">
                                    <span class="smt-swing-time">${formatTime(defData.prevTime)}</span>
                                    <span class="smt-swing-price">${formatPrice(defAsset, defData.prevPrice)}</span>
                                </div>
                                <div class="smt-swing-connector ${smt.dir === 'bull' ? 'bullish' : 'bearish'}">
                                    <span class="smt-swing-arrow">${smt.dir === 'bull' ? '↗' : '↘'}</span>
                                </div>
                                <div class="smt-swing-point current">
                                    <span class="smt-swing-time">${formatTime(defData.currTime)}</span>
                                    <span class="smt-swing-price">${formatPrice(defAsset, defData.currPrice)}</span>
                                </div>
                            </div>
                            <div class="smt-swing-result ${smt.dir === 'bull' ? 'bullish' : 'bearish'}">
                                <span class="smt-swing-structure">${defData.structure}</span>
                                <span class="smt-swing-delta">${formatDelta(defDelta)}</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="smt-timing-bar">
                        <div class="smt-timing-endpoint">${sweepAsset} @ ${formatTime(sweepData.currTime)}</div>
                        <div class="smt-timing-connector">
                            <div class="smt-timing-line"></div>
                            <div class="smt-timing-delta ${syncClass}">${syncLabel}</div>
                            <div class="smt-timing-line"></div>
                        </div>
                        <div class="smt-timing-endpoint">${defAsset} @ ${formatTime(defData.currTime)}</div>
                    </div>
                </div>
                
                ${(smt.price.defensive || smt.price.sweepDepthAtr) ? `
                <div class="detail-section">
                    <div class="smt-entry-section">
                        ${smt.price.sweepDepthAtr ? `
                        <div class="smt-entry-row">
                            <span class="smt-entry-label">Sweep Depth</span>
                            <span class="smt-entry-value">${smt.price.sweepDepthAtr.toFixed(2)} ATR</span>
                        </div>
                        ` : ''}
                        ${smt.price.defensive ? `
                        <div class="smt-entry-row">
                            <span class="smt-entry-label">Defensive Level</span>
                            <span class="smt-entry-value">${formatPrice(defAsset, smt.price.defensive)} (${defAsset})</span>
                        </div>
                        ` : ''}
                        ${hasFvg ? `
                        <div class="smt-entry-row">
                            <span class="smt-entry-label">FVG</span>
                            <span class="smt-entry-value smt-fvg-present">Present</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
                ` : ''}
                
                <div class="detail-section">
                    <div class="smt-matrix">
                        <div class="smt-matrix-header strength">✓ Strengths</div>
                        <div class="smt-matrix-header weakness">✗ Weaknesses</div>
                        ${matrixRows}
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="smt-quality-section">
                        <div class="smt-quality-main">
                            <div class="smt-quality-bar">
                                <div class="smt-quality-track">
                                    <div class="smt-quality-fill ${qClass}" style="width: ${smt.quality.score || 0}%"></div>
                                </div>
                                <div class="smt-quality-value ${qClass}">${smt.quality.score?.toFixed(0) || '-'}</div>
                            </div>
                        </div>
                        <div class="smt-quality-breakdown">
                            <div class="smt-quality-item">
                                <span class="smt-quality-item-label">Corr</span>
                                <span class="smt-quality-item-value">${smt.quality.correspondence?.toFixed(0) || '-'}</span>
                            </div>
                            <div class="smt-quality-item">
                                <span class="smt-quality-item-label">Sweep</span>
                                <span class="smt-quality-item-value">${smt.quality.sweep?.toFixed(0) || '-'}</span>
                            </div>
                            <div class="smt-quality-item">
                                <span class="smt-quality-item-label">Struct</span>
                                <span class="smt-quality-item-value">${smt.quality.structure?.toFixed(0) || '-'}</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="smt-meta-footer">
                    <span>${smt.tf.toUpperCase()}</span>
                    <span>•</span>
                    <span>${smt.smtId}</span>
                </div>
            `;
        }
        
        function createBreakerBar(b, laneHeight) {
            const startX = Math.max(0, (b.startMin - windowStartMin) * PIXELS_PER_MINUTE);
            const endX = (b.endMin - windowStartMin) * PIXELS_PER_MINUTE;
            const barWidth = Math.max(endX - startX + PIXELS_PER_MINUTE, 6);
            
            // Calculate vertical position - top aligned with padding
            const topOffset = LANE_PADDING + b.stackIdx * (BAR_HEIGHT + BAR_GAP);
            
            const bar = document.createElement('div');
            bar.className = 'breaker-bar ' + b.symbol.toLowerCase() + ' ' + b.dir;
            
            if (b.status !== 'active') {
                bar.classList.add('completed');
            }
            
            bar.style.left = startX + 'px';
            bar.style.width = barWidth + 'px';
            bar.style.top = topOffset + 'px';
            bar.style.height = BAR_HEIGHT + 'px';
            bar.dataset.breakerId = b.id;
            bar.dataset.startMin = b.startMin;
            bar.dataset.endMin = b.endMin;
            
            // Right-side container for fib and status
            const rightGroup = document.createElement('div');
            rightGroup.className = 'bar-right-group';
            
            // Show fib on wider bars (right side, before status)
            if (barWidth > 50) {
                const fibSpan = document.createElement('span');
                fibSpan.className = 'bar-fib';
                fibSpan.textContent = b.maxFib.toFixed(1);
                rightGroup.appendChild(fibSpan);
            }
            
            // Status dot - only for completed
            if (b.status === 'success' || b.status === 'fail') {
                const dot = document.createElement('div');
                dot.className = 'status-dot ' + b.status;
                dot.textContent = b.status === 'success' ? 'S' : 'F';
                rightGroup.appendChild(dot);
            }
            
            bar.appendChild(rightGroup);
            
            // Click to show details
            bar.addEventListener('click', (e) => {
                e.stopPropagation();
                selectBreaker(b.id);
            });
            
            return bar;
        }
        
        // ===== DETAIL PANEL =====
        function showEmptyPanel() {
            document.getElementById('panel-time').textContent = '';
            document.getElementById('panel-type').textContent = 'Details';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="panel-empty">
                    <div class="panel-empty-icon">📋</div>
                    <div class="panel-empty-text">
                        Click a breaker bar or entry line to see details
                    </div>
                </div>
            `;
        }
        
        function showCursorConfluence(cursorMin) {
            // Find all breakers active at cursor time
            const activeAtEntry = allData.filter(d => 
                d.startMin <= cursorMin && d.endMin >= cursorMin
            );
            
            // Build context for each TF/Symbol combination
            const contextRows = [];
            let nqBull = 0, nqBear = 0, esBull = 0, esBear = 0;
            
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    const breaker = activeAtEntry.find(d => 
                        d.tf.replace('hr', 'h') === tf && d.symbol === symbol
                    );
                    
                    if (breaker) {
                        // Count for alignment
                        if (symbol === 'NQ') {
                            if (breaker.dir === 'bull') nqBull++; else nqBear++;
                        } else {
                            if (breaker.dir === 'bull') esBull++; else esBear++;
                        }
                        
                        // Get fib at entry (first event)
                        const entryFib = breaker.events[0]?.fib || 1.0;
                        
                        // Get current fib (event closest to cursor time)
                        let currentFib = entryFib;
                        for (const evt of breaker.events) {
                            if (evt.absMin <= cursorMin) {
                                currentFib = evt.fib;
                            }
                        }
                        
                        // Status indicator
                        const statusIcon = breaker.status === 'success' ? 'S' : 
                                          breaker.status === 'fail' ? 'F' : '-';
                        const statusClass = breaker.status;
                        
                        contextRows.push(`
                            <div class="context-row active">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir ${breaker.dir}">${breaker.dir.toUpperCase()}</span>
                                <span class="context-fib">${entryFib.toFixed(1)} → ${currentFib.toFixed(1)}</span>
                                <span class="context-status-icon ${statusClass}">${statusIcon}</span>
                            </div>
                        `);
                    } else {
                        contextRows.push(`
                            <div class="context-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir none">-</span>
                                <span class="context-fib">-</span>
                                <span class="context-status-icon none">-</span>
                            </div>
                        `);
                    }
                });
            });
            
            document.getElementById('panel-time').textContent = minToTime(cursorMin);
            document.getElementById('panel-type').textContent = 'Confluence';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-section-title">Active Breakers</div>
                    <div class="context-header">
                        <span>TF</span>
                        <span>Sym</span>
                        <span>Dir</span>
                        <span>Fib</span>
                        <span>St</span>
                    </div>
                    <div class="context-grid">
                        ${contextRows.join('')}
                    </div>
                </div>
                
                <div class="context-summary">
                    <div class="context-summary-row">
                        <span class="context-summary-label">NQ</span>
                        <span class="context-summary-value"><span class="arrow-bull">${nqBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${nqBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                    <div class="context-summary-row">
                        <span class="context-summary-label">ES</span>
                        <span class="context-summary-value"><span class="arrow-bull">${esBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${esBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                </div>
            `;
        }
        
        function showLiveConfluence() {
            const currentMin = dataMaxTime;
            
            // Highlight active breakers on chart and left panel (green for live)
            highlightLiveActive();
            
            // Find all breakers active at current time
            const activeAtEntry = allData.filter(d => 
                d.startMin <= currentMin && d.endMin >= currentMin
            );
            
            // Build context for each TF/Symbol combination
            const contextRows = [];
            let nqBull = 0, nqBear = 0, esBull = 0, esBear = 0;
            
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    const breaker = activeAtEntry.find(d => 
                        d.tf.replace('hr', 'h') === tf && d.symbol === symbol
                    );
                    
                    if (breaker) {
                        // Count for alignment
                        if (symbol === 'NQ') {
                            if (breaker.dir === 'bull') nqBull++; else nqBear++;
                        } else {
                            if (breaker.dir === 'bull') esBull++; else esBear++;
                        }
                        
                        // Get fib at entry (first event)
                        const entryFib = breaker.events[0]?.fib || 1.0;
                        
                        // Get current fib (latest event)
                        const currentFib = breaker.maxFib;
                        
                        // Status indicator
                        const statusIcon = breaker.status === 'success' ? 'S' : 
                                          breaker.status === 'fail' ? 'F' : '-';
                        const statusClass = breaker.status;
                        
                        contextRows.push(`
                            <div class="context-row live-active-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir ${breaker.dir}">${breaker.dir.toUpperCase()}</span>
                                <span class="context-fib">${entryFib.toFixed(1)} → ${currentFib.toFixed(1)}</span>
                                <span class="context-status-icon ${statusClass}">${statusIcon}</span>
                            </div>
                        `);
                    } else {
                        contextRows.push(`
                            <div class="context-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir none">-</span>
                                <span class="context-fib">-</span>
                                <span class="context-status-icon none">-</span>
                            </div>
                        `);
                    }
                });
            });
            
            document.getElementById('panel-time').textContent = minToTime(currentMin);
            document.getElementById('panel-type').textContent = 'Live Confluence';
            document.getElementById('panel-type').classList.add('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-section-title">Active Breakers</div>
                    <div class="context-header">
                        <span>TF</span>
                        <span>Sym</span>
                        <span>Dir</span>
                        <span>Fib</span>
                        <span>St</span>
                    </div>
                    <div class="context-grid">
                        ${contextRows.join('')}
                    </div>
                </div>
                
                <div class="context-summary">
                    <div class="context-summary-row">
                        <span class="context-summary-label">NQ</span>
                        <span class="context-summary-value"><span class="arrow-bull">${nqBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${nqBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                    <div class="context-summary-row">
                        <span class="context-summary-label">ES</span>
                        <span class="context-summary-value"><span class="arrow-bull">${esBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${esBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                </div>
            `;
        }
        
        function showBreakerDetail(breakerId) {
            const b = allData.find(d => d.id === breakerId);
            if (!b) return;
            
            const duration = minToDuration(b.startMin, b.endMin);
            const statusClass = b.status.toLowerCase();
            const statusText = b.status.charAt(0).toUpperCase() + b.status.slice(1);
            
            // Generate fib chart
            const fibChart = generateFibChart(b);
            
            document.getElementById('panel-time').textContent = minToTime(b.startMin);
            document.getElementById('panel-type').textContent = 'Breaker Detail';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-id">${b.displayId || b.id}</div>
                    <div class="detail-badges">
                        <span class="detail-badge ${b.symbol.toLowerCase()}">${b.symbol}</span>
                        <span class="detail-badge ${b.dir}">${b.dir.toUpperCase()}</span>
                        <span class="detail-badge ${statusClass}">${statusText}</span>
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Fib Progression</div>
                    <div class="fib-chart-container">
                        ${fibChart}
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Metrics</div>
                    <div class="detail-row">
                        <span class="detail-label">Max Fib</span>
                        <span class="detail-value large">${b.maxFib.toFixed(2)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Timeframe</span>
                        <span class="detail-value">${TF_DISPLAY[b.tf] || b.tf.toUpperCase()}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Duration</span>
                        <span class="detail-value">${duration}</span>
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Timeline</div>
                    <div class="detail-row">
                        <span class="detail-label">Start</span>
                        <span class="detail-value">${minToDateTime(b.startMin)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">End</span>
                        <span class="detail-value">${minToDateTime(b.endMin)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Snapshots</span>
                        <span class="detail-value">${b.events.length}</span>
                    </div>
                </div>
                
                ${(b.tf === '1m' && b.dir === 'bull' && b.symbol === 'NQ') ? `
                <div class="analysis-link" onclick="showAnalysisModal('${b.id}')" title="View 21-dimension confirmation analysis">
                    📊 View Full Analysis
                </div>
                ` : ''}
            `;
        }
        
        function generateFibChart(breaker) {
            const events = breaker.events;
            if (events.length < 2) {
                return '<div style="color:#666;text-align:center;padding:20px;">Not enough data</div>';
            }
            
            const width = 280;
            const height = 120;
            const padding = { top: 20, right: 15, bottom: 25, left: 35 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Find min/max
            const minTime = events[0].absMin;
            const maxTime = events[events.length - 1].absMin;
            const timeRange = maxTime - minTime || 1;
            
            const maxFib = Math.max(...events.map(e => e.fib), 1);
            const fibCeil = Math.ceil(maxFib * 1.1); // Add 10% padding
            
            // Find peak point (first occurrence of max fib)
            const maxFibVal = Math.max(...events.map(e => e.fib));
            const peakIndex = events.findIndex(e => e.fib === maxFibVal);
            const peakEvent = events[peakIndex];
            
            // Downsample events if too many (keep first, last, peak, and sampled)
            let sampledEvents = events;
            let sampledPeakIndex = peakIndex;
            if (events.length > 100) {
                const step = Math.ceil(events.length / 80);
                sampledEvents = events.filter((e, i) => 
                    i === 0 || i === events.length - 1 || i === peakIndex || i % step === 0
                );
                sampledPeakIndex = sampledEvents.findIndex(e => e === events[peakIndex]);
            }
            
            // Generate points from sampled events
            const points = sampledEvents.map((e, i) => {
                const x = padding.left + ((e.absMin - minTime) / timeRange) * chartWidth;
                const y = padding.top + chartHeight - (e.fib / fibCeil) * chartHeight;
                return { x, y, fib: e.fib, time: e.absMin, isPeak: i === sampledPeakIndex };
            });
            
            // Create line path
            const linePath = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            
            // Create area path (for gradient fill)
            const areaPath = linePath + ` L ${points[points.length-1].x} ${padding.top + chartHeight} L ${points[0].x} ${padding.top + chartHeight} Z`;
            
            // Generate Y-axis labels
            const yLabels = [];
            const ySteps = 4;
            for (let i = 0; i <= ySteps; i++) {
                const val = (fibCeil / ySteps) * i;
                const y = padding.top + chartHeight - (i / ySteps) * chartHeight;
                yLabels.push(`<text class="fib-chart-value-label" x="${padding.left - 5}" y="${y + 3}" text-anchor="end">${val.toFixed(1)}</text>`);
                if (i > 0 && i < ySteps) {
                    yLabels.push(`<line class="fib-chart-grid" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}"/>`);
                }
            }
            
            // Generate time labels (start, middle, end)
            const midTime = minTime + Math.floor(timeRange / 2);
            const timeLabels = [];
            timeLabels.push(`<text class="fib-chart-label" x="${padding.left}" y="${height - 5}" text-anchor="start">${minToTime(minTime)}</text>`);
            timeLabels.push(`<text class="fib-chart-label" x="${padding.left + chartWidth/2}" y="${height - 5}" text-anchor="middle">${minToTime(midTime)}</text>`);
            timeLabels.push(`<text class="fib-chart-label" x="${width - padding.right}" y="${height - 5}" text-anchor="end">${minToTime(maxTime)}</text>`);
            
            // Find peak point coordinates
            const peakPoint = points.find(p => p.isPeak);
            
            // Generate dots (sample if too many)
            let dotPoints = points;
            if (points.length > 20) {
                const step = Math.ceil(points.length / 15);
                dotPoints = points.filter((p, i) => i === 0 || i === points.length - 1 || p.isPeak || i % step === 0);
            }
            
            const dots = dotPoints.map(p => {
                return `<circle class="${p.isPeak ? 'fib-chart-peak' : 'fib-chart-dot'}" cx="${p.x}" cy="${p.y}" r="${p.isPeak ? 4 : 3}"/>`;
            }).join('');
            
            // Peak label
            const peakLabel = peakPoint ? `
                <text class="fib-peak-label" x="${peakPoint.x}" y="${peakPoint.y - 8}" text-anchor="middle">${peakEvent.fib.toFixed(2)}</text>
            ` : '';
            
            // Store chart data for cursor interaction
            const chartId = 'fib-chart-' + Date.now();
            
            // Schedule cursor setup after DOM update
            setTimeout(() => setupFibChartCursor(chartId, points, padding, chartWidth, chartHeight, fibCeil, minTime, timeRange), 0);
            
            return `
                <svg id="${chartId}" class="fib-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                    <defs>
                        <linearGradient id="fibGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:0.4"/>
                            <stop offset="100%" style="stop-color:#60a5fa;stop-opacity:0"/>
                        </linearGradient>
                    </defs>
                    
                    <!-- Grid lines -->
                    ${yLabels.join('')}
                    
                    <!-- Axes -->
                    <line class="fib-chart-axis" x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${padding.top + chartHeight}"/>
                    <line class="fib-chart-axis" x1="${padding.left}" y1="${padding.top + chartHeight}" x2="${width - padding.right}" y2="${padding.top + chartHeight}"/>
                    
                    <!-- Area fill -->
                    <path class="fib-chart-area" d="${areaPath}"/>
                    
                    <!-- Line -->
                    <path class="fib-chart-line" d="${linePath}"/>
                    
                    <!-- Dots -->
                    ${dots}
                    
                    <!-- Peak label -->
                    ${peakLabel}
                    
                    <!-- Time labels -->
                    ${timeLabels.join('')}
                    
                    <!-- Cursor elements -->
                    <line class="fib-cursor-line" id="${chartId}-cursor-line" x1="0" y1="${padding.top}" x2="0" y2="${padding.top + chartHeight}"/>
                    <circle class="fib-cursor-dot" id="${chartId}-cursor-dot" cx="0" cy="0" r="5"/>
                    
                    <!-- Hover area -->
                    <rect x="${padding.left}" y="${padding.top}" width="${chartWidth}" height="${chartHeight}" fill="transparent" style="cursor:crosshair"/>
                </svg>
                <div class="fib-cursor-tooltip" id="${chartId}-tooltip">
                    <span class="fib-val">0.00</span>
                    <span class="time-val">00:00</span>
                </div>
            `;
        }
        
        function setupFibChartCursor(chartId, points, padding, chartWidth, chartHeight, fibCeil, minTime, timeRange) {
            const svg = document.getElementById(chartId);
            const cursorLine = document.getElementById(chartId + '-cursor-line');
            const cursorDot = document.getElementById(chartId + '-cursor-dot');
            const tooltip = document.getElementById(chartId + '-tooltip');
            
            // Guard: check if elements exist and listeners not already attached
            if (!svg || !cursorLine || !cursorDot || !tooltip) return;
            if (svg.dataset.listenersAttached) return;
            svg.dataset.listenersAttached = 'true';
            
            const container = svg.closest('.fib-chart-container');
            
            svg.addEventListener('mousemove', (e) => {
                const rect = svg.getBoundingClientRect();
                const scaleX = 280 / rect.width;
                const mouseX = (e.clientX - rect.left) * scaleX;
                
                // Check if within chart area
                if (mouseX < padding.left || mouseX > padding.left + chartWidth) {
                    cursorLine.style.opacity = '0';
                    cursorDot.style.opacity = '0';
                    tooltip.style.opacity = '0';
                    return;
                }
                
                // Find closest point
                let closest = points[0];
                let closestDist = Math.abs(points[0].x - mouseX);
                
                for (const p of points) {
                    const dist = Math.abs(p.x - mouseX);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = p;
                    }
                }
                
                // Update cursor
                cursorLine.setAttribute('x1', closest.x);
                cursorLine.setAttribute('x2', closest.x);
                cursorLine.style.opacity = '1';
                
                cursorDot.setAttribute('cx', closest.x);
                cursorDot.setAttribute('cy', closest.y);
                cursorDot.style.opacity = '1';
                
                // Update tooltip
                tooltip.querySelector('.fib-val').textContent = closest.fib.toFixed(2);
                tooltip.querySelector('.time-val').textContent = minToTime(closest.time);
                tooltip.style.opacity = '1';
                
                // Position tooltip
                const tooltipX = (closest.x / 280) * rect.width;
                const tooltipY = (closest.y / 120) * rect.height;
                
                // Flip tooltip if near right edge
                if (tooltipX > rect.width * 0.6) {
                    tooltip.style.left = (tooltipX - tooltip.offsetWidth - 10) + 'px';
                } else {
                    tooltip.style.left = (tooltipX + 10) + 'px';
                }
                tooltip.style.top = (tooltipY - 10) + 'px';
            });
            
            svg.addEventListener('mouseleave', () => {
                cursorLine.style.opacity = '0';
                cursorDot.style.opacity = '0';
                tooltip.style.opacity = '0';
            });
        }
        
        function showEntryContext(entryMin) {
            // Find all breakers active at this time
            const activeAtEntry = allData.filter(d => 
                d.startMin <= entryMin && d.endMin >= entryMin
            );
            
            // Build context for each TF/Symbol combination
            const contextRows = [];
            let nqBull = 0, nqBear = 0, esBull = 0, esBear = 0;
            
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    const breaker = activeAtEntry.find(d => 
                        d.tf.replace('hr', 'h') === tf && d.symbol === symbol
                    );
                    
                    if (breaker) {
                        // Count for alignment
                        if (symbol === 'NQ') {
                            if (breaker.dir === 'bull') nqBull++; else nqBear++;
                        } else {
                            if (breaker.dir === 'bull') esBull++; else esBear++;
                        }
                        
                        // Get fib at start
                        const startFib = breaker.events[0]?.fib || 1.0;
                        
                        // Get fib at entry time
                        let fibAtEntry = startFib;
                        for (const evt of breaker.events) {
                            if (evt.absMin <= entryMin) {
                                fibAtEntry = evt.fib;
                            }
                        }
                        
                        // Status indicator
                        const statusIcon = breaker.status === 'success' ? 'S' : 
                                          breaker.status === 'fail' ? 'F' : '-';
                        const statusClass = breaker.status;
                        
                        contextRows.push(`
                            <div class="context-row active">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir ${breaker.dir}">${breaker.dir.toUpperCase()}</span>
                                <span class="context-fib">${startFib.toFixed(1)} → ${fibAtEntry.toFixed(1)}</span>
                                <span class="context-status-icon ${statusClass}">${statusIcon}</span>
                            </div>
                        `);
                    } else {
                        contextRows.push(`
                            <div class="context-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir none">-</span>
                                <span class="context-fib">-</span>
                                <span class="context-status-icon none">-</span>
                            </div>
                        `);
                    }
                });
            });
            
            document.getElementById('panel-time').textContent = minToTime(entryMin);
            document.getElementById('panel-type').textContent = 'Entry Confluence';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-section-title">Active Breakers</div>
                    <div class="context-header">
                        <span>TF</span>
                        <span>Sym</span>
                        <span>Dir</span>
                        <span>Fib</span>
                        <span>St</span>
                    </div>
                    <div class="context-grid">
                        ${contextRows.join('')}
                    </div>
                </div>
                
                <div class="context-summary">
                    <div class="context-summary-row">
                        <span class="context-summary-label">NQ</span>
                        <span class="context-summary-value"><span class="arrow-bull">${nqBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${nqBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                    <div class="context-summary-row">
                        <span class="context-summary-label">ES</span>
                        <span class="context-summary-value"><span class="arrow-bull">${esBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${esBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                </div>
            `;
        }
        
        // ===== SELECTION =====
        function selectBreaker(breakerId) {
            // Clear previous selection
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.smt-marker.selected').forEach(el => {
                el.classList.remove('selected');
            });
            clearEntryHighlight();
            selectedEntryMin = null;
            selectedSmtId = null;
            
            // Toggle selection
            if (selectedBreakerId === breakerId) {
                selectedBreakerId = null;
                showEmptyPanel();
            } else {
                selectedBreakerId = breakerId;
                
                // Highlight selected bar
                document.querySelectorAll(`.breaker-bar[data-breaker-id="${breakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                
                showBreakerDetail(breakerId);
            }
            
            // Update entry line and marker styling
            document.querySelectorAll('.entry-line').forEach(el => {
                el.classList.remove('selected');
            });
        }
        
        function selectEntry(entryMin) {
            // Clear previous selection
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.smt-marker.selected').forEach(el => {
                el.classList.remove('selected');
            });
            selectedBreakerId = null;
            selectedSmtId = null;
            
            // Toggle selection
            if (selectedEntryMin === entryMin) {
                selectedEntryMin = null;
                clearEntryHighlight();
                showEmptyPanel();
            } else {
                selectedEntryMin = entryMin;
                highlightActiveAtEntry(entryMin);
                showEntryContext(entryMin);
            }
            
            // Update entry line and marker styling
            document.querySelectorAll('.entry-line').forEach(el => {
                if (parseInt(el.dataset.entryMin) === selectedEntryMin) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });
        }
        
        function selectTimeContext(clickedMin) {
            // Clear previous selections
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.smt-marker.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.entry-line').forEach(el => {
                el.classList.remove('selected');
            });
            selectedBreakerId = null;
            selectedSmtId = null;
            
            // Toggle selection
            if (selectedEntryMin === clickedMin) {
                selectedEntryMin = null;
                clearEntryHighlight();
                showEmptyPanel();
            } else {
                selectedEntryMin = clickedMin;
                highlightActiveAtEntry(clickedMin);
                showEntryContext(clickedMin);
            }
        }
        
        function highlightActiveAtEntry(entryMin) {
            clearEntryHighlight();
            
            // Track which TF/symbol combinations have active breakers
            const activeLanes = new Set();
            
            // Use cached bars
            for (const bar of renderedBars) {
                if (bar.startMin <= entryMin && bar.endMin >= entryMin) {
                    bar.el.classList.add('active-at-entry');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('has-confluence');
                }
            }
        }
        
        function clearEntryHighlight() {
            for (const bar of renderedBars) {
                bar.el.classList.remove('active-at-entry');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('has-confluence');
            }
        }
        
        // Cursor highlighting (yellow) - separate from live/selected highlighting
        function highlightCursorActive(cursorMin) {
            clearCursorHighlight();
            clearLiveHighlight(); // Clear live highlight when cursor is active
            
            const activeLanes = new Set();
            
            // Use cached bars instead of querySelectorAll
            for (const bar of renderedBars) {
                if (bar.startMin <= cursorMin && bar.endMin >= cursorMin) {
                    bar.el.classList.add('cursor-active');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('cursor-confluence');
                }
            }
        }
        
        function clearCursorHighlight() {
            // Use cached bars instead of querySelectorAll
            for (const bar of renderedBars) {
                bar.el.classList.remove('cursor-active');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('cursor-confluence');
            }
        }
        
        // Live highlighting (green) - for live mode current time
        function highlightLiveActive() {
            clearLiveHighlight();
            const currentMin = dataMaxTime;
            
            const activeLanes = new Set();
            
            // Use cached bars
            for (const bar of renderedBars) {
                if (bar.startMin <= currentMin && bar.endMin >= currentMin) {
                    bar.el.classList.add('live-active');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('live-confluence');
                }
            }
        }
        
        function clearLiveHighlight() {
            for (const bar of renderedBars) {
                bar.el.classList.remove('live-active');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('live-confluence');
            }
        }
        
        // ===== VIEWPORT DRAG TO PAN =====
        let vpHandlersSetup = false;
        
        function setupViewportHandlers() {
            if (vpHandlersSetup) return;
            vpHandlersSetup = true;
            
            const track = document.getElementById('timeline-track');
            const viewport = document.getElementById('viewport-indicator');
            
            if (!track || !viewport) return;
            
            let isDragging = false;
            let hasDragged = false;
            let startX = 0;
            let startScrollLeft = 0;
            
            // Drag viewport to scroll chart
            viewport.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                hasDragged = false;
                startX = e.clientX;
                
                const container = document.getElementById('scroll-container');
                startScrollLeft = container ? container.scrollLeft : 0;
                viewport.style.cursor = 'grabbing';
            });
            
            // Click on track to jump
            track.addEventListener('click', (e) => {
                if (e.target !== track || hasDragged) {
                    hasDragged = false;
                    return;
                }
                
                if (dataMinTime === 0 || dataMaxTime === 0) return;
                
                const container = document.getElementById('scroll-container');
                const chartInner = document.getElementById('chart-inner');
                if (!container || !chartInner) return;
                
                const trackRect = track.getBoundingClientRect();
                const clickPct = (e.clientX - trackRect.left) / trackRect.width;
                const totalRange = dataMaxTime - dataMinTime;
                const clickMin = dataMinTime + clickPct * totalRange;
                
                // Calculate scroll position to center on clicked time
                const chartWidth = chartInner.offsetWidth;
                const viewportWidth = container.clientWidth;
                const windowRange = windowEndMin - windowStartMin;
                
                // Map clicked time to scroll position
                const timeInWindow = clickMin - windowStartMin;
                const scrollTarget = (timeInWindow / windowRange) * chartWidth - viewportWidth / 2;
                
                container.scrollLeft = Math.max(0, Math.min(scrollTarget, chartWidth - viewportWidth));
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                if (dataMinTime === 0 || dataMaxTime === 0) return;
                
                hasDragged = true;
                
                const container = document.getElementById('scroll-container');
                const chartInner = document.getElementById('chart-inner');
                const trackEl = document.getElementById('timeline-track');
                if (!container || !chartInner || !trackEl) return;
                
                const trackRect = trackEl.getBoundingClientRect();
                const trackWidth = trackRect.width;
                const chartWidth = chartInner.offsetWidth;
                const viewportWidth = container.clientWidth;
                const maxScroll = chartWidth - viewportWidth;
                
                if (maxScroll <= 0) return;
                
                const totalRange = dataMaxTime - dataMinTime;
                const windowRange = windowEndMin - windowStartMin;
                
                // Map drag distance on track to scroll distance
                const dx = e.clientX - startX;
                const dPctOfTotal = dx / trackWidth;
                const dTime = dPctOfTotal * totalRange;
                const dScroll = (dTime / windowRange) * chartWidth;
                
                container.scrollLeft = Math.max(0, Math.min(startScrollLeft + dScroll, maxScroll));
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    viewport.style.cursor = 'grab';
                }
            });
        }
        
        // ===== SCROLL =====
        let scrollTimeout;
        
        function onScroll() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(updateViewportFromScroll, 30);
            
            const container = document.getElementById('scroll-container');
            const header = document.getElementById('time-header');
            header.style.transform = `translateX(${-container.scrollLeft}px)`;
            
            // Update sticky date indicator
            updateStickyDate(container.scrollLeft);
        }
        
        function updateStickyDate(scrollLeft) {
            // Disabled - using date in time labels instead
            const stickyDate = document.getElementById('sticky-date');
            if (stickyDate) stickyDate.classList.remove('visible');
        }
        
        function updateViewportFromScroll() {
            if (dataMinTime === 0 || dataMaxTime === 0) return;
            
            const container = document.getElementById('scroll-container');
            const chartInner = document.getElementById('chart-inner');
            if (!container || !chartInner) return;
            
            const chartWidth = chartInner.offsetWidth;
            const viewportWidth = container.clientWidth;
            const scrollLeft = container.scrollLeft;
            
            if (chartWidth <= 0) return;
            
            const totalDataRange = dataMaxTime - dataMinTime;
            const windowRange = windowEndMin - windowStartMin;
            
            // Calculate visible time range based on scroll
            const scrollPct = chartWidth > viewportWidth ? scrollLeft / (chartWidth - viewportWidth) : 0;
            const visibleTimeWidth = (viewportWidth / chartWidth) * windowRange;
            const visibleStartMin = windowStartMin + scrollPct * (windowRange - visibleTimeWidth);
            const visibleEndMin = visibleStartMin + visibleTimeWidth;
            
            // Map to viewport bar position
            const startPct = Math.max(0, ((visibleStartMin - dataMinTime) / totalDataRange) * 100);
            const endPct = Math.min(100, ((visibleEndMin - dataMinTime) / totalDataRange) * 100);
            const widthPct = Math.max(2, endPct - startPct);
            
            const vpEl = document.getElementById('viewport-indicator');
            if (vpEl) {
                vpEl.style.left = startPct + '%';
                vpEl.style.width = widthPct + '%';
            }
        }
        
        function updateViewportIndicator() {
            // Update time labels
            if (dataMinTime > 0 && dataMaxTime > 0) {
                document.getElementById('data-start').textContent = minToDateTime(dataMinTime);
            }
            
            // Update viewport bar position based on current scroll
            updateViewportFromScroll();
        }
        
        // ===== AUTO REFRESH =====
        function setRefreshInterval() {
            if (refreshTimer) clearInterval(refreshTimer);
            if (countdownTimer) clearInterval(countdownTimer);
            
            const interval = parseInt(document.getElementById('refresh-interval').value);
            const countdownEl = document.getElementById('countdown');
            
            if (interval === 0) {
                countdownEl.textContent = '';
                return;
            }
            
            countdownSecs = interval;
            countdownEl.textContent = interval + 's';
            
            countdownTimer = setInterval(() => {
                countdownSecs--;
                if (countdownSecs <= 0) countdownSecs = interval;
                countdownEl.textContent = countdownSecs + 's';
            }, 1000);
            
            refreshTimer = setInterval(() => {
                loadData();
                countdownSecs = interval;
            }, interval * 1000);
        }
        
        // ===== ANALYSIS MODAL =====
        const ANALYSIS_DIMENSIONS = {
            direction: [
                { code: 'D1', name: 'NQ Alignment', key: 'd1_nq_alignment' },
                { code: 'D2', name: 'ES Alignment', key: 'd2_es_alignment' },
                { code: 'D3', name: 'Bearish Inversion', key: 'd3_bearish_inversion' }
            ],
            support: [
                { code: 'S1', name: 'Premium/Discount', key: 's1_premium_discount' },
                { code: 'S2', name: 'Stacked Breakers', key: 's2_stacked_breakers' },
                { code: 'S3', name: 'Stacked FVGs', key: 's3_stacked_fvgs' }
            ],
            resistance: [
                { code: 'R1', name: 'Blocking Breakers', key: 'r1_blocking_breakers' },
                { code: 'R2', name: 'Blocking FVGs', key: 'r2_blocking_fvgs' }
            ],
            energy: [
                { code: 'E1', name: 'Formation FVG', key: 'e1_formation_fvg' },
                { code: 'E2', name: 'Formation Sweep', key: 'e2_formation_sweep' },
                { code: 'E3', name: 'Formation SMT', key: 'e3_formation_smt' },
                { code: 'E4', name: 'Bullish Attraction', key: 'e4_bullish_attraction' },
                { code: 'E5', name: 'Bearish Attraction', key: 'e5_bearish_attraction' },
                { code: 'E6', name: 'Daily Burn', key: 'e6_daily_burn' }
            ],
            gate: [
                { code: 'G1', name: 'Trading Hours', key: 'g1_trading_hours' },
                { code: 'G2', name: 'News Blackout', key: 'g2_news_blackout' },
                { code: 'G3', name: 'Price Volatility', key: 'g3_price_volatility' },
                { code: 'G4', name: 'Market Volatility', key: 'g4_market_volatility' },
                { code: 'G5', name: 'Risk/Reward', key: 'g5_risk_reward' },
                { code: 'G6', name: 'Consecutive Losses', key: 'g6_consecutive_losses' },
                { code: 'G7', name: 'SPY Trend', key: 'g7_spy_trend' }
            ]
        };
        
        const CATEGORY_LABELS = {
            direction: 'Direction',
            support: 'Support',
            resistance: 'Resistance',
            energy: 'Energy',
            gate: 'Gate (All Must Pass)'
        };
        
        function showAnalysisModal(breakerId = null) {
            const modal = document.getElementById('analysis-modal');
            const heroId = document.getElementById('analysis-hero-id');
            
            if (!breakerId) {
                heroId.textContent = 'No breaker selected';
                showAnalysisError('Select a 1M Bull NQ breaker to view analysis');
                modal.classList.add('visible');
                document.addEventListener('keydown', handleModalEscape);
                return;
            }
            
            // Find the breaker to get its start time and display_id
            const breaker = allData.find(d => d.id === breakerId);
            if (breaker) {
                heroId.textContent = breaker.displayId || breakerId;
                // Fetch confirmation data from Firebase for this breaker's time
                fetchConfirmationData(breakerId, breaker.startMin);
            } else {
                heroId.textContent = breakerId;
                showAnalysisError('Breaker not found in loaded data');
            }
            
            modal.classList.add('visible');
            document.addEventListener('keydown', handleModalEscape);
        }
        
        function showAnalysisError(message) {
            const contentContainer = document.getElementById('analysis-content');
            const tabsContainer = document.getElementById('analysis-tabs');
            const decisionBadge = document.getElementById('analysis-decision-badge');
            const scoreBig = document.getElementById('analysis-score-big');
            const heroMeta = document.getElementById('analysis-hero-meta');
            
            decisionBadge.textContent = 'ERROR';
            decisionBadge.className = 'analysis-decision-badge fail';
            scoreBig.textContent = '--/21';
            heroMeta.textContent = '';
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = `
                <div style="padding: 40px; text-align: center; color: #f87171;">
                    <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
                    <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">No Confirmation Data</div>
                    <div style="font-size: 13px; color: #888;">${message}</div>
                </div>
            `;
        }
        
        function fetchConfirmationData(breakerId, startMin) {
            // Get display_id for UI
            const breaker = allData.find(d => d.id === breakerId);
            const displayId = breaker?.displayId || breakerId;
            
            console.log(`📊 Fetching confirmation for key: ${breakerId}`);
            
            // Show loading state
            document.getElementById('analysis-hero-id').textContent = displayId + ' · Loading...';
            
            // Query the confirmations collection directly (not inside snapshots)
            const confirmationsUrl = FIREBASE_URL.replace('snapshots.json', 'confirmations.json');
            
            fetch(confirmationsUrl)
                .then(r => r.json())
                .then(data => {
                    if (!data || Object.keys(data).length === 0) {
                        console.warn('No confirmations found');
                        document.getElementById('analysis-hero-id').textContent = displayId;
                        showAnalysisError(`No confirmations in database`);
                        return;
                    }
                    
                    // Find confirmation matching this breaker_id
                    let confirmationData = null;
                    const allBreakderIds = [];
                    
                    for (const [confKey, conf] of Object.entries(data)) {
                        if (conf && conf.breaker_id) {
                            allBreakderIds.push(conf.breaker_id);
                            if (conf.breaker_id === breakerId) {
                                confirmationData = conf;
                                console.log('✓ Found confirmation data:', confirmationData);
                                break;
                            }
                        }
                    }
                    
                    if (confirmationData) {
                        document.getElementById('analysis-hero-id').textContent = displayId;
                        renderAnalysisContent(transformConfirmationData(confirmationData, displayId));
                    } else {
                        console.warn('No confirmation found for this breaker');
                        console.log('📊 Looking for:', breakerId);
                        console.log('📊 Available breaker_ids:', allBreakderIds);
                        
                        document.getElementById('analysis-hero-id').textContent = displayId;
                        showAnalysisError(`No confirmation found for this breaker`);
                    }
                })
                .catch(err => {
                    console.error('Error fetching confirmation:', err);
                    document.getElementById('analysis-hero-id').textContent = displayId;
                    showAnalysisError(`Firebase error: ${err.message}`);
                });
        }
        
        function transformConfirmationData(conf, displayId) {
            // Transform Firebase confirmation structure to analysis modal format
            // Firebase stores confirmation with: breaker_id, confirmation_time, decision, decision_score, dimensions
            // dimensions contains: gate, direction, support, resistance, energy
            const dims = conf.dimensions || {};
            
            return {
                breaker_id: displayId,  // Use displayId for UI
                confirmation_time: conf.confirmation_time || new Date().toISOString(),
                decision: conf.decision || 'PENDING',
                decision_score: conf.decision_score || 0,
                dimensions: {
                    gate: dims.gate || {},
                    direction: dims.direction || {},
                    support: dims.support || {},
                    resistance: dims.resistance || {},
                    energy: dims.energy || {}
                }
            };
        }
        
        function closeAnalysisModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('analysis-modal');
            modal.classList.remove('visible');
            document.removeEventListener('keydown', handleModalEscape);
        }
        
        function handleModalEscape(e) {
            if (e.key === 'Escape') {
                closeAnalysisModal();
            }
        }
        
        function toggleDimension(el) {
            el.closest('.analysis-dimension').classList.toggle('expanded');
        }
        
        function toggleCategory(btn, categoryEl) {
            const dimensions = categoryEl.querySelectorAll('.analysis-dimension');
            const allExpanded = Array.from(dimensions).every(d => d.classList.contains('expanded'));
            
            dimensions.forEach(d => {
                if (allExpanded) {
                    d.classList.remove('expanded');
                } else {
                    d.classList.add('expanded');
                }
            });
            
            btn.textContent = allExpanded ? '▼ Expand All' : '▲ Collapse All';
        }
        
        function renderZoneChart(dimData, isSupport) {
            if (!dimData.zones || dimData.zones.length === 0) {
                if (dimData.target) {
                    // Resistance with no obstacles - show clear path
                    return `
                        <div class="analysis-zone-chart">
                            <div class="analysis-zone-chart-title">Visual: Entry to Target</div>
                            <div style="height: 100px; position: relative; display: flex; align-items: center; justify-content: center;">
                                <svg width="100%" height="100" viewBox="0 0 400 100">
                                    <defs>
                                        <linearGradient id="clearPath" x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:0.8" />
                                            <stop offset="100%" style="stop-color:#4ade80;stop-opacity:0.8" />
                                        </linearGradient>
                                    </defs>
                                    <line x1="50" y1="50" x2="350" y2="50" stroke="url(#clearPath)" stroke-width="3" stroke-dasharray="8,4"/>
                                    <circle cx="50" cy="50" r="8" fill="#60a5fa"/>
                                    <text x="50" y="75" text-anchor="middle" fill="#60a5fa" font-size="10" font-family="JetBrains Mono">Entry</text>
                                    <polygon points="350,50 340,44 340,56" fill="#4ade80"/>
                                    <circle cx="350" cy="50" r="8" fill="#4ade80"/>
                                    <text x="350" y="75" text-anchor="middle" fill="#4ade80" font-size="10" font-family="JetBrains Mono">Target</text>
                                    <text x="200" y="30" text-anchor="middle" fill="#4ade80" font-size="11" font-family="JetBrains Mono">✓ Clear Path</text>
                                </svg>
                            </div>
                        </div>
                    `;
                }
                return '';
            }
            
            // Calculate price range for chart
            const entry = dimData.entry;
            const target = dimData.target;
            const stop = dimData.stop || (isSupport ? entry - 20 : null);
            
            let allPrices = [entry];
            if (target) allPrices.push(target);
            if (stop) allPrices.push(stop);
            dimData.zones.forEach(z => {
                allPrices.push(z.high, z.low);
            });
            
            const minPrice = Math.min(...allPrices) - 5;
            const maxPrice = Math.max(...allPrices) + 5;
            const priceRange = maxPrice - minPrice;
            const chartHeight = 250;
            
            const priceToY = (price) => {
                return chartHeight - ((price - minPrice) / priceRange * chartHeight);
            };
            
            let zonesHtml = '';
            dimData.zones.forEach(zone => {
                const topY = priceToY(zone.high);
                const bottomY = priceToY(zone.low);
                const height = Math.max(bottomY - topY, 8);
                const isBull = zone.type.toLowerCase().includes('bull');
                const tfClass = 'tf-' + zone.tf.toLowerCase();
                
                zonesHtml += `
                    <div class="analysis-zone-chart-zone ${isBull ? 'bull' : 'bear'} ${tfClass}" 
                         style="top: ${topY}px; height: ${height}px;">
                        <span class="analysis-zone-chart-zone-tf">${zone.tf.toUpperCase()}</span>
                        <span style="margin-left: 8px; opacity: 0.7;">${zone.low.toLocaleString()}-${zone.high.toLocaleString()}</span>
                    </div>
                `;
            });
            
            // Entry line
            const entryY = priceToY(entry);
            zonesHtml += `
                <div class="analysis-zone-chart-line entry" style="top: ${entryY}px;"></div>
                <div class="analysis-zone-chart-current" style="top: ${entryY}px;"></div>
                <div class="analysis-zone-chart-label entry" style="top: ${entryY}px;">► Entry ${entry.toLocaleString()}</div>
            `;
            
            // Target line
            if (target) {
                const targetY = priceToY(target);
                zonesHtml += `
                    <div class="analysis-zone-chart-line target" style="top: ${targetY}px;"></div>
                    <div class="analysis-zone-chart-label target" style="top: ${targetY}px;">◆ Target ${target.toLocaleString()}</div>
                `;
            }
            
            // Stop line (for support)
            if (stop && isSupport) {
                const stopY = priceToY(stop);
                zonesHtml += `
                    <div class="analysis-zone-chart-line stop" style="top: ${stopY}px;"></div>
                    <div class="analysis-zone-chart-label stop" style="top: ${stopY}px;">■ Stop ${stop.toLocaleString()}</div>
                `;
            }
            
            // Price axis labels
            const priceSteps = 5;
            let axisHtml = '';
            for (let i = 0; i <= priceSteps; i++) {
                const price = maxPrice - (priceRange * i / priceSteps);
                const isEntry = Math.abs(price - entry) < priceRange * 0.05;
                const isTarget = target && Math.abs(price - target) < priceRange * 0.05;
                let priceClass = '';
                if (isEntry) priceClass = 'entry';
                else if (isTarget) priceClass = 'target';
                axisHtml += `<div class="analysis-zone-chart-price ${priceClass}">${price.toFixed(0)}</div>`;
            }
            
            return `
                <div class="analysis-zone-chart">
                    <div class="analysis-zone-chart-title">Visual: ${isSupport ? 'Support Zones Below Entry' : 'Resistance Zones to Target'}</div>
                    <div class="analysis-zone-chart-inner">
                        <div class="analysis-zone-chart-axis">
                            ${axisHtml}
                        </div>
                        <div class="analysis-zone-chart-body" style="height: ${chartHeight}px;">
                            ${zonesHtml}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function getExampleData() {
            // Complete Firebase schema from QuantConnect
            return {
                breaker_id: "NQ_1m_20250115_1205",
                confirmation_time: "2025-01-15T12:05",
                decision: "EXECUTE",
                decision_score: 18,
                dimensions: {
                    gate: {
                        g1_trading_hours: {
                            status: "PASS",
                            current_time: "12:05 PM ET",
                            session: "NY_LUNCH",
                            is_tradeable: true,
                            in_no_trade_window: false,
                            no_trade_window_name: null,
                            reason: "Within trading hours"
                        },
                        g2_news_blackout: {
                            status: "PASS",
                            is_clear: true,
                            next_event: null,
                            minutes_until: null,
                            reason: "No scheduled events"
                        },
                        g3_price_volatility: {
                            status: "PASS",
                            nq: { atr_ratio: 1.2, status: "NORMAL" },
                            es: { atr_ratio: 1.1, status: "NORMAL" },
                            combined_status: "NORMAL",
                            reason: "ATR within normal range"
                        },
                        g4_market_volatility: {
                            status: "PASS",
                            current_vix: 15.2,
                            vix_sma: 16.0,
                            vix_ratio: 0.95,
                            vix_status: "STABLE",
                            reason: "VIX stable at 0.95x SMA"
                        },
                        g5_risk_reward: {
                            status: "PASS",
                            entry_price: 21500.0,
                            stop_price: 21480.0,
                            target_price: 21550.0,
                            risk_points: 20.0,
                            reward_points: 50.0,
                            rr_ratio: 2.5,
                            reason: "R:R 2.50 exceeds minimum 2.0"
                        },
                        g6_consecutive_losses: {
                            status: "PASS",
                            losses_1m: 0,
                            losses_5m: 1,
                            max_allowed: 3,
                            reason: "1M: 0 losses, 5M: 1 loss (max 3)"
                        },
                        g7_spy_trend: {
                            status: "PASS",
                            spy_price: 598.50,
                            spy_sma: 595.20,
                            is_above_sma: true,
                            is_near_sma: false,
                            recent_touch: true,
                            bounce_up: false,
                            trend_status: "BULLISH",
                            reason: "SPY bullish: above SMA"
                        }
                    },
                    direction: {
                        d1_nq_alignment: {
                            value: "ALIGNED",
                            bias_4h: "BULLISH",
                            bias_1h: "BULLISH",
                            bias_15m: "BULLISH",
                            high_tf_bias: "BULLISH",
                            confirms_entry: true,
                            reason: "4H BULLISH, 1H BULLISH, 15M BULLISH = ALIGNED"
                        },
                        d2_es_alignment: {
                            value: "CONVERGED",
                            es_bias_4h: "BULLISH",
                            es_bias_1h: "BULLISH",
                            es_bias_15m: "BULLISH",
                            nq_high_tf_bias: "BULLISH",
                            converges_with_nq: true,
                            reason: "ES BULLISH converges with NQ BULLISH"
                        },
                        d3_bearish_inversion: {
                            value: "STRONG",
                            failed_breakers: {
                                nq_1m_bear: true,
                                nq_5m_bear: false,
                                nq_15m_bear: true,
                                es_bear: false
                            },
                            total_failures: 2,
                            highest_tf_failed: "15m",
                            reason: "NQ 15m+NQ 1m bears failed = STRONG inversion"
                        }
                    },
                    support: {
                        s1_premium_discount: {
                            value: "DISCOUNT",
                            zone: "DISCOUNT",
                            current_price: 21500.0,
                            ranges: {
                                weekly: { high: 21800.0, low: 21200.0, position_pct: 50.0 },
                                daily: { high: 21600.0, low: 21400.0, position_pct: 50.0 },
                                session: { high: 21550.0, low: 21450.0, position_pct: 50.0 }
                            },
                            weighted_composite: 25.0,
                            reason: "At 25% = DISCOUNT"
                        },
                        s2_stacked_breakers: {
                            value: "STRONG",
                            strength: "STRONG",
                            total_layers: 3,
                            by_timeframe: { "4h": 1, "1h": 1, "15m": 1, "5m": 0 },
                            highest_tf: "1h",
                            breakers: [
                                { tf: "4h", high: 21480.0, low: 21450.0, age_bars: 120, energy: 0.8 },
                                { tf: "1h", high: 21470.0, low: 21445.0, age_bars: 45, energy: 0.9 },
                                { tf: "15m", high: 21465.0, low: 21440.0, age_bars: 12, energy: 1.0 }
                            ],
                            reason: "4H+1H+15M breakers below = STRONG support"
                        },
                        s3_stacked_fvgs: {
                            value: "MODERATE",
                            strength: "MODERATE",
                            total_layers: 2,
                            by_timeframe: { "4h": 0, "1h": 0, "15m": 1, "5m": 1 },
                            highest_tf: "15m",
                            fvgs: [
                                { tf: "15m", high: 21490.0, low: 21480.0, fill_pct: 20.0 },
                                { tf: "5m", high: 21485.0, low: 21478.0, fill_pct: 0.0 }
                            ],
                            reason: "15M+5M FVGs below = MODERATE support"
                        }
                    },
                    resistance: {
                        r1_blocking_breakers: {
                            value: "FRICTION",
                            strength: "LOW_TF",
                            total_in_path: 1,
                            by_timeframe: { "4h": 0, "1h": 0, "15m": 0, "5m": 1 },
                            highest_blocking_tf: "5m",
                            breakers: [
                                { tf: "5m", high: 21535.0, low: 21525.0, age_bars: 5, energy: 0.6 }
                            ],
                            reason: "5M bear in path = FRICTION"
                        },
                        r2_blocking_fvgs: {
                            value: "CLEAR",
                            strength: "NONE",
                            total_in_path: 0,
                            by_timeframe: { "4h": 0, "1h": 0, "15m": 0, "5m": 0 },
                            highest_blocking_tf: null,
                            fvgs: [],
                            reason: "No bearish FVGs in path = Clear"
                        }
                    },
                    energy: {
                        e1_formation_fvg: {
                            value: "HIGH",
                            strength: "HIGH",
                            has_fvg: true,
                            fvg_details: {
                                size_pct: 45.0,
                                high: 21510.0,
                                low: 21500.0
                            },
                            reason: "FVG 45% of breaker = HIGH energy"
                        },
                        e2_formation_sweep: {
                            value: "MODERATE",
                            strength: "MODERATE",
                            has_sweep: true,
                            sweep_depth_pct: 30.0,
                            sweep_low: 21475.0,
                            impulse_high: 21520.0,
                            impulse_low: 21480.0,
                            reason: "Sweep 30% of impulse = MODERATE"
                        },
                        e3_formation_smt: {
                            value: "MODERATE",
                            strength: "MODERATE",
                            has_divergence: false,
                            divergence_type: null,
                            nq_swing_price: null,
                            es_swing_price: null,
                            reason: "No divergence detected"
                        },
                        e4_bullish_attraction: {
                            value: "HIGH",
                            level: "HIGH",
                            zone_sd: 1.5,
                            sd_phase: "FRESH",
                            zone_high: 21470.0,
                            zone_low: 21450.0,
                            zone_timeframe: "1h",
                            reason: "Support zone at 1.5 SD (FRESH) = HIGH"
                        },
                        e5_bearish_attraction: {
                            value: "HIGH",
                            level: "HIGH",
                            zone_sd: 3.5,
                            sd_phase: "EXHAUSTED",
                            zone_high: 21600.0,
                            zone_low: 21580.0,
                            zone_timeframe: "4h",
                            reason: "Resistance zone at 3.5 SD (EXHAUSTED) = HIGH"
                        },
                        e6_daily_burn: {
                            value: "AVAILABLE",
                            level: "AVAILABLE",
                            burn_pct: 45.0,
                            nq: { daily_range: 180.0, adr_20: 400.0, burn_pct: 45.0 },
                            es: { daily_range: 20.0, adr_20: 50.0, burn_pct: 40.0 },
                            limiting_symbol: "NQ",
                            reason: "NQ at 45% burn = AVAILABLE"
                        }
                    }
                }
            };
        }
        
        function renderAnalysisContent(data) {
            const tabsContainer = document.getElementById('analysis-tabs');
            const contentContainer = document.getElementById('analysis-content');
            const decisionBadge = document.getElementById('analysis-decision-badge');
            const heroId = document.getElementById('analysis-hero-id');
            const heroMeta = document.getElementById('analysis-hero-meta');
            const scoreBig = document.getElementById('analysis-score-big');
            
            // Get nested dimensions
            const dims = data.dimensions || data;
            
            // Update hero section
            const decision = data.decision || 'EXECUTE';
            decisionBadge.textContent = decision;
            decisionBadge.className = 'analysis-decision-badge ' + decision.toLowerCase();
            
            heroId.textContent = data.breaker_id || 'NQ_1m_bull';
            
            // Extract time from confirmation_time
            if (data.confirmation_time) {
                const time = data.confirmation_time.split('T')[1] || '';
                heroMeta.textContent = time + ' ET';
            }
            
            const score = data.decision_score || 18;
            scoreBig.textContent = score + '/21';
            
            // Build tabs
            let tabsHtml = '';
            let contentHtml = '';
            let isFirst = true;
            
            console.log('📊 Dimensions data:', dims);
            
            Object.entries(ANALYSIS_DIMENSIONS).forEach(([category, dimensions]) => {
                const categoryData = dims[category] || {};
                const categoryMissing = !dims[category];
                
                console.log(`📊 Category ${category}:`, categoryMissing ? 'MISSING' : categoryData);
                console.log(`📊 Expected keys:`, dimensions.map(d => d.key));
                console.log(`📊 Available keys:`, Object.keys(categoryData));
                
                // Count pass/warn/fail for tab indicator
                let passCount = 0, warnCount = 0, failCount = 0, missingCount = 0;
                dimensions.forEach(dim => {
                    const dimData = categoryData[dim.key];
                    if (dimData) {
                        const val = (dimData.value || dimData.status || '').toUpperCase();
                        const cls = getValueClass(val);
                        if (cls === 'pass') passCount++;
                        else if (cls === 'warn') warnCount++;
                        else if (cls === 'fail') failCount++;
                    } else {
                        missingCount++;
                    }
                });
                
                const countClass = missingCount > 0 ? 'has-error' : failCount > 0 ? 'has-fail' : warnCount > 0 ? 'has-warn' : 'all-pass';
                const countText = missingCount > 0 ? `${passCount}/${dimensions.length} (${missingCount} missing)` : `${passCount}/${dimensions.length}`;
                
                // Tab
                tabsHtml += `
                    <div class="analysis-tab ${isFirst ? 'active' : ''}" onclick="switchTab('${category}')">
                        ${CATEGORY_LABELS[category]}
                        <span class="analysis-tab-count ${countClass}">${countText}</span>
                    </div>
                `;
                
                // Content panel
                const categoryMissingMsg = categoryMissing ? 
                    `<div style="background:rgba(248,113,113,0.15);border:1px solid rgba(248,113,113,0.4);padding:12px;border-radius:8px;margin-bottom:16px;color:#f87171;">
                        <strong>⚠️ Category "${category}" not found in confirmation data</strong><br>
                        <span style="font-size:12px;color:#888;">Available categories: ${Object.keys(dims).join(', ') || 'none'}</span>
                    </div>` : '';
                
                contentHtml += `
                    <div class="analysis-panel ${isFirst ? 'active' : ''}" id="panel-${category}">
                        ${categoryMissingMsg}
                        <div class="analysis-cards">
                            ${dimensions.map(dim => {
                                const dimData = categoryData[dim.key];
                                let value = '—';
                                let valueClass = '';
                                let errorMsg = '';
                                
                                if (dimData) {
                                    value = dimData.value || dimData.status || '—';
                                    valueClass = getValueClass(value);
                                } else {
                                    value = 'KEY NOT FOUND';
                                    valueClass = 'error';
                                    errorMsg = `<div style="color:#f87171;font-size:11px;margin-top:8px;">Expected key: <code style="background:#2a2a2a;padding:2px 6px;border-radius:3px;">${dim.key}</code><br>In category: <code style="background:#2a2a2a;padding:2px 6px;border-radius:3px;">${category}</code><br>Available: ${Object.keys(categoryData).join(', ') || 'none'}</div>`;
                                }
                                
                                return `
                                    <div class="analysis-card ${dimData ? '' : 'error-card'}">
                                        <div class="analysis-card-header">
                                            <div class="analysis-card-title">
                                                <span class="analysis-card-code">${dim.code}</span>
                                                <span class="analysis-card-name">${dim.name}</span>
                                            </div>
                                            <span class="analysis-card-value ${valueClass}">${value}</span>
                                        </div>
                                        <div class="analysis-card-visual">
                                            ${dimData ? renderDimensionVisual(dim.key, dimData) : errorMsg}
                                        </div>
                                        <div class="analysis-card-calc">
                                            <div class="analysis-calc-title">How it's calculated</div>
                                            <div class="analysis-calc-text">${dimData?.reason || 'No calculation data'}</div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
                
                isFirst = false;
            });
            
            tabsContainer.innerHTML = tabsHtml;
            contentContainer.innerHTML = contentHtml;
        }
        
        // Helper function to render price ladder for support/resistance zones
        function renderPriceLadder(data, zoneType) {
            const zones = data.breakers || data.fvgs || [];
            const isSupport = zoneType.includes('support');
            const isBreaker = zoneType.includes('breaker');
            
            if (zones.length === 0) {
                const statusText = isSupport ? 
                    (isBreaker ? 'No support breakers below' : 'No support FVGs below') :
                    (isBreaker ? 'No blocking breakers' : 'No blocking FVGs');
                const statusClass = isSupport ? 'warn' : 'pass';
                
                return `
                    <div style="text-align: center; padding: 20px; color: ${isSupport ? '#fbbf24' : '#4ade80'};">
                        <div style="font-size: 24px; margin-bottom: 8px;">${isSupport ? '—' : '✓'}</div>
                        <div style="font-size: 12px;">${statusText}</div>
                    </div>
                    <div class="analysis-metric-row">
                        <div class="analysis-metric">
                            <div class="analysis-metric-label">Total</div>
                            <div class="analysis-metric-value">${isSupport ? data.total_layers || 0 : data.total_in_path || 0}</div>
                        </div>
                        <div class="analysis-metric">
                            <div class="analysis-metric-label">${isSupport ? 'Highest TF' : 'Blocking TF'}</div>
                            <div class="analysis-metric-value">${(isSupport ? data.highest_tf : data.highest_blocking_tf)?.toUpperCase() || 'None'}</div>
                        </div>
                        <div class="analysis-metric">
                            <div class="analysis-metric-label">Strength</div>
                            <div class="analysis-metric-value ${getStrengthClass(data.strength || data.value)}">${data.strength || data.value || '—'}</div>
                        </div>
                    </div>
                `;
            }
            
            // Build zone list
            let zonesHtml = zones.map((z, i) => {
                const tfClass = 'tf-' + (z.tf || '').toLowerCase();
                const extraInfo = isBreaker ? 
                    `${z.age_bars || 0} bars · ${((z.energy || 0) * 100).toFixed(0)}% energy` :
                    `${(z.fill_pct || 0).toFixed(0)}% filled`;
                    
                return `
                    <div class="price-ladder-zone ${zoneType} ${tfClass}" style="position: relative; margin-bottom: 6px;">
                        <span class="zone-tf">${(z.tf || '').toUpperCase()}</span>
                        <span>${z.high?.toLocaleString()} - ${z.low?.toLocaleString()}</span>
                        <span class="zone-info">${extraInfo}</span>
                    </div>
                `;
            }).join('');
            
            return `
                <div style="max-height: 150px; overflow-y: auto; margin-bottom: 12px;">
                    ${zonesHtml}
                </div>
                <div class="analysis-metric-row">
                    <div class="analysis-metric">
                        <div class="analysis-metric-label">Total</div>
                        <div class="analysis-metric-value">${isSupport ? data.total_layers || 0 : data.total_in_path || 0}</div>
                    </div>
                    <div class="analysis-metric">
                        <div class="analysis-metric-label">${isSupport ? 'Highest TF' : 'Blocking TF'}</div>
                        <div class="analysis-metric-value ${(isSupport ? data.highest_tf : data.highest_blocking_tf) ? (isSupport ? 'pass' : 'fail') : ''}">${(isSupport ? data.highest_tf : data.highest_blocking_tf)?.toUpperCase() || 'None'}</div>
                    </div>
                    <div class="analysis-metric">
                        <div class="analysis-metric-label">Strength</div>
                        <div class="analysis-metric-value ${getStrengthClass(data.strength || data.value)}">${data.strength || data.value || '—'}</div>
                    </div>
                </div>
            `;
        }
        
        function renderDimensionVisual(key, data) {
            switch(key) {
                // Direction - Flow chart with arrows
                case 'd1_nq_alignment':
                    const nqAligned = data.bias_4h === 'BULLISH' && data.bias_1h === 'BULLISH' && data.bias_15m === 'BULLISH';
                    const nqArrow = nqAligned ? 'aligned' : 'mixed';
                    return `
                        <div class="direction-flow">
                            <div class="direction-flow-row">
                                <div class="direction-flow-symbol">NQ</div>
                                <div class="direction-flow-tfs">
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">4H</div>
                                        <div class="direction-flow-tf-box ${(data.bias_4h || '').toLowerCase()}">${data.bias_4h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${nqArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">1H</div>
                                        <div class="direction-flow-tf-box ${(data.bias_1h || '').toLowerCase()}">${data.bias_1h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${nqArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">15M</div>
                                        <div class="direction-flow-tf-box ${(data.bias_15m || '').toLowerCase()}">${data.bias_15m === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                </div>
                                <div class="direction-flow-result ${data.value?.toLowerCase() || ''}">${data.value || 'ALIGNED'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'd2_es_alignment':
                    const esAligned = data.es_bias_4h === 'BULLISH' && data.es_bias_1h === 'BULLISH' && data.es_bias_15m === 'BULLISH';
                    const esArrow = esAligned ? 'aligned' : 'mixed';
                    return `
                        <div class="direction-flow">
                            <div class="direction-flow-row">
                                <div class="direction-flow-symbol">ES</div>
                                <div class="direction-flow-tfs">
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">4H</div>
                                        <div class="direction-flow-tf-box ${(data.es_bias_4h || '').toLowerCase()}">${data.es_bias_4h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${esArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">1H</div>
                                        <div class="direction-flow-tf-box ${(data.es_bias_1h || '').toLowerCase()}">${data.es_bias_1h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${esArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">15M</div>
                                        <div class="direction-flow-tf-box ${(data.es_bias_15m || '').toLowerCase()}">${data.es_bias_15m === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                </div>
                                <div class="direction-flow-result ${data.converges_with_nq ? 'aligned' : 'diverged'}">${data.value || 'CONVERGED'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'd3_bearish_inversion':
                    const fb = data.failed_breakers || {};
                    return `
                        <div class="inversion-grid">
                            <div class="inversion-cell ${fb.nq_1m_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">NQ 1M Bear</div>
                                <div class="inversion-cell-icon">${fb.nq_1m_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.nq_1m_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                            <div class="inversion-cell ${fb.nq_5m_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">NQ 5M Bear</div>
                                <div class="inversion-cell-icon">${fb.nq_5m_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.nq_5m_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                            <div class="inversion-cell ${fb.nq_15m_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">NQ 15M Bear</div>
                                <div class="inversion-cell-icon">${fb.nq_15m_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.nq_15m_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                            <div class="inversion-cell ${fb.es_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">ES Bear</div>
                                <div class="inversion-cell-icon">${fb.es_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.es_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                        </div>
                        <div class="analysis-metric-row" style="margin-top: 10px;">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Bears Failed</div>
                                <div class="analysis-metric-value ${data.total_failures > 0 ? 'pass' : ''}">${data.total_failures || 0}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Highest TF</div>
                                <div class="analysis-metric-value">${data.highest_tf_failed?.toUpperCase() || 'None'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.value)}">${data.value || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                // Support - Premium/Discount gauge
                case 's1_premium_discount':
                    const composite = data.weighted_composite || 50;
                    const ranges = data.ranges || {};
                    const pdZone = composite < 35 ? 'DISCOUNT' : composite > 65 ? 'PREMIUM' : 'EQUILIBRIUM';
                    
                    return `
                        <div class="pd-gauge">
                            <div class="pd-gauge-bar">
                                <div class="pd-gauge-marker" style="left: ${composite}%;"></div>
                            </div>
                            <div class="pd-gauge-labels">
                                <span>Discount (0%)</span>
                                <span>Equilibrium</span>
                                <span>Premium (100%)</span>
                            </div>
                        </div>
                        <div class="analysis-metric-row" style="margin-top: 16px;">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Weekly</div>
                                <div class="analysis-metric-value">${ranges.weekly?.position_pct?.toFixed(0) || '—'}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Daily</div>
                                <div class="analysis-metric-value">${ranges.daily?.position_pct?.toFixed(0) || '—'}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Session</div>
                                <div class="analysis-metric-value">${ranges.session?.position_pct?.toFixed(0) || '—'}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Composite</div>
                                <div class="analysis-metric-value ${composite < 40 ? 'pass' : composite > 65 ? 'fail' : 'warn'}">${composite.toFixed(0)}%</div>
                            </div>
                        </div>
                    `;
                    
                // Support - Price ladder with actual zones
                case 's2_stacked_breakers':
                    return renderPriceLadder(data, 'support-breaker');
                    
                case 's3_stacked_fvgs':
                    return renderPriceLadder(data, 'support-fvg');
                    
                case 'r1_blocking_breakers':
                    return renderPriceLadder(data, 'resist-breaker');
                    
                case 'r2_blocking_fvgs':
                    return renderPriceLadder(data, 'resist-fvg');
                    
                // Energy dimensions
                case 'e1_formation_fvg':
                    const fvgPct = data.fvg_details?.size_pct || 0;
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Has FVG</div>
                                <div class="analysis-metric-value ${data.has_fvg ? 'pass' : 'fail'}">${data.has_fvg ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">FVG Size</div>
                                <div class="analysis-metric-value">${fvgPct.toFixed(0)}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.strength)}">${data.strength || '—'}</div>
                            </div>
                        </div>
                        <div class="analysis-progress">
                            <div class="analysis-progress-fill ${fvgPct > 30 ? 'good' : fvgPct > 15 ? 'warn' : 'bad'}" style="width: ${Math.min(fvgPct, 100)}%;"></div>
                        </div>
                    `;
                    
                case 'e2_formation_sweep':
                    const sweepPct = data.sweep_depth_pct || 0;
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Has Sweep</div>
                                <div class="analysis-metric-value ${data.has_sweep ? 'pass' : ''}">${data.has_sweep ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Sweep Depth</div>
                                <div class="analysis-metric-value">${sweepPct.toFixed(0)}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.strength)}">${data.strength || '—'}</div>
                            </div>
                        </div>
                        <div class="analysis-progress">
                            <div class="analysis-progress-fill ${sweepPct > 40 ? 'good' : sweepPct > 20 ? 'warn' : 'bad'}" style="width: ${Math.min(sweepPct, 100)}%;"></div>
                        </div>
                    `;
                    
                case 'e3_formation_smt':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Divergence</div>
                                <div class="analysis-metric-value ${data.has_divergence ? 'pass' : ''}">${data.has_divergence ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Type</div>
                                <div class="analysis-metric-value">${data.divergence_type || 'None'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.strength)}">${data.strength || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'e4_bullish_attraction':
                    const bullPhase = (data.sd_phase || 'FRESH').toLowerCase();
                    const bullLevel = Math.min(100, (4 - (data.zone_sd || 0)) / 4 * 100);
                    return `
                        <div class="attraction-visual">
                            <div class="attraction-visual-header">
                                <div class="attraction-visual-tf bullish">${data.zone_timeframe?.toUpperCase() || '—'} Support Zone</div>
                                <div class="attraction-visual-phase ${bullPhase}">${data.sd_phase || '—'}</div>
                            </div>
                            <div class="attraction-visual-sd">
                                <div class="attraction-visual-sd-value" style="color: #4ade80;">${data.zone_sd?.toFixed(1) || '—'}</div>
                                <div class="attraction-visual-sd-label">SD from Mean</div>
                            </div>
                            <div class="attraction-visual-bar">
                                <div class="attraction-visual-bar-fill bullish" style="width: ${bullLevel}%;"></div>
                            </div>
                            <div class="analysis-metric-row" style="margin-top: 10px;">
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone High</div>
                                    <div class="analysis-metric-value">${data.zone_high?.toLocaleString() || '—'}</div>
                                </div>
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone Low</div>
                                    <div class="analysis-metric-value">${data.zone_low?.toLocaleString() || '—'}</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                case 'e5_bearish_attraction':
                    const bearPhase = (data.sd_phase || 'EXHAUSTED').toLowerCase();
                    const bearLevel = Math.min(100, (data.zone_sd || 0) / 4 * 100);
                    return `
                        <div class="attraction-visual">
                            <div class="attraction-visual-header">
                                <div class="attraction-visual-tf bearish">${data.zone_timeframe?.toUpperCase() || '—'} Resistance Zone</div>
                                <div class="attraction-visual-phase ${bearPhase}">${data.sd_phase || '—'}</div>
                            </div>
                            <div class="attraction-visual-sd">
                                <div class="attraction-visual-sd-value" style="color: #f87171;">${data.zone_sd?.toFixed(1) || '—'}</div>
                                <div class="attraction-visual-sd-label">SD from Mean</div>
                            </div>
                            <div class="attraction-visual-bar">
                                <div class="attraction-visual-bar-fill bearish" style="width: ${bearLevel}%;"></div>
                            </div>
                            <div class="analysis-metric-row" style="margin-top: 10px;">
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone High</div>
                                    <div class="analysis-metric-value">${data.zone_high?.toLocaleString() || '—'}</div>
                                </div>
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone Low</div>
                                    <div class="analysis-metric-value">${data.zone_low?.toLocaleString() || '—'}</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                case 'e6_daily_burn':
                    const nqBurn = data.nq?.burn_pct || 0;
                    const esBurn = data.es?.burn_pct || 0;
                    const nqClass = nqBurn < 70 ? 'available' : nqBurn < 100 ? 'limited' : 'exhausted';
                    const esClass = esBurn < 70 ? 'available' : esBurn < 100 ? 'limited' : 'exhausted';
                    const circumf = 188; // 2 * PI * 30
                    const nqOff = circumf - (circumf * Math.min(nqBurn, 100) / 100);
                    const esOff = circumf - (circumf * Math.min(esBurn, 100) / 100);
                    
                    return `
                        <div class="burn-gauges">
                            <div class="burn-gauge">
                                <div class="burn-gauge-label">NQ</div>
                                <div class="burn-gauge-ring">
                                    <svg width="80" height="80" viewBox="0 0 80 80">
                                        <circle class="burn-gauge-bg" cx="40" cy="40" r="30"/>
                                        <circle class="burn-gauge-fill ${nqClass}" cx="40" cy="40" r="30" 
                                                stroke-dasharray="${circumf}" stroke-dashoffset="${nqOff}"/>
                                    </svg>
                                    <div class="burn-gauge-value ${nqClass}">${nqBurn.toFixed(0)}%</div>
                                </div>
                                <div class="burn-gauge-status ${nqClass}">${nqBurn < 70 ? 'Available' : nqBurn < 100 ? 'Limited' : 'Exhausted'}</div>
                            </div>
                            <div class="burn-gauge">
                                <div class="burn-gauge-label">ES</div>
                                <div class="burn-gauge-ring">
                                    <svg width="80" height="80" viewBox="0 0 80 80">
                                        <circle class="burn-gauge-bg" cx="40" cy="40" r="30"/>
                                        <circle class="burn-gauge-fill ${esClass}" cx="40" cy="40" r="30" 
                                                stroke-dasharray="${circumf}" stroke-dashoffset="${esOff}"/>
                                    </svg>
                                    <div class="burn-gauge-value ${esClass}">${esBurn.toFixed(0)}%</div>
                                </div>
                                <div class="burn-gauge-status ${esClass}">${esBurn < 70 ? 'Available' : esBurn < 100 ? 'Limited' : 'Exhausted'}</div>
                            </div>
                        </div>
                        <div class="analysis-metric-row" style="margin-top: 12px;">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">NQ Range</div>
                                <div class="analysis-metric-value">${data.nq?.daily_range?.toFixed(0) || '—'} pts</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">NQ ADR</div>
                                <div class="analysis-metric-value">${data.nq?.adr_20?.toFixed(0) || '—'} pts</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Limiting</div>
                                <div class="analysis-metric-value">${data.limiting_symbol || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                // Gate dimensions
                case 'g1_trading_hours':
                    return `
                        <div class="session-visual">
                            <div class="session-visual-time">${data.current_time || '—'}</div>
                            <div class="session-visual-badge ${data.is_tradeable ? 'active' : 'inactive'}">${data.session?.replace('_', ' ') || 'OFF HOURS'}</div>
                            ${data.in_no_trade_window ? `<div class="session-visual-badge inactive">${data.no_trade_window_name || 'No Trade'}</div>` : ''}
                        </div>
                    `;
                    
                case 'g2_news_blackout':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Clear</div>
                                <div class="analysis-metric-value ${data.is_clear ? 'pass' : 'fail'}">${data.is_clear ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Next Event</div>
                                <div class="analysis-metric-value">${data.next_event || 'None'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Minutes Until</div>
                                <div class="analysis-metric-value">${data.minutes_until || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'g3_price_volatility':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">NQ ATR Ratio</div>
                                <div class="analysis-metric-value ${getVolatilityClass(data.nq?.status)}">${data.nq?.atr_ratio?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">ES ATR Ratio</div>
                                <div class="analysis-metric-value ${getVolatilityClass(data.es?.status)}">${data.es?.atr_ratio?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Combined</div>
                                <div class="analysis-metric-value ${getVolatilityClass(data.combined_status)}">${data.combined_status || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'g4_market_volatility':
                    const vixStatus = data.vix_status || 'STABLE';
                    const vixClass = vixStatus === 'STABLE' ? 'stable' : vixStatus === 'ELEVATED' ? 'elevated' : 'high';
                    // Map VIX ratio to position (0.7 = 0%, 1.3 = 100%)
                    const vixPos = Math.min(100, Math.max(0, ((data.vix_ratio || 1) - 0.7) / 0.6 * 100));
                    
                    return `
                        <div class="vix-gauge">
                            <div class="vix-gauge-header">
                                <div class="vix-gauge-value ${vixClass}">${data.current_vix?.toFixed(1) || '—'}</div>
                                <div class="vix-gauge-ratio ${vixClass}">${data.vix_ratio?.toFixed(2) || '—'}x SMA</div>
                            </div>
                            <div class="vix-gauge-bar">
                                <div class="vix-gauge-marker" style="left: ${vixPos}%;"></div>
                            </div>
                            <div class="analysis-metric-row" style="margin-top: 12px;">
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">VIX SMA</div>
                                    <div class="analysis-metric-value">${data.vix_sma?.toFixed(1) || '—'}</div>
                                </div>
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Status</div>
                                    <div class="analysis-metric-value ${vixClass}">${vixStatus}</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                case 'g5_risk_reward':
                    const entry = data.entry_price || 0;
                    const stop = data.stop_price || 0;
                    const target = data.target_price || 0;
                    const risk = data.risk_points || 1;
                    const reward = data.reward_points || 1;
                    const total = risk + reward;
                    const riskPct = (risk / total) * 100;
                    const rewardPct = (reward / total) * 100;
                    
                    return `
                        <div class="rr-visual">
                            <div class="rr-visual-prices">
                                <div class="rr-visual-price stop">
                                    <div class="rr-visual-price-label">Stop</div>
                                    <div class="rr-visual-price-value">${stop.toLocaleString()}</div>
                                </div>
                                <div class="rr-visual-price entry">
                                    <div class="rr-visual-price-label">Entry</div>
                                    <div class="rr-visual-price-value">${entry.toLocaleString()}</div>
                                </div>
                                <div class="rr-visual-price target">
                                    <div class="rr-visual-price-label">Target</div>
                                    <div class="rr-visual-price-value">${target.toLocaleString()}</div>
                                </div>
                            </div>
                            <div class="rr-visual-bar">
                                <div class="rr-visual-bar-risk" style="width: ${riskPct}%;">${risk.toFixed(0)} pts</div>
                                <div class="rr-visual-bar-entry" style="left: ${riskPct}%;"></div>
                                <div class="rr-visual-bar-reward" style="width: ${rewardPct}%;">${reward.toFixed(0)} pts</div>
                            </div>
                            <div class="rr-visual-ratio ${data.rr_ratio >= 2 ? 'pass' : 'fail'}">${data.rr_ratio?.toFixed(2) || '—'}:1 R:R</div>
                        </div>
                    `;
                    
                case 'g6_consecutive_losses':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">1M Losses</div>
                                <div class="analysis-metric-value ${data.losses_1m < 3 ? 'pass' : 'fail'}">${data.losses_1m || 0}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">5M Losses</div>
                                <div class="analysis-metric-value ${data.losses_5m < 3 ? 'pass' : 'fail'}">${data.losses_5m || 0}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Max Allowed</div>
                                <div class="analysis-metric-value">${data.max_allowed || 3}</div>
                            </div>
                        </div>
                    `;
                    
                case 'g7_spy_trend':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">SPY Price</div>
                                <div class="analysis-metric-value">${data.spy_price?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">SPY SMA</div>
                                <div class="analysis-metric-value">${data.spy_sma?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Above SMA</div>
                                <div class="analysis-metric-value ${data.is_above_sma ? 'pass' : 'fail'}">${data.is_above_sma ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Trend</div>
                                <div class="analysis-metric-value ${data.trend_status === 'BULLISH' ? 'pass' : 'fail'}">${data.trend_status || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                default:
                    return `<div class="analysis-calc-text">Visual not available for this dimension</div>`;
            }
        }
        
        function getValueClass(value) {
            const v = (value || '').toString().toUpperCase();
            // Positive values
            if (['PASS', 'ALIGNED', 'CONVERGED', 'STRONG', 'HIGH', 'DISCOUNT', 'CLEAR', 'AVAILABLE'].includes(v)) {
                return 'pass';
            }
            // Neutral/moderate values
            if (['PARTIAL', 'MODERATE', 'FRICTION', 'EQUILIBRIUM', 'LIMITED'].includes(v)) {
                return 'warn';
            }
            // Negative values
            if (['FAIL', 'OPPOSED', 'DIVERGED', 'WEAK', 'NONE', 'LOW', 'PREMIUM', 'BLOCKED', 'EXHAUSTED'].includes(v)) {
                return 'fail';
            }
            return '';
        }
        
        function switchTab(category) {
            // Update tabs
            document.querySelectorAll('.analysis-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent.includes(CATEGORY_LABELS[category])) {
                    tab.classList.add('active');
                }
            });
            
            // Update panels
            document.querySelectorAll('.analysis-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById('panel-' + category).classList.add('active');
        }
        
        function getBiasClass(bias) {
            if (bias === 'BULLISH') return 'pass';
            if (bias === 'BEARISH') return 'fail';
            return 'warn';
        }
        
        function getStrengthClass(strength) {
            const s = (strength || '').toUpperCase();
            if (['STRONG', 'HIGH'].includes(s)) return 'pass';
            if (['MODERATE'].includes(s)) return 'warn';
            if (['WEAK', 'LOW', 'NONE'].includes(s)) return 'fail';
            return '';
        }
        
        function getVolatilityClass(status) {
            if (status === 'NORMAL') return 'pass';
            if (status === 'HOT' || status === 'DEAD') return 'fail';
            return 'warn';
        }
        
        function getSDPhaseClass(phase) {
            if (phase === 'FRESH') return 'pass';
            if (phase === 'TESTED') return 'warn';
            if (phase === 'EXHAUSTED') return 'fail';
            return '';
        }
        
        // ===== INIT =====
        window.onload = function() {
            // Start in Live mode (buttons already set in HTML)
            isLive = true;
            loadSmtData().then(() => {
                loadData();
            });
            setRefreshInterval();
            
            // Update viewport indicator on resize
            window.addEventListener('resize', updateViewportIndicator);
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (selectedEntryMin !== null) {
                        selectEntry(selectedEntryMin);
                    } else if (selectedBreakerId !== null) {
                        selectBreaker(selectedBreakerId);
                    } else if (selectedSmtId !== null) {
                        selectSmt(selectedSmtId);
                    }
                }
            });
        };
    </script>
</body>
</html>
