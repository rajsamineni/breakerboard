<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SigXFlow v6.15.31</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f10;
            color: #e0e0e0;
            font-size: 13px;
        }
        
        /* ===== HEADER ===== */
        .header {
            background: linear-gradient(180deg, #1e1e20 0%, #1a1a1c 100%);
            border-bottom: 1px solid #2a2a2e;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .logo {
            font-size: 16px;
            font-weight: 600;
            color: #60a5fa;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .logo-icon {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            padding: 5px 7px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .logo-icon::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 7px solid #4ade80;
        }
        
        .logo-icon::after {
            content: '';
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 7px solid #f87171;
        }
        
        /* Stats */
        .stats-row {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        .stat-compact {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            padding: 6px 10px;
            background: linear-gradient(135deg, #1a1a1c 0%, #1e1e20 100%);
            border: 1px solid #2a2a2e;
            border-radius: 6px;
        }
        
        .stat-compact span {
            margin-right: 3px;
            font-size: 14px;
        }
        
        .stat-compact.success { 
            color: #4ade80; 
            border-color: rgba(74, 222, 128, 0.2);
        }
        .stat-compact.success span {
            text-shadow: 0 0 8px rgba(74, 222, 128, 0.4);
        }
        .stat-compact.fail { 
            color: #f87171; 
            border-color: rgba(248, 113, 113, 0.2);
        }
        .stat-compact.fail span {
            text-shadow: 0 0 8px rgba(248, 113, 113, 0.4);
        }
        .stat-compact.win { 
            color: #fbbf24; 
            border-color: rgba(251, 191, 36, 0.2);
        }
        .stat-compact.win span {
            text-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
        }
        
        .stat {
            padding: 8px 16px;
            background: #1f1f22;
            border: 1px solid #2a2a2e;
            border-radius: 6px;
            text-align: center;
            min-width: 70px;
        }
        
        .stat-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 18px;
            font-weight: 600;
        }
        
        .stat-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .stat.active .stat-value { color: #60a5fa; }
        .stat.success .stat-value { color: #22c55e; }
        .stat.fail .stat-value { color: #ef4444; }
        .stat.win .stat-value { color: #fbbf24; }
        
        /* Navigation */
        .nav-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .btn {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 500;
            padding: 8px 14px;
            border-radius: 6px;
            border: 1px solid #3a3a3e;
            background: #252528;
            color: #bbb;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .btn:hover {
            background: #303035;
            border-color: #4a4a4e;
        }
        
        /* Primary action - subtle gold theme */
        .btn.primary {
            background: linear-gradient(135deg, #252528 0%, #2a2a2e 100%);
            border: 1px solid rgba(251, 191, 36, 0.4);
            color: #fbbf24;
            font-weight: 600;
        }
        
        .btn.primary:hover {
            background: linear-gradient(135deg, #2a2a2e 0%, #333 100%);
            border-color: rgba(251, 191, 36, 0.7);
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.2);
        }
        
        /* Secondary action - muted style */
        .btn.secondary {
            background: linear-gradient(135deg, #1e1e20 0%, #252528 100%);
            border: 1px solid #333;
            color: #888;
            font-weight: 500;
        }
        
        .btn.secondary:hover {
            border-color: #444;
            color: #aaa;
            background: linear-gradient(135deg, #252528 0%, #2a2a2e 100%);
        }
        
        .btn.live {
            background: #dc2626;
            border-color: #dc2626;
            color: #fff;
        }
        
        .btn.inactive {
            background: #1a1a1c;
            border-color: #2a2a2e;
            color: #555;
        }
        
        .btn.explore-active {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #888;
            color: #fff;
        }
        
        /* Styled selects - cohesive dark theme */
        .select-styled {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #333;
            background: linear-gradient(135deg, #1a1a1c 0%, #222 100%);
            color: #888;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .select-styled:hover {
            border-color: #444;
            color: #aaa;
        }
        
        .select-styled:focus {
            outline: none;
            border-color: rgba(251, 191, 36, 0.5);
        }
        
        .divider {
            width: 1px;
            height: 24px;
            background: linear-gradient(180deg, transparent 0%, #3a3a3e 50%, transparent 100%);
            margin: 0 4px;
        }
        
        /* Settings group - load, refresh, latest */
        .settings-group {
            display: flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, #1a1a1c 0%, #1e1e20 100%);
            padding: 4px 6px;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
        }
        
        .settings-group .select-styled {
            border: none;
            background: transparent;
            padding: 6px 8px;
        }
        
        .settings-group .btn {
            padding: 6px 12px;
        }
        
        .settings-group .countdown {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #555;
            min-width: 24px;
            text-align: center;
        }
        
        /* ===== TOOLBAR ===== */
        .toolbar {
            background: linear-gradient(180deg, #1a1a1c 0%, #161618 100%);
            border-bottom: 1px solid #252528;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .filter-group {
            display: flex;
            gap: 4px;
            background: linear-gradient(135deg, #1e1e20 0%, #222 100%);
            padding: 3px;
            border-radius: 6px;
            border: 1px solid #2a2a2e;
        }
        
        .filter-btn {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            padding: 5px 10px;
            border-radius: 4px;
            border: none;
            background: transparent;
            color: #666;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .filter-btn:hover {
            color: #999;
        }
        
        .filter-btn.active {
            background: #333;
            color: #ddd;
        }
        
        .filter-btn.nq.active { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .filter-btn.es.active { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        .filter-btn.bull.active { color: #22c55e; background: rgba(22, 163, 74, 0.2); }
        .filter-btn.bear.active { color: #f87171; background: rgba(220, 38, 38, 0.2); }
        
        .arrow-up, .arrow-down {
            display: inline-block;
            width: 0;
            height: 0;
            margin-right: 4px;
            vertical-align: middle;
        }
        
        .arrow-up {
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid currentColor;
        }
        
        .arrow-down {
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid currentColor;
        }
        
        .arrow-up-sm, .arrow-down-sm {
            display: inline-block;
            width: 0;
            height: 0;
            margin-left: 2px;
            vertical-align: middle;
        }
        
        .arrow-up-sm {
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-bottom: 5px solid currentColor;
        }
        
        .arrow-down-sm {
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-top: 5px solid currentColor;
        }
        
        .toolbar-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Breaker count badge - prominent display */
        .status-msg {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
            padding: 2px 8px;
            border-radius: 4px;
            transition: opacity 0.3s;
        }
        
        .status-msg.success {
            color: #4ade80;
        }
        
        .status-msg.error {
            color: #f87171;
        }
        
        /* ===== TIMELINE BAR ===== */
        .timeline-track {
            height: 6px;
            background: #252528;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            margin-bottom: 4px;
        }
        
        .timeline-viewport {
            position: absolute;
            height: 100%;
            background: #3b82f6;
            border-radius: 3px;
            cursor: grab;
            transition: background 0.15s;
        }
        
        .timeline-viewport:hover {
            background: #60a5fa;
        }
        
        .timeline-viewport:active {
            cursor: grabbing;
            background: #93c5fd;
        }
        
        /* ===== MAIN WRAPPER ===== */
        .main-wrapper {
            display: flex;
            height: calc(100vh - 130px);
            margin: 10px;
            gap: 10px;
        }
        
        /* ===== CHART AREA ===== */
        .chart-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #131315;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
            overflow: hidden;
            min-width: 0;
            position: relative;
        }
        
        /* Fixed Header Row */
        .header-row {
            display: flex;
            flex-shrink: 0;
            background: #1a1a1c;
            border-bottom: 1px solid #2a2a2e;
        }
        
        .left-header {
            width: 195px;
            min-width: 195px;
            height: 48px;
            padding: 0 12px;
            display: flex;
            align-items: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: #888;
            box-sizing: border-box;
        }
        
        .time-header-wrapper {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 6px 10px 0 10px;
        }
        
        .time-header {
            height: 30px;
            position: relative;
            white-space: nowrap;
        }
        
        /* Unified Scroll Container */
        .scroll-container {
            flex-grow: 1;
            overflow: auto;
            position: relative;
        }
        
        /* Main chart live cursor */
        .main-cursor-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(74, 222, 128, 0.85);
            pointer-events: none;
            z-index: 90;
            display: none;
            box-shadow: 0 0 4px rgba(74, 222, 128, 0.4);
        }
        
        .main-cursor-line.visible {
            display: block;
        }
        
        .main-cursor-time {
            position: fixed;
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: #fff;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-family: 'Roboto Mono', monospace;
            font-weight: 700;
            pointer-events: none;
            z-index: 100;
            display: none;
            white-space: nowrap;
            box-shadow: 0 0 6px rgba(74, 222, 128, 0.4);
        }
        
        .scroll-inner {
            display: flex;
            min-width: fit-content;
            min-height: 100%;
        }
        
        /* Left Panel - labels */
        .left-panel {
            width: 195px;
            min-width: 195px;
            background: #151517;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 30;
            overflow: hidden;
        }
        
        /* TF section header */
        .tf-header {
            height: 4px;
            margin-top: 8px;
            position: sticky;
            top: 0;
            z-index: 5;
        }
        
        .tf-header.tf-4h { background: linear-gradient(90deg, #f87171 0%, transparent 100%); }
        .tf-header.tf-1h { background: linear-gradient(90deg, #fbbf24 0%, transparent 100%); }
        .tf-header.tf-15m { background: linear-gradient(90deg, #4ade80 0%, transparent 100%); }
        .tf-header.tf-5m { background: linear-gradient(90deg, #60a5fa 0%, transparent 100%); }
        .tf-header.tf-1m { background: linear-gradient(90deg, #c084fc 0%, transparent 100%); }
        
        .tf-header-chart {
            height: 2px;
            display: block;
            position: sticky;
            left: 0;
            z-index: 5;
            width: 100vw;
            max-width: calc(100vw - 195px);
            background-size: 75vw 100%; /* Gradient spans 75% of viewport */
            background-repeat: no-repeat;
        }
        
        .tf-spacer {
            height: 2px;
        }
        
        /* Left panel spacer - full gradient across the panel */
        .tf-spacer[data-tf="1m"] { background: linear-gradient(90deg, #c084fc 0%, rgba(192, 132, 252, 0.5) 100%); }
        .tf-spacer[data-tf="5m"] { background: linear-gradient(90deg, #60a5fa 0%, rgba(96, 165, 250, 0.5) 100%); }
        .tf-spacer[data-tf="15m"] { background: linear-gradient(90deg, #4ade80 0%, rgba(74, 222, 128, 0.5) 100%); }
        .tf-spacer[data-tf="1h"] { background: linear-gradient(90deg, #fbbf24 0%, rgba(251, 191, 36, 0.5) 100%); }
        .tf-spacer[data-tf="4h"] { background: linear-gradient(90deg, #f87171 0%, rgba(248, 113, 113, 0.5) 100%); }
        
        /* TF background tints for chart header - gradient uses background-size */
        .tf-header-chart[data-tf="1m"] { background-image: linear-gradient(90deg, rgba(192, 132, 252, 0.5) 0%, rgba(192, 132, 252, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="5m"] { background-image: linear-gradient(90deg, rgba(96, 165, 250, 0.5) 0%, rgba(96, 165, 250, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="15m"] { background-image: linear-gradient(90deg, rgba(74, 222, 128, 0.5) 0%, rgba(74, 222, 128, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="1h"] { background-image: linear-gradient(90deg, rgba(251, 191, 36, 0.5) 0%, rgba(251, 191, 36, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="4h"] { background-image: linear-gradient(90deg, rgba(248, 113, 113, 0.5) 0%, rgba(248, 113, 113, 0.2) 50%, transparent 100%); }
        
        /* Symbol Lane rows */
        .lane-label {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            transition: all 0.2s ease;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        /* TF Group container */
        .tf-group {
            display: flex;
            flex-direction: row;
            align-items: stretch;
        }
        
        .tf-group-accent {
            width: 30px;
            min-width: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        .tf-group-accent[data-tf="1m"] { background: #c084fc; color: #1a1a1c; }
        .tf-group-accent[data-tf="5m"] { background: #60a5fa; color: #1a1a1c; }
        .tf-group-accent[data-tf="15m"] { background: #4ade80; color: #1a1a1c; }
        .tf-group-accent[data-tf="1h"] { background: #fbbf24; color: #1a1a1c; }
        .tf-group-accent[data-tf="4h"] { background: #f87171; color: #1a1a1c; }
        
        .tf-group-lanes {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .lane-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            gap: 8px;
            box-sizing: border-box;
            min-height: 68px;
            overflow: hidden;
        }
        
        .lane-row[data-symbol="ES"] {
            box-shadow: inset 0 0 0 1000px rgba(0,0,0,0.1);
        }
        
        .lane-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }
        
        .lane-stat-row {
            display: flex;
            align-items: center;
            gap: 4px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
        }
        
        .lane-stat-dir {
            width: 10px;
            font-size: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .lane-stat-dir.bull::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid #22c55e;
        }
        
        .lane-stat-dir.bear::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid #ef4444;
        }
        
        .lane-stat-counts {
            color: #888;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .lane-stat-bar {
            flex: 1;
            min-width: 20px;
            height: 6px;
            background: #252528;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .lane-stat-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .lane-stat-fill.bull {
            background: linear-gradient(90deg, #22c55e, #4ade80);
        }
        
        .lane-stat-fill.bear {
            background: linear-gradient(90deg, #ef4444, #f87171);
        }
        
        .lane-stat-pct {
            text-align: right;
            font-weight: 600;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .lane-stat-pct.bull { color: #4ade80; }
        .lane-stat-pct.bear { color: #f87171; }
        .lane-stat-pct.neutral { color: #555; }
        
        .lane-row.has-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-row.has-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Timeframe background tints for left panel */
        .tf-group[data-tf="1m"] .tf-group-lanes { background: rgba(192, 132, 252, 0.03); }
        .tf-group[data-tf="5m"] .tf-group-lanes { background: rgba(96, 165, 250, 0.03); }
        .tf-group[data-tf="15m"] .tf-group-lanes { background: rgba(74, 222, 128, 0.03); }
        .tf-group[data-tf="1h"] .tf-group-lanes { background: rgba(251, 191, 36, 0.03); }
        .tf-group[data-tf="4h"] .tf-group-lanes { background: rgba(248, 113, 113, 0.03); }
        
        .symbol-badge {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 4px;
            min-width: 28px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .symbol-badge.nq { background: rgba(37, 99, 235, 0.25); color: #60a5fa; border: 1px solid rgba(37, 99, 235, 0.4); }
        .symbol-badge.es { background: rgba(6, 182, 212, 0.25); color: #22d3ee; border: 1px solid rgba(6, 182, 212, 0.4); }
        
        /* Right Panel - chart */
        .right-panel {
            flex-grow: 1;
            position: relative;
            min-height: 100%;
        }
        
        .time-tick-label {
            position: absolute;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #555;
            top: 50%;
            transform: translateY(-50%);
            white-space: nowrap;
        }
        
        /* Date separator - vertical line marking day boundaries */
        .date-separator {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(96, 165, 250, 0.15);
            z-index: 5;
        }
        
        .date-separator-label {
            position: absolute;
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            font-weight: 500;
            color: rgba(96, 165, 250, 0.5);
            background: rgba(15, 15, 18, 0.8);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid rgba(96, 165, 250, 0.2);
            top: 2px;
            transform: translateX(-50%);
            white-space: nowrap;
            z-index: 5;
        }
        
        /* Sticky date indicator */
        .sticky-date {
            position: fixed;
            top: 130px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: #60a5fa;
            background: rgba(15, 15, 18, 0.95);
            padding: 6px 16px;
            border-radius: 20px;
            border: 1px solid rgba(96, 165, 250, 0.4);
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .sticky-date.visible {
            opacity: 1;
        }
        
        .chart-inner {
            position: relative;
            overflow: visible;
            min-height: 100%;
        }
        
        /* Swimlane row */
        .swimlane {
            position: relative;
            box-sizing: border-box;
            min-height: 68px;
        }
        
        /* Timeframe background tints for swimlanes */
        .swimlane[data-tf="1m"] { background: rgba(192, 132, 252, 0.02); }
        .swimlane[data-tf="5m"] { background: rgba(96, 165, 250, 0.02); }
        .swimlane[data-tf="15m"] { background: rgba(74, 222, 128, 0.02); }
        .swimlane[data-tf="1h"] { background: rgba(251, 191, 36, 0.02); }
        .swimlane[data-tf="4h"] { background: rgba(248, 113, 113, 0.02); }
        
        /* ES rows slightly darker for visual separation */
        .swimlane[data-symbol="ES"] {
            box-shadow: inset 0 0 0 1000px rgba(0,0,0,0.1);
        }
        
        /* ===== BREAKER BARS ===== */
        .breaker-bar {
            position: absolute;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 5px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: rgba(255,255,255,0.95);
            overflow: hidden;
            min-width: 6px;
        }
        
        .bar-right-group {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .breaker-bar.selected {
            box-shadow: 0 0 0 2px #00ffff, 0 0 12px #00ffff;
            z-index: 21;
        }
        
        /* NQ Bull = Forest Green */
        .breaker-bar.nq.bull { background: #16a34a; }
        /* NQ Bear = Crimson Red */
        .breaker-bar.nq.bear { background: #dc2626; }
        /* ES Bull = Forest Green with bottom stripe */
        .breaker-bar.es.bull { background: #16a34a; }
        /* ES Bear = Crimson Red with bottom stripe */
        .breaker-bar.es.bear { background: #dc2626; }
        
        /* ES indicator - white bottom stripe */
        .breaker-bar.es::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 0 0 4px 4px;
        }
        
        /* Completed = slightly faded */
        .breaker-bar.completed {
            opacity: 0.75;
        }
        
        /* Fib label */
        .bar-fib {
            flex-shrink: 0;
            font-size: 10px;
            opacity: 0.95;
            font-weight: 600;
            letter-spacing: -0.3px;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .bar-fib-value {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.9);
            border-radius: 2px;
            padding: 1px 3px;
            font-size: 9px;
            font-weight: 700;
            color: #000;
        }
        
        .bar-points {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.9);
            border-radius: 2px;
            padding: 1px 3px;
            font-size: 9px;
            font-weight: 700;
            color: #000;
        }
        
        /* Status dot */
        .status-dot {
            min-width: 18px;
            height: 18px;
            padding: 0 2px;
            border-radius: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 700;
            flex-shrink: 0;
            border: 2px solid rgba(255,255,255,0.95);
            color: #fff;
        }
        
        .status-dot.success, .status-dot.success-t1, .status-dot.success-t2 {
            background: #16a34a;
        }
        
        .status-dot.fail {
            background: #dc2626;
        }
        
        /* T1/T2 milestone markers on breaker bars */
        .milestone-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            pointer-events: none;
            z-index: 5;
        }
        
        .milestone-marker.t1 {
            background: linear-gradient(180deg, #fbbf24 0%, #f59e0b 100%);
            box-shadow: 0 0 4px rgba(251, 191, 36, 0.6);
        }
        
        .milestone-marker.t2 {
            background: linear-gradient(180deg, #4ade80 0%, #22c55e 100%);
            box-shadow: 0 0 4px rgba(74, 222, 128, 0.6);
        }
        
        /* SMT linked indicator on breaker bar */
        .smt-link-indicator {
            position: absolute;
            left: 3px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            font-weight: 800;
            font-family: 'Roboto Mono', monospace;
            line-height: 1;
            color: #000;
            background: linear-gradient(135deg, #ffe066 0%, #ffd700 50%, #ffb300 100%);
            border: 1px solid rgba(0,0,0,0.3);
            border-radius: 2px;
            padding: 2px 3px;
            letter-spacing: -0.5px;
            z-index: 15;
            pointer-events: none;
        }
        
        /* Breaker bar with SMT */
        .breaker-bar.has-smt {
            padding-left: 26px;
        }
        
        /* Active at entry highlight (for selection - yellow crisp) */
        .breaker-bar.active-at-entry {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 25;
            opacity: 1 !important;
        }
        
        /* Click cursor line - solid yellow line on click */
        .click-cursor-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #fbbf24;
            z-index: 100;
            pointer-events: none;
            display: none;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        .click-cursor-line.visible {
            display: block;
        }
        
        /* Cursor active - no visual highlight on cursor movement */
        .breaker-bar.cursor-active {
            /* Removed yellow highlight - only click selection highlights now */
        }
        
        .lane-row.cursor-confluence {
            /* Removed cursor confluence highlight */
        }
        
        .lane-row.cursor-confluence .symbol-badge {
            /* Removed cursor confluence badge highlight */
        }
        
        /* Live mode highlight (yellow - same as cursor) */
        .breaker-bar.live-active {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 23;
            opacity: 1 !important;
        }
        
        .lane-row.live-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-row.live-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Entry lines - DISABLED */
        .entry-line {
            display: none !important;
        }
        
        .entry-line::after {
            display: none !important;
        }
        
        .entry-line:hover {
            display: none !important;
        }
        
        .entry-line.selected {
            display: none !important;
        }
        
        /* Cursor line */
        .cursor-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            border-left: 1px dashed rgba(255, 255, 255, 0.5);
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        .cursor-line.visible {
            opacity: 1;
        }
        
        .cursor-time {
            position: fixed;
            display: none;
            background: #fbbf24;
            color: #000;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
        }
        
        /* ===== SMT MARKERS ===== */
        .smt-marker {
            position: absolute;
            width: 2px;
            z-index: 50;
            cursor: pointer;
            transition: all 0.15s;
            background: none !important;
            border-left: 2px dotted;
        }
        
        .smt-marker.bull {
            border-left-color: rgba(74, 222, 128, 0.7);
        }
        
        .smt-marker.bear {
            border-left-color: rgba(248, 113, 113, 0.7);
        }
        
        /* Invisible hit area for easier clicking */
        .smt-marker::before {
            content: '';
            position: absolute;
            top: 0;
            left: -12px;
            width: 30px;
            height: 100%;
            background: transparent;
        }
        
        .smt-marker:hover {
            width: 4px;
            border-left-width: 3px;
            margin-left: -1px;
            z-index: 60;
        }
        
        .smt-marker.bull:hover {
            border-left-color: rgba(74, 222, 128, 1);
        }
        
        .smt-marker.bear:hover {
            border-left-color: rgba(248, 113, 113, 1);
        }
        
        .smt-marker:hover .smt-diamond {
            width: 14px;
            height: 14px;
            border-width: 2px;
        }
        
        .smt-marker.selected {
            width: 4px;
            border-left-width: 3px;
            margin-left: -1px;
            z-index: 61;
        }
        
        .smt-marker.selected.bull {
            box-shadow: 0 0 0 2px #fff;
            border-left-color: rgba(74, 222, 128, 1);
        }
        
        .smt-marker.selected.bear {
            box-shadow: 0 0 0 2px #fff;
            border-left-color: rgba(248, 113, 113, 1);
        }
        
        .smt-marker.selected .smt-diamond {
            width: 14px;
            height: 14px;
            border-width: 2px;
        }
        
        .smt-marker .smt-diamond {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 10px;
            height: 10px;
            border: 2px solid;
            border-radius: 2px;
            background: #1a1a1f;
            transition: all 0.15s;
        }
        
        .smt-marker.bull .smt-diamond {
            border-color: #4ade80;
        }
        
        .smt-marker.bear .smt-diamond {
            border-color: #f87171;
        }
        
        /* Status-based marker styling */
        .smt-marker.smt-invalidated {
            opacity: 0.4;
        }
        .smt-marker.smt-invalidated .smt-diamond {
            border-style: dashed;
        }
        
        .smt-marker.smt-expired {
            opacity: 0.25;
        }
        .smt-marker.smt-expired .smt-diamond {
            border-style: dotted;
        }
        
        /* ═══════════════════════════════════════════════════════════════════════
           SMT DASHBOARD - Comprehensive Signal Analysis Panel
           ═══════════════════════════════════════════════════════════════════════ */
        
        /* Header Row - Status & Quality */
        .smt-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .smt-status-pill {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .smt-status-pill.active { background: #166534; color: #4ade80; }
        .smt-status-pill.invalidated { background: #7f1d1d; color: #fca5a5; }
        .smt-status-pill.expired { background: #44403c; color: #a8a29e; }
        
        .smt-quality-pill {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            background: #0f0f12;
            border: 1px solid #2a2a2f;
        }
        .smt-quality-pill.high { border-color: #16a34a; }
        .smt-quality-pill.med { border-color: #ca8a04; }
        .smt-quality-pill.low { border-color: #dc2626; }
        
        .smt-quality-score {
            padding: 6px 12px;
            border-radius: 6px;
            min-width: 50px;
            text-align: center;
        }
        
        .smt-quality-score .smt-quality-num {
            font-size: 16px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .smt-quality-num {
            font-size: 14px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
        }
        .smt-quality-pill.high .smt-quality-num { color: #4ade80; }
        .smt-quality-pill.med .smt-quality-num { color: #fbbf24; }
        .smt-quality-pill.low .smt-quality-num { color: #f87171; }
        
        .smt-quality-label {
            font-size: 8px;
            color: #666;
            text-transform: uppercase;
        }
        
        /* Direction Block */
        .smt-direction-block {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            border-radius: 8px;
            margin-bottom: 12px;
        }
        .smt-direction-block.bull {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
            border: 1px solid rgba(74, 222, 128, 0.3);
        }
        .smt-direction-block.bear {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.15) 0%, rgba(248, 113, 113, 0.05) 100%);
            border: 1px solid rgba(248, 113, 113, 0.3);
        }
        
        .smt-dir-icon {
            font-size: 28px;
            font-weight: 700;
            line-height: 1;
        }
        .smt-direction-block.bull .smt-dir-icon { color: #4ade80; }
        .smt-direction-block.bear .smt-dir-icon { color: #f87171; }
        
        .smt-dir-info {
            flex: 1;
        }
        .smt-dir-label {
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 1px;
        }
        .smt-direction-block.bull .smt-dir-label { color: #4ade80; }
        .smt-direction-block.bear .smt-dir-label { color: #f87171; }
        
        .smt-dir-expect {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }
        
        .smt-swept-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.4);
        }
        
        /* Section Title */
        .smt-section-title {
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #555;
            margin-bottom: 8px;
        }
        
        /* Story Cards */
        /* SMT Divergence Chart - Tight */
        .smt-div-chart {
            display: flex;
            gap: 4px;
            align-items: stretch;
        }
        
        .smt-div-panel {
            flex: 1;
            background: #18181a;
            border: 1px solid #2a2a2e;
            border-radius: 6px;
            padding: 6px 8px;
            min-width: 0;
        }
        
        .smt-div-panel.sweep { border-left: 2px solid #f87171; }
        .smt-div-panel.defender { border-left: 2px solid #4ade80; }
        
        .smt-div-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .smt-div-title {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .smt-div-role {
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .smt-div-panel.sweep .smt-div-role { color: #f87171; }
        .smt-div-panel.defender .smt-div-role { color: #4ade80; }
        
        .smt-div-asset {
            font-size: 10px;
            font-weight: 600;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .smt-div-asset.nq { background: #1e3a5f; color: #60a5fa; }
        .smt-div-asset.es { background: #3f2e1e; color: #fbbf24; }
        
        .smt-div-structure {
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            color: #555;
        }
        
        /* LL/LH = bearish structures, HL/HH = bullish structures */
        .smt-div-structure.LL, .smt-div-structure.LH { color: #f87171; }
        .smt-div-structure.HL, .smt-div-structure.HH { color: #4ade80; }
        
        .smt-div-chart-area {
            height: 60px;
            position: relative;
        }
        
        .smt-div-svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .smt-div-svg .price-label {
            font-family: 'Roboto Mono', monospace;
            font-weight: 500;
        }
        
        .smt-div-svg .price-label.prev { fill: #999; }
        .smt-div-svg .price-label.curr { fill: #e0e0e0; }
        
        .smt-div-svg .time-label {
            font-family: 'Roboto Mono', monospace;
            fill: #999;
        }
        
        .smt-div-svg .chart-line {
            stroke-width: 2;
            fill: none;
            stroke-linecap: round;
        }
        
        .smt-div-panel.sweep .smt-div-svg .chart-line { stroke: #f87171; }
        .smt-div-panel.defender .smt-div-svg .chart-line { stroke: #4ade80; }
        
        .smt-div-svg .chart-point {
            stroke-width: 2;
        }
        
        .smt-div-svg .chart-point.prev {
            fill: #18181a;
            stroke: #555;
        }
        
        .smt-div-panel.sweep .smt-div-svg .chart-point.curr { fill: #f87171; stroke: #f87171; }
        .smt-div-panel.defender .smt-div-svg .chart-point.curr { fill: #4ade80; stroke: #4ade80; }
        
        .smt-div-delta {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            margin-top: 4px;
            text-align: right;
        }
        
        .smt-div-delta.positive { color: #4ade80; }
        .smt-div-delta.negative { color: #f87171; }
        
        .smt-div-vs {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            flex-shrink: 0;
            color: #444;
            font-size: 12px;
        }
        
        /* Detection Grid */
        .smt-detection-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .smt-detect-item {
            background: #0a0a0c;
            border-radius: 6px;
            padding: 8px 10px;
            border: 1px solid #1a1a1f;
        }
        
        .smt-detect-label {
            font-size: 8px;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .smt-detect-value {
            font-size: 11px;
            font-weight: 600;
            color: #ccc;
        }
        .smt-detect-value.method {
            font-size: 10px;
            color: #a78bfa;
        }
        .smt-detect-value.strength {
            color: #fbbf24;
            letter-spacing: 2px;
        }
        .smt-detect-value.asset {
            font-weight: 700;
        }
        .smt-detect-value.asset.nq { color: #60a5fa; }
        .smt-detect-value.asset.es { color: #fbbf24; }
        .smt-detect-value.price {
            font-family: 'Roboto Mono', monospace;
            color: #fb923c;
        }
        
        /* Criteria Chips */
        .smt-criteria-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }
        .smt-criteria-row:last-child { margin-bottom: 0; }
        
        .smt-criteria-chip {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            background: #0a0a0c;
            border: 1px solid #2a2a2f;
            cursor: default;
        }
        .smt-criteria-chip.ok {
            border-color: rgba(74, 222, 128, 0.4);
            color: #4ade80;
        }
        .smt-criteria-chip.fail {
            border-color: #333;
            color: #666;
        }
        .smt-criteria-row.levels .smt-criteria-chip.ok {
            border-color: rgba(251, 191, 36, 0.4);
            color: #fbbf24;
        }
        
        .smt-chip-icon {
            font-size: 9px;
        }
        .smt-chip-label {
            font-family: 'Roboto Mono', monospace;
        }
        
        /* Methods Pills - inside direction block */
        .smt-dir-methods {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }
        
        .smt-method-pill {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            padding: 3px 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.7);
        }
        
        /* Criteria List - Big & Visible */
        .smt-criteria-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .smt-criteria-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 4px;
            background: #0a0a0c;
            border: 1px solid #1a1a1f;
        }
        
        .smt-criteria-row.ok {
            border-color: rgba(74, 222, 128, 0.25);
            background: rgba(74, 222, 128, 0.03);
        }
        
        .smt-criteria-label {
            font-size: 12px;
            font-weight: 500;
            color: #555;
        }
        
        .smt-criteria-row.ok .smt-criteria-label {
            color: #ccc;
        }
        
        .smt-criteria-status {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            width: 16px;
            text-align: center;
        }
        
        .smt-criteria-row.ok .smt-criteria-status {
            color: #4ade80;
        }
        
        .smt-criteria-row:not(.ok) .smt-criteria-status {
            color: #444;
        }
        
        /* Quality Bar Section */
        .smt-quality-bar-section {
            background: #0a0a0c;
            border-radius: 6px;
            padding: 10px;
        }
        
        .smt-qbar-track {
            position: relative;
            height: 8px;
            background: #1a1a1f;
            border-radius: 4px;
            overflow: visible;
            margin-bottom: 6px;
        }
        
        .smt-qbar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .smt-qbar-fill.high { background: linear-gradient(90deg, #16a34a, #4ade80); }
        .smt-qbar-fill.med { background: linear-gradient(90deg, #ca8a04, #fbbf24); }
        .smt-qbar-fill.low { background: linear-gradient(90deg, #dc2626, #f87171); }
        
        .smt-qbar-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
        }
        .smt-qbar-mark {
            position: absolute;
            top: -14px;
            transform: translateX(-50%);
            font-size: 8px;
            color: #444;
            font-family: 'Roboto Mono', monospace;
        }
        
        .smt-qbar-labels {
            display: flex;
            justify-content: space-between;
            font-size: 8px;
            color: #444;
            text-transform: uppercase;
        }
        
        /* Meta Row */
        .smt-meta-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin-top: 8px;
            border-top: 1px solid #1a1a1f;
        }
        
        .smt-meta-tf {
            font-size: 10px;
            font-weight: 700;
            color: #888;
            font-family: 'Roboto Mono', monospace;
        }
        .smt-meta-sep { color: #333; }
        .smt-meta-id {
            font-size: 9px;
            color: #444;
            font-family: 'Roboto Mono', monospace;
        }
        
        /* Footer Section */
        .smt-footer-section {
            background: #0a0a0c;
            border-radius: 6px;
            padding: 10px 12px;
            margin-top: 8px;
        }
        
        .smt-footer-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
        }
        
        .smt-footer-row:not(:last-child) {
            border-bottom: 1px solid #1a1a1f;
        }
        
        .smt-footer-label {
            font-size: 10px;
            color: #555;
            text-transform: uppercase;
        }
        
        .smt-footer-value {
            font-family: 'Roboto Mono', monospace;
        }
        
        .smt-footer-value.time {
            font-size: 12px;
            font-weight: 600;
            color: #fbbf24;
        }
        
        .smt-footer-value.tf {
            font-size: 12px;
            font-weight: 700;
            color: #a78bfa;
        }
        
        .smt-footer-value.id {
            font-size: 11px;
            color: #aaa;
            word-break: break-all;
        }
        
        /* ===== DETAIL PANEL ===== */
        .detail-panel {
            width: 420px;
            min-width: 420px;
            background: #1a1a1c;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-header {
            padding: 10px 16px;
            background: #1f1f22;
            border-bottom: 1px solid #2a2a2e;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .panel-time {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            color: #fbbf24;
        }
        
        .panel-type {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .panel-type.live {
            color: #f87171;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .panel-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #555;
            text-align: center;
            padding: 20px;
        }
        
        .panel-empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        
        .panel-empty-text {
            font-size: 13px;
            line-height: 1.5;
        }
        
        /* Breaker Detail View */
        .detail-section {
            margin-bottom: 20px;
        }
        
        .detail-section:last-child {
            margin-bottom: 0;
        }
        
        .detail-section-title {
            font-size: 10px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #2a2a2e;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .live-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #60a5fa;
            animation: pulse-live 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-live {
            0%, 100% { opacity: 1; box-shadow: 0 0 6px #60a5fa; }
            50% { opacity: 0.6; box-shadow: 0 0 3px #60a5fa; }
        }
        
        .detail-id {
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
        }
        
        .detail-badges {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .detail-badge {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 4px;
        }
        
        .detail-badge.nq { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .detail-badge.es { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        .detail-badge.bull { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .detail-badge.bear { background: rgba(249, 115, 22, 0.2); color: #fb923c; }
        .detail-badge.active { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .detail-badge.success { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
        .detail-badge.fail { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #222;
        }
        
        .detail-row:last-child {
            border-bottom: none;
        }
        
        .detail-label {
            color: #888;
            font-size: 12px;
        }
        
        .detail-value {
            font-family: 'Roboto Mono', monospace;
            color: #ddd;
            font-size: 12px;
            font-weight: 500;
        }
        
        .detail-value.large {
            font-size: 18px;
            color: #fff;
        }
        
        .detail-metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 8px;
        }
        
        .detail-metric {
            background: #1a1a1c;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }
        
        .detail-metric-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 18px;
            font-weight: 600;
            color: #fff;
        }
        
        .detail-metric-label {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .failure-reason {
            margin-top: 8px;
            padding: 6px 10px;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 4px;
            font-size: 11px;
            color: #ef4444;
        }
        
        /* Detail grid for organized info display */
        .detail-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .detail-grid-item {
            background: #1a1a1c;
            border-radius: 4px;
            padding: 8px 10px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .detail-grid-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .detail-grid-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            color: #e0e0e0;
            font-weight: 500;
        }
        
        .detail-grid-value.success {
            color: #4ade80;
        }
        
        .detail-grid-value.warn {
            color: #fbbf24;
        }
        
        .detail-grid-value.fail {
            color: #f87171;
        }
        
        .detail-grid-value.highlight {
            color: #60a5fa;
            font-weight: 600;
        }
        
        .detail-badge.tf {
            background: #374151;
            color: #9ca3af;
        }
        
        /* ===== BREAKER DETAIL v3.4 ===== */
        /* ===== BREAKER DETAIL v3.7 - Elegant Header ===== */
        .bd-header-new {
            padding-bottom: 12px;
            border-bottom: 1px solid #2a2a2e;
            margin-bottom: 12px;
        }
        
        .bd-top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .bd-symbol-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .bd-symbol {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            padding: 4px 10px;
            border-radius: 4px;
        }
        
        .bd-symbol.nq { background: #1e40af; color: #93c5fd; }
        .bd-symbol.es { background: #0e7490; color: #67e8f9; }
        
        .bd-dir { font-size: 18px; font-weight: 700; }
        .bd-dir.bull { color: #60a5fa; }
        .bd-dir.bear { color: #fb923c; }
        
        .bd-outcome {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 12px;
            border-radius: 4px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
        }
        
        .bd-outcome.active { background: rgba(96, 165, 250, 0.15); color: #60a5fa; }
        .bd-outcome.success { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
        .bd-outcome.fail { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        
        .bd-info-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            color: #9ca3af;
        }
        
        .bd-tf {
            background: #1f1f23;
            padding: 2px 8px;
            border-radius: 3px;
            color: #e0e0e0;
        }
        
        .bd-separator {
            color: #4b5563;
        }
        
        .bd-timerange {
            color: #9ca3af;
        }
        
        .bd-dur {
            color: #6b7280;
        }
        
        /* Metrics Row - 4 columns */
        .bd-metrics-row {
            display: flex;
            justify-content: space-between;
            background: #1a1a1c;
            border-radius: 8px;
            padding: 10px 8px;
            margin-bottom: 10px;
        }
        
        .bd-metric {
            text-align: center;
            flex: 1;
        }
        
        .bd-metric-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 18px;
            font-weight: 700;
            color: #e0e0e0;
            display: block;
            line-height: 1.2;
        }
        
        .bd-metric-value.good {
            color: #4ade80;
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.3);
        }
        
        .bd-metric-label {
            font-size: 9px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-top: 2px;
            display: block;
        }
        
        /* Zone Entry - Clean Elegant Design */
        .bd-zone-entry {
            background: linear-gradient(135deg, #18181b 0%, #1c1c20 100%);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            border: 1px solid #2a2a2e;
        }
        
        .bd-zone-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .bd-zone-title {
            font-size: 11px;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }
        
        .bd-zone-pct {
            font-family: 'Roboto Mono', monospace;
            font-weight: 700;
            font-size: 18px;
        }
        
        .bd-zone-pct.good { color: #4ade80; }
        .bd-zone-pct.partial { color: #fbbf24; }
        .bd-zone-pct.bad { color: #f87171; }
        .bd-zone-pct.none { color: #4b5563; }
        
        /* Zone Bar Container */
        .bd-zone-bar-container {
            position: relative;
            margin-bottom: 8px;
        }
        
        .bd-zone-bar-track {
            display: flex;
            height: 12px;
            border-radius: 0;
            overflow: hidden;
            background: #252528;
        }
        
        .bd-zone-bar-segment {
            position: relative;
            height: 100%;
        }
        
        .bd-zone-bar-segment.zone {
            background: #2a2a2e;
        }
        
        .bd-zone-bar-segment.zone.bull {
            background: rgba(74, 222, 128, 0.15);
            border-right: 2px solid rgba(74, 222, 128, 0.4);
        }
        
        .bd-zone-bar-segment.zone.bear {
            background: rgba(248, 113, 113, 0.15);
            border-left: 2px solid rgba(248, 113, 113, 0.4);
        }
        
        .bd-zone-bar-segment.gray {
            background: #1a1a1c;
        }
        
        .bd-zone-bar-segment.blank {
            background: transparent;
            position: relative;
        }
        
        .bd-zone-bar-fill {
            position: absolute;
            top: 0;
            height: 100%;
            border-radius: 0;
            transition: width 0.3s ease;
        }
        
        .bd-zone-bar-fill.bull {
            left: 0;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            box-shadow: 0 0 8px rgba(74, 222, 128, 0.5);
        }
        
        .bd-zone-bar-fill.bear {
            right: 0;
            background: linear-gradient(90deg, #f87171, #ef4444);
            box-shadow: 0 0 8px rgba(248, 113, 113, 0.5);
        }
        
        /* Zone Size Badge - Centered on bar */
        .bd-zone-size-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            font-weight: 700;
            color: #9ca3af;
            background: #252528;
            padding: 1px 6px;
            border-radius: 0;
            border: 1px solid #3a3a3e;
            z-index: 2;
        }
        
        /* Price Levels Grid - 3 columns */
        .bd-zone-levels-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }
        
        .bd-zone-levels-grid.two-col {
            grid-template-columns: 1fr 1fr;
        }
        
        .bd-zone-level-col {
            display: flex;
            flex-direction: column;
        }
        
        .bd-zone-level-col.left {
            align-items: flex-start;
        }
        
        .bd-zone-level-col.center {
            align-items: center;
        }
        
        .bd-zone-level-col.right {
            align-items: flex-end;
        }
        
        /* Legacy relative positioning (keeping for compatibility) */
        .bd-zone-levels-relative {
            position: relative;
            height: 65px;
            margin-top: 12px;
        }
        
        .bd-zone-level-abs {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: translateX(-50%);
        }
        
        .bd-zone-level-abs.level-start {
            transform: translateX(0);
            align-items: flex-start;
        }
        
        .bd-zone-level-abs.level-mid {
            transform: translateX(-50%);
            align-items: center;
        }
        
        .bd-zone-level-abs.level-end {
            transform: translateX(-100%);
            align-items: flex-end;
        }
        
        .bd-zone-levels-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-top: 12px;
        }
        
        .bd-zone-level {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }
        
        .bd-zone-level.left { align-items: flex-start; }
        .bd-zone-level.right { align-items: flex-end; }
        
        .bd-zone-level-label {
            font-size: 9px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 3px;
            font-weight: 500;
        }
        
        .bd-zone-level-fib {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 2px;
        }
        
        .bd-zone-level-fib.bull { color: #4ade80; }
        .bd-zone-level-fib.bear { color: #f87171; }
        .bd-zone-level-fib.neutral { color: #6b7280; }
        
        .bd-zone-level-price {
            font-family: 'Roboto Mono', monospace;
            font-size: 15px;
            font-weight: 600;
            color: #f0f0f0;
        }
        
        .bd-zone-level-price.muted {
            color: #6b7280;
            font-size: 14px;
        }
        
        .bd-level {
            text-align: center;
        }
        
        .bd-level-label {
            font-size: 8px;
            color: #4b5563;
            text-transform: uppercase;
            display: block;
        }
        
        .bd-level-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            color: #9ca3af;
        }
        
        .bd-level-size {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #6b7280;
            background: #2a2a2e;
            padding: 2px 8px;
            border-radius: 4px;
        }
        
        /* Chart Sections */
        .bd-chart-section {
            margin-bottom: 8px;
        }
        
        .bd-chart-title {
            font-size: 9px;
            color: #4b5563;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .bd-chart-legend {
            font-size: 8px;
            color: #6b7280;
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .bd-chart-legend .leg-p,
        .bd-chart-legend .leg-c {
            display: inline-block;
            width: 12px;
            height: 2px;
            margin-right: 3px;
            vertical-align: middle;
        }
        
        .bd-chart-legend .leg-p { background: #60a5fa; }
        .bd-chart-legend .leg-c { background: #fb923c; }
        
        /* Breaker ID footer */
        .bd-breaker-id {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #9ca3af;
            text-align: center;
            padding: 10px 8px;
            background: #1a1a1c;
            border-radius: 4px;
            margin-top: 10px;
            word-break: break-all;
            letter-spacing: 0.3px;
        }

        /* Analysis Button */
        .bd-analysis-btn {
            margin-top: 8px;
            padding: 8px;
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.1), rgba(139, 92, 246, 0.1));
            border: 1px solid rgba(96, 165, 250, 0.2);
            border-radius: 6px;
            text-align: center;
            font-size: 11px;
            color: #60a5fa;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .bd-analysis-btn:hover {
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.2), rgba(139, 92, 246, 0.2));
            border-color: rgba(96, 165, 250, 0.4);
        }
        
        .compact-info {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px 0 !important;
        }
        
        .info-item {
            flex: 1 1 45%;
            min-width: 60px;
            background: #1a1a1c;
            border-radius: 4px;
            padding: 8px;
            text-align: center;
        }
        
        .info-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            display: block;
        }
        
        .info-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .price-zone-container {
            background: #151517;
            border-radius: 6px;
            padding: 12px;
        }
        
        .price-chart {
            width: 100%;
            height: 140px;
            cursor: crosshair;
        }
        
        .price-chart-breaker-zone {
            fill: rgba(96, 165, 250, 0.15);
        }
        
        .price-chart-breaker-line {
            stroke: #60a5fa;
            stroke-width: 2;
        }
        
        .price-chart-level {
            stroke: #444;
            stroke-width: 1;
            stroke-dasharray: 4, 4;
        }
        
        .price-chart-price-line {
            fill: none;
            stroke: #f97316;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        .price-chart-price-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            fill: #60a5fa;
        }
        
        .price-chart-price-label.zone-label {
            fill: #60a5fa;
            font-weight: 600;
        }
        
        .price-chart-current {
            fill: #4ade80;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .price-chart-current-line {
            stroke: #4ade80;
            stroke-width: 1;
            opacity: 0.5;
        }
        
        .price-chart-current-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            fill: #4ade80;
            font-weight: 600;
        }
        
        .price-chart-cursor {
            stroke: #888;
            stroke-width: 1;
            stroke-dasharray: 2,2;
        }
        
        .price-chart-hover-dot {
            fill: #f97316;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .price-chart-time-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            fill: #666;
        }
        
        .price-chart-container {
            position: relative;
        }
        
        .price-chart-hover-info {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            color: #e0e0e0;
            padding: 4px 0;
            min-height: 20px;
            opacity: 0;
            transition: opacity 0.15s;
        }
        
        .price-chart-hover-info .hover-price {
            color: #f97316;
            font-weight: 600;
        }
        
        .price-chart-hover-info .hover-time {
            color: #9ca3af;
        }
        
        /* Entry Context View */
        .context-time {
            font-family: 'Roboto Mono', monospace;
            font-size: 20px;
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: 16px;
        }
        
        .context-grid {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .context-row {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            background: #151517;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .context-row.active {
            background: rgba(251, 191, 36, 0.12);
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
        }
        
        .context-row.live-active-row {
            background: rgba(251, 191, 36, 0.12);
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
        }
        
        .context-tf {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            width: 36px;
            color: #888;
        }
        
        .context-symbol {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            width: 28px;
            padding: 2px 4px;
            border-radius: 3px;
            text-align: center;
            margin-right: 10px;
        }
        
        .context-symbol.nq { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .context-symbol.es { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        
        .context-dir {
            font-size: 11px;
            font-weight: 600;
            width: 50px;
        }
        
        .context-dir.bull { color: #60a5fa; }
        .context-dir.bear { color: #fb923c; }
        .context-dir.none { color: #555; }
        
        .context-header {
            display: flex;
            align-items: center;
            padding: 4px 10px;
            font-size: 9px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #2a2a2e;
            margin-bottom: 4px;
        }
        
        .context-header span:nth-child(1) { width: 36px; }
        .context-header span:nth-child(2) { width: 38px; }
        .context-header span:nth-child(3) { width: 50px; }
        .context-header span:nth-child(4) { flex: 1; }
        .context-header span:nth-child(5) { width: 24px; text-align: center; }
        
        .context-fib {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #aaa;
            flex: 1;
        }
        
        .context-status-icon {
            font-size: 11px;
            width: 24px;
            text-align: center;
        }
        
        .context-status-icon.active { color: #60a5fa; }
        .context-status-icon.success, .context-status-icon.success-t1, .context-status-icon.success-t2 { color: #4ade80; }
        .context-status-icon.fail { color: #f87171; }
        .context-status-icon.none { color: #444; }
        
        .arrow-bull { color: #4ade80; }
        .arrow-bear { color: #f87171; }
        
        .context-summary {
            margin-top: 16px;
            padding: 12px;
            background: #151517;
            border-radius: 6px;
        }
        
        .context-summary-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }
        
        .context-summary-label {
            color: #888;
            font-size: 12px;
        }
        
        .context-summary-value {
            font-family: 'Roboto Mono', monospace;
            font-weight: 600;
            font-size: 12px;
        }
        
        .context-summary-value.good { color: #4ade80; }
        .context-summary-value.bad { color: #f87171; }
        .context-summary-value.neutral { color: #fbbf24; }
        
        /* Confluence Fib Tracks */
        .confluence-fib-tracks {
            margin-top: 16px;
        }
        
        .confluence-fib-track {
            background: #151517;
            border-radius: 6px;
            margin-bottom: 8px;
            overflow: hidden;
            border-left: 3px solid #333;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .confluence-fib-track:hover {
            background: #1a1a1c;
            border-color: #555;
        }
        
        .confluence-fib-track.bull {
            border-left-color: #4ade80;
        }
        
        .confluence-fib-track.bear {
            border-left-color: #f87171;
        }
        
        .confluence-fib-track-header {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            gap: 6px;
        }
        
        .confluence-fib-track-tf {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            color: #e0e0e0;
            width: 28px;
        }
        
        .confluence-fib-track-badge {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: 500;
        }
        
        .confluence-fib-track-badge.nq { background: #2563eb20; color: #60a5fa; }
        .confluence-fib-track-badge.es { background: #7c3aed20; color: #a78bfa; }
        
        .confluence-fib-track-fib {
            margin-left: auto;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #60a5fa;
            font-weight: 500;
        }
        
        .confluence-fib-track-chart {
            padding: 0 8px 8px 8px;
        }
        
        /* Stacked view styles */
        .confluence-stacked-view {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        /* Live cursor styling */
        .cursor-line.live-cursor {
            background: linear-gradient(180deg, rgba(74, 222, 128, 0.8) 0%, rgba(74, 222, 128, 0.3) 100%);
            width: 2px;
            box-shadow: 0 0 8px rgba(74, 222, 128, 0.5);
        }
        
        /* Stacked Breaker Charts */
        .stack-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .stack-item {
            background: #111;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: filter 0.15s, box-shadow 0.15s;
        }
        
        .stack-item:hover {
            filter: brightness(1.15);
        }
        
        .stack-item.selected {
            box-shadow: 0 0 0 2px #00ffff, 0 0 8px #00ffff;
        }
        
        .stack-label {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: #0a0a0c;
            border-left: 4px solid #888;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
        }
        
        .stack-tf {
            font-weight: 700;
            min-width: 24px;
        }
        
        .stack-sym {
            color: #777;
        }
        
        .stack-dir {
            font-weight: 600;
        }
        
        .stack-spacer {
            flex: 1;
        }
        
        .stack-legend {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            color: #777;
        }
        
        .legend-line {
            width: 14px;
            height: 2px;
            border-radius: 1px;
        }
        
        .legend-line.dashed {
            height: 0;
            border-top: 2px dashed;
        }
        
        .stack-charts {
            display: flex;
            flex-direction: column;
            background: #0c0c0f;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .stack-charts-wrapper {
            position: relative;
        }
        
        .detail-cursor-line {
            position: absolute;
            top: 0;
            bottom: 24px;
            width: 2px;
            background: rgba(74, 255, 150, 0.95);
            pointer-events: none;
            z-index: 10;
            display: none;
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.8), 0 0 25px rgba(74, 222, 128, 0.5);
        }
        
        .detail-cursor-line.visible {
            display: block;
        }
        
        .detail-cursor-time {
            position: absolute;
            bottom: 2px;
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: #fff;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 10px;
            font-family: 'Roboto Mono', monospace;
            font-weight: 600;
            pointer-events: none;
            z-index: 11;
            display: none;
            transform: translateX(-50%);
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.6);
        }
        
        .detail-cursor-time.visible {
            display: block;
        }
        
        .stack-svg {
            width: 100%;
            height: 90px;
            display: block;
        }
        
        .stack-svg-tall {
            width: 100%;
            height: 200px;
            display: block;
        }
        
        .stack-empty {
            padding: 16px;
            text-align: center;
            color: #444;
            font-size: 10px;
        }
        
        /* Unified Breaker Cards */
        .confluence-cards {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        /* Old card styles - keep for right panel */
        .confluence-card-old {
            display: flex;
            background: #111;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .confluence-card-old:hover {
            background: #1a1a1c;
        }
        
        .card-accent {
            width: 4px;
            flex-shrink: 0;
        }
        
        .card-content {
            flex: 1;
            min-width: 0;
        }
        
        .card-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: #0a0a0a;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
        }
        
        .card-tf {
            font-weight: 700;
            min-width: 24px;
        }
        
        .card-symbol {
            color: #888;
        }
        
        .card-dir {
            font-weight: 600;
        }
        
        .card-spacer {
            flex: 1;
        }
        
        .card-fib {
            color: #666;
        }
        
        .card-price {
            color: #555;
        }
        
        .card-charts {
            display: flex;
            flex-direction: column;
            gap: 1px;
            padding: 2px;
        }
        
        .card-chart {
            width: 100%;
            height: 32px;
            display: block;
        }
        
        .card-no-data {
            padding: 8px;
            text-align: center;
            color: #444;
            font-size: 10px;
        }
        
        .confluence-stack-section {
            background: #111;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .confluence-stack-title {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 8px 12px;
            background: #0a0a0a;
            border-bottom: 1px solid #1a1a1a;
        }
        
        .confluence-stack-charts {
            display: flex;
            flex-direction: column;
        }
        
        .confluence-stack-box {
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid #1a1a1a;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .confluence-stack-box:last-child {
            border-bottom: none;
        }
        
        .confluence-stack-box:hover {
            background: #151515;
        }
        
        /* Standard: bull=green, bear=red */
        .confluence-stack-box.bull {
            border-left: 3px solid #4ade80;
        }
        
        .confluence-stack-box.bear {
            border-left: 3px solid #f87171;
        }
        
        .confluence-stack-label {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: #0d0d0d;
        }
        
        .stack-tf {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: #ccc;
        }
        
        .stack-sym {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            color: #888;
        }
        
        .stack-dir {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            font-weight: 500;
        }
        
        /* Standard: bull=green, bear=red */
        .stack-dir.bull { color: #4ade80; }
        .stack-dir.bear { color: #f87171; }
        
        .confluence-stack-chart {
            padding: 2px 4px;
        }
        
        .confluence-stack-item {
            border-bottom: 1px solid #1a1a1a;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .confluence-stack-item:last-child {
            border-bottom: none;
        }
        
        .confluence-stack-item:hover {
            background: #151515;
        }
        
        /* Standard: bull=green, bear=red */
        .confluence-stack-item.bull {
            border-left: 3px solid #4ade80;
        }
        
        .confluence-stack-item.bear {
            border-left: 3px solid #f87171;
        }
        
        .confluence-stack-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: #0d0d0d;
        }
        
        .confluence-stack-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: #888;
        }
        
        .stack-dir {
            font-weight: 600;
        }
        
        .stack-dir.bull { color: #4ade80; }
        .stack-dir.bear { color: #f87171; }
        
        .confluence-stack-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: #666;
        }
        
        .confluence-stack-svg {
            width: 100%;
            height: 50px;
            display: block;
        }
        
        /* Legacy combined view styles (keep for compatibility) */
        .confluence-combined-view {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .confluence-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px;
            background: #151517;
            border-radius: 6px;
        }
        
        .confluence-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            background: #1a1a1c;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .confluence-legend-item:hover {
            background: #252528;
        }
        
        .confluence-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .confluence-legend-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: #ccc;
        }
        
        .confluence-chart-section {
            background: #111;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .confluence-chart-title {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            font-weight: 600;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 6px 10px;
            background: #0a0a0a;
            border-bottom: 1px solid #1a1a1a;
        }
        
        .confluence-combined-svg {
            width: 100%;
            height: 200px;
            display: block;
        }
        
        .confluence-time-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 8px;
            fill: #555;
        }
        
        .confluence-price-scale {
            font-family: 'Roboto Mono', monospace;
            font-size: 8px;
            fill: #555;
        }
        
        .confluence-fib-grid {
            stroke: #2a2a2e;
            stroke-width: 0.5;
        }
        
        .confluence-fib-scale {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            fill: #666;
        }
        
        .confluence-price-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 8px;
            fill: #60a5fa;
        }
        
        /* INVERTED: Bulls are RED, Bears are GREEN */
        .confluence-fib-line.bull { stroke: #f87171; }
        .confluence-fib-line.bear { stroke: #4ade80; }
        
        .confluence-fib-area.bull { fill: rgba(248, 113, 113, 0.15); }
        .confluence-fib-area.bear { fill: rgba(74, 222, 128, 0.15); }
        
        .confluence-fib-dot.bull { fill: #f87171; }
        .confluence-fib-dot.bear { fill: #4ade80; }
        
        /* Track border colors inverted too */
        .confluence-fib-track.bull {
            border-left-color: #f87171;
        }
        
        .confluence-fib-track.bear {
            border-left-color: #4ade80;
        }
        
        /* Badge colors inverted */
        .confluence-fib-track-badge.bull { background: #dc262615; color: #f87171; }
        .confluence-fib-track-badge.bear { background: #16a34a15; color: #4ade80; }
        
        .confluence-fib-track-svg {
            width: 100%;
            height: 100%;
        }
        
        .confluence-fib-ref-line {
            stroke: #333;
            stroke-width: 0.5;
            stroke-dasharray: 2, 3;
        }
        
        .confluence-fib-line {
            fill: none;
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        .confluence-fib-line.bull { stroke: #4ade80; }
        .confluence-fib-line.bear { stroke: #f87171; }
        
        .confluence-fib-area.bull { fill: rgba(74, 222, 128, 0.15); }
        .confluence-fib-area.bear { fill: rgba(248, 113, 113, 0.15); }
        
        .confluence-fib-dot {
            stroke: #1a1a1c;
            stroke-width: 1.5;
        }
        
        .confluence-fib-dot.bull { fill: #4ade80; }
        .confluence-fib-dot.bear { fill: #f87171; }
        
        .confluence-section-title {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .confluence-section-title::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #2a2a2e;
        }
        
        .confluence-no-active {
            text-align: center;
            color: #555;
            padding: 20px;
            font-size: 12px;
        }
        
        /* Fib Chart */
        .fib-chart-container {
            margin-top: 8px;
            background: #151517;
            border-radius: 6px;
            padding: 12px;
        }
        
        .fib-chart-legend {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-bottom: 4px;
            font-size: 10px;
            color: #888;
        }
        
        .fib-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .fib-legend-line {
            width: 16px;
            height: 3px;
            border-radius: 1px;
        }
        
        .fib-legend-line.max {
            background: #60a5fa;
        }
        
        .fib-legend-line.current {
            background: #f97316;
        }
        
        .fib-chart {
            width: 100%;
            height: 120px;
        }
        
        .fib-chart-axis {
            stroke: #333;
            stroke-width: 1;
        }
        
        .fib-chart-grid {
            stroke: #222;
            stroke-width: 1;
            stroke-dasharray: 2, 4;
        }
        
        .fib-chart-line {
            fill: none;
            stroke: #60a5fa;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        .fib-chart-line-current {
            fill: none;
            stroke: #f97316;
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
            opacity: 0.8;
        }
        
        .fib-chart-area {
            fill: url(#fibGradient);
            opacity: 0.3;
        }
        
        .fib-chart-dot {
            fill: #60a5fa;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .fib-chart-dot:hover {
            fill: #fff;
            r: 5;
        }
        
        .fib-chart-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            fill: #666;
        }
        
        .fib-chart-value-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            fill: #888;
        }
        
        .fib-chart-peak {
            fill: #4ade80;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .fib-peak-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            fill: #4ade80;
            font-weight: 600;
        }
        
        .fib-chart-container {
            position: relative;
        }
        
        .fib-cursor-line {
            stroke: #fbbf24;
            stroke-width: 1;
            stroke-dasharray: 3, 3;
            opacity: 0;
            pointer-events: none;
        }
        
        .fib-cursor-dot {
            fill: #fbbf24;
            opacity: 0;
            pointer-events: none;
        }
        
        .fib-cursor-tooltip {
            position: absolute;
            background: #252528;
            border: 1px solid #3a3a3e;
            border-radius: 4px;
            padding: 6px 10px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 10;
            white-space: nowrap;
        }
        
        .fib-cursor-tooltip .fib-val {
            color: #60a5fa;
            font-weight: 600;
        }
        
        .fib-cursor-tooltip .time-val {
            color: #888;
            margin-left: 8px;
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .toast.error { background: #dc2626; }
        .toast.success { background: #16a34a; }
        
        /* Legend */
        .legend {
            display: flex;
            gap: 12px;
            align-items: center;
            font-size: 11px;
            color: #888;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-swatch {
            width: 18px;
            height: 14px;
            border-radius: 3px;
            position: relative;
        }
        
        .legend-swatch.nq-bull { background: #16a34a; }
        .legend-swatch.nq-bear { background: #dc2626; }
        .legend-swatch.es-bull { background: #16a34a; }
        .legend-swatch.es-bear { background: #dc2626; }
        
        /* ES legend swatches get bottom stripe */
        .legend-swatch.es-bull::after,
        .legend-swatch.es-bear::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 0 0 3px 3px;
        }
        
        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 700;
            border: 2px solid rgba(255,255,255,0.8);
            color: #fff;
        }
        
        .legend-dot.win { 
            background: #16a34a;
        }
        .legend-dot.loss { 
            background: #dc2626;
        }
        
        .legend-swatch.entry { 
            background: #fbbf24; 
            width: 3px; 
            height: 16px;
        }
        
        .legend-divider {
            width: 1px;
            height: 16px;
            background: #3a3a3e;
            margin: 0 4px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1c;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #3a3a3e;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a4e;
        }
        
        /* Analysis Modal - Redesigned */
        .analysis-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
        }
        
        .analysis-modal-overlay.visible { display: flex; }
        
        .analysis-modal {
            background: linear-gradient(180deg, #1a1a1c 0%, #0f0f11 100%);
            border-radius: 16px;
            border: 1px solid #333;
            width: calc(100% - 40px);
            max-width: none;
            height: calc(100% - 40px);
            max-height: none;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.7);
            position: relative;
        }
        
        /* Hero Section */
        .analysis-hero {
            padding: 28px 32px 20px;
            background: linear-gradient(135deg, rgba(35, 35, 40, 0.9) 0%, rgba(25, 25, 30, 0.9) 100%);
            border-bottom: 1px solid #333;
            position: relative;
        }
        
        .analysis-hero-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.4);
            color: #ef4444;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 22px;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .analysis-hero-close:hover { background: #ef4444; color: #fff; border-color: #ef4444; }
        
        .analysis-hero-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .analysis-hero-decision {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .analysis-decision-badge {
            font-family: 'Roboto Mono', monospace;
            font-size: 24px;
            font-weight: 800;
            padding: 14px 32px;
            border-radius: 10px;
            letter-spacing: 3px;
        }
        
        .analysis-decision-badge.execute {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.08) 100%);
            color: #4ade80;
            border: 2px solid rgba(74, 222, 128, 0.3);
            box-shadow: 0 0 40px rgba(74, 222, 128, 0.15);
        }
        
        .analysis-decision-badge.caution {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2) 0%, rgba(251, 191, 36, 0.08) 100%);
            color: #fbbf24;
            border: 2px solid rgba(251, 191, 36, 0.3);
            box-shadow: 0 0 40px rgba(251, 191, 36, 0.15);
        }
        
        .analysis-decision-badge.skip, .analysis-decision-badge.blocked {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.08) 100%);
            color: #f87171;
            border: 2px solid rgba(248, 113, 113, 0.3);
            box-shadow: 0 0 40px rgba(248, 113, 113, 0.15);
        }
        
        .analysis-decision-badge.pending {
            background: linear-gradient(135deg, rgba(148, 163, 184, 0.2) 0%, rgba(148, 163, 184, 0.08) 100%);
            color: #94a3b8;
            border: 2px solid rgba(148, 163, 184, 0.3);
            box-shadow: 0 0 40px rgba(148, 163, 184, 0.15);
        }
        
        .analysis-hero-id {
            font-family: 'Roboto Mono', monospace;
            font-size: 13px;
            color: #94a3b8;
        }
        
        .analysis-hero-meta {
            font-size: 12px;
            color: #64748b;
            margin-top: 2px;
        }
        
        .analysis-hero-score {
            text-align: right;
        }
        
        .analysis-score-big {
            font-family: 'Roboto Mono', monospace;
            font-size: 36px;
            font-weight: 700;
            color: #fff;
        }
        
        .analysis-score-label {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Category Tabs */
        .analysis-tabs {
            display: flex;
            background: rgba(15, 15, 18, 0.6);
            border-bottom: 1px solid #333;
            padding: 0 24px;
        }
        
        .analysis-tab {
            padding: 16px 24px;
            font-size: 12px;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -1px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .analysis-tab:hover { color: #94a3b8; background: rgba(255,255,255,0.02); }
        
        .analysis-tab.active {
            color: #fff;
            border-bottom-color: #60a5fa;
            background: rgba(96, 165, 250, 0.05);
        }
        
        .analysis-tab-count {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 10px;
        }
        
        .analysis-tab-count.all-pass { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-tab-count.has-warn { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-tab-count.has-fail { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        .analysis-tab-count.has-error { background: rgba(248, 113, 113, 0.4); color: #fff; }
        
        /* Content Area */
        .analysis-content {
            flex: 1;
            overflow-y: auto;
            padding: 28px;
        }
        
        .analysis-panel { display: none; }
        .analysis-panel.active { display: block; }
        
        /* Dimension Cards */
        .analysis-cards {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        
        .analysis-card {
            background: rgba(30, 30, 35, 0.5);
            border: 1px solid #2a2a30;
            border-radius: 12px;
            padding: 20px 24px;
            transition: all 0.2s;
        }
        
        .analysis-card:hover {
            border-color: #3a3a45;
            background: rgba(40, 40, 48, 0.5);
        }
        
        .analysis-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        
        .analysis-card-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .analysis-card-code {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.12);
            padding: 4px 10px;
            border-radius: 5px;
        }
        
        .analysis-card-name {
            font-size: 14px;
            font-weight: 600;
            color: #e2e8f0;
        }
        
        .analysis-card-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            font-weight: 700;
            padding: 6px 16px;
            border-radius: 5px;
        }
        
        .analysis-card-value.pass { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-card-value.warn { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-card-value.fail { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        .analysis-card-value.error { background: rgba(248, 113, 113, 0.3); color: #f87171; font-size: 9px; }
        
        .analysis-card.error-card {
            border: 1px solid rgba(248, 113, 113, 0.5);
            background: rgba(248, 113, 113, 0.05);
        }
        
        /* Narrative bullets in dimension cards */
        .analysis-card-narrative {
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            margin: 12px 0;
        }
        
        .narrative-line {
            font-size: 12px;
            line-height: 1.6;
            color: #b0b0b0;
            padding: 4px 0;
            padding-left: 16px;
            position: relative;
        }
        
        .narrative-line::before {
            content: '•';
            position: absolute;
            left: 0;
            color: #666;
        }
        
        .narrative-line:first-child {
            color: #e0e0e0;
            font-weight: 500;
        }
        
        /* Summary panel */
        .analysis-summary {
            padding: 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .summary-line {
            font-size: 13px;
            line-height: 1.8;
            color: #ccc;
            padding: 6px 0;
        }
        
        .summary-line:first-child {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }
        
        /* Analysis sections in Summary tab */
        .analysis-section {
            background: rgba(30, 30, 34, 0.6);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
        }
        
        .analysis-section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            margin-bottom: 12px;
            font-weight: 600;
        }
        
        /* Levels grid */
        .levels-grid {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .level-item {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }
        
        .level-item.entry {
            border-left: 3px solid #60a5fa;
        }
        
        .level-item.stop {
            border-left: 3px solid #f87171;
        }
        
        .level-item.target {
            border-left: 3px solid #4ade80;
        }
        
        .level-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #888;
            display: block;
            margin-bottom: 4px;
        }
        
        .level-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }
        
        /* Fib levels */
        .fib-levels {
            display: flex;
            gap: 8px;
        }
        
        .fib-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        .fib-item span:first-child {
            font-size: 9px;
            color: #666;
            margin-bottom: 2px;
        }
        
        .fib-item span:last-child {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #aaa;
        }
        
        /* Zone display */
        .zone-display {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }
        
        .zone-high, .zone-low {
            font-family: 'Roboto Mono', monospace;
            font-size: 13px;
            font-weight: 600;
        }
        
        .zone-high {
            color: #4ade80;
        }
        
        .zone-low {
            color: #f87171;
        }
        
        .zone-bar {
            flex: 1;
            height: 24px;
            background: linear-gradient(180deg, rgba(74, 222, 128, 0.3) 0%, rgba(248, 113, 113, 0.3) 100%);
            border-radius: 4px;
            border-top: 2px solid #4ade80;
            border-bottom: 2px solid #f87171;
        }
        
        /* Pattern points */
        .pattern-points {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }
        
        .pattern-point {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 12px;
            background: rgba(40, 40, 44, 0.6);
            border-radius: 6px;
            min-width: 70px;
        }
        
        .pattern-label {
            font-size: 10px;
            font-weight: 700;
            color: #60a5fa;
            margin-bottom: 4px;
        }
        
        .pattern-price {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            color: #fff;
            font-weight: 600;
        }
        
        .pattern-time {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }
        
        .pattern-arrow {
            color: #444;
            font-size: 14px;
        }
        
        /* ===== OVERVIEW PANEL STYLES ===== */
        .overview-section {
            background: rgba(20, 20, 24, 0.6);
            border: 1px solid #2a2a2e;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
        }
        
        .overview-section-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        /* Pattern Flow */
        .pattern-flow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .pattern-point {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 14px;
            background: rgba(30, 30, 34, 0.8);
            border-radius: 6px;
            border: 1px solid #333;
            min-width: 65px;
        }
        
        .pattern-point.start { border-top: 2px solid #60a5fa; }
        .pattern-point.low { border-top: 2px solid #f87171; }
        .pattern-point.breaker { border-top: 2px solid #4ade80; }
        .pattern-point.sweep { border-top: 2px solid #fbbf24; }
        .pattern-point.confirm { border-top: 2px solid #c084fc; }
        
        .pattern-point-label {
            font-size: 10px;
            font-weight: 700;
            color: #888;
            margin-bottom: 4px;
        }
        
        .pattern-point-price {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            color: #fff;
            font-weight: 600;
        }
        
        .pattern-point-time {
            font-size: 9px;
            color: #666;
            margin-top: 3px;
        }
        
        .pattern-connector {
            color: #444;
            font-size: 16px;
            font-weight: 300;
        }
        
        /* Price Ladder */
        .price-ladder {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .price-ladder-row {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            background: rgba(30, 30, 34, 0.5);
            border-radius: 4px;
        }
        
        .price-ladder-row.target {
            background: rgba(74, 222, 128, 0.1);
            border-left: 3px solid #4ade80;
        }
        
        .price-ladder-row.entry {
            background: rgba(96, 165, 250, 0.1);
            border-left: 3px solid #60a5fa;
        }
        
        .price-ladder-row.stop {
            background: rgba(248, 113, 113, 0.1);
            border-left: 3px solid #f87171;
        }
        
        .price-ladder-row.fib {
            opacity: 0.6;
        }
        
        .ladder-label {
            font-size: 11px;
            color: #888;
            width: 80px;
            flex-shrink: 0;
        }
        
        .price-ladder-row.target .ladder-label { color: #4ade80; font-weight: 600; }
        .price-ladder-row.entry .ladder-label { color: #60a5fa; font-weight: 600; }
        .price-ladder-row.stop .ladder-label { color: #f87171; font-weight: 600; }
        
        .ladder-line {
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, #333 0%, transparent 100%);
            margin: 0 12px;
        }
        
        .ladder-price {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            color: #ccc;
            min-width: 70px;
            text-align: right;
        }
        
        .price-ladder-zone {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            margin: 4px 0;
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.15) 0%, rgba(248, 113, 113, 0.15) 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .zone-label {
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 1px;
            color: #888;
        }
        
        .zone-range {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #aaa;
        }
        
        /* Trade Decision Tree */
        .trade-decision-tree {
            padding: 8px;
        }
        
        .decision-tree {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
        }
        
        .decision-tree-empty {
            text-align: center;
            padding: 30px;
            color: #555;
            font-size: 12px;
        }
        
        .tree-entry-row {
            display: flex;
            justify-content: center;
            width: 100%;
        }
        
        .tree-node {
            background: rgba(30, 30, 34, 0.8);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px 16px;
            text-align: center;
            min-width: 85px;
        }
        
        .node-label {
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 4px;
            text-transform: uppercase;
        }
        
        .node-price {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }
        
        .node-meta {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }
        
        .node-fib {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #888;
            margin-top: 4px;
        }
        
        .node-rr {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            margin-top: 6px;
            padding: 3px 8px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .node-rr.stop {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }
        
        .node-rr.target {
            background: rgba(74, 222, 128, 0.15);
            color: #4ade80;
        }
        
        /* Entry Node */
        .entry-node {
            border-color: #60a5fa;
            border-width: 2px;
            background: linear-gradient(180deg, rgba(96, 165, 250, 0.15) 0%, rgba(96, 165, 250, 0.05) 100%);
        }
        
        .entry-node .node-label {
            color: #60a5fa;
        }
        
        /* SVG Connector */
        .tree-connector-svg {
            width: 100%;
            max-width: 400px;
        }
        
        /* Branches */
        .tree-branches {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
            gap: 16px;
        }
        
        /* Stop Node */
        .stop-node {
            border-color: #f87171;
            background: linear-gradient(180deg, rgba(248, 113, 113, 0.15) 0%, rgba(248, 113, 113, 0.05) 100%);
            flex-shrink: 0;
        }
        
        .stop-node .node-label {
            color: #f87171;
        }
        
        .stop-node .node-fib {
            color: #f87171;
            opacity: 0.7;
        }
        
        /* Targets Container */
        .targets-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: flex-end;
            flex: 1;
        }
        
        .target-arrow {
            color: #4ade80;
            font-size: 14px;
            opacity: 0.4;
        }
        
        /* Target Nodes */
        .target-node {
            border-color: #333;
            min-width: 75px;
            padding: 8px 10px;
        }
        
        .target-node .node-label {
            color: #666;
            font-size: 8px;
        }
        
        .target-node .node-price {
            font-size: 12px;
        }
        
        .target-node .node-fib {
            font-size: 9px;
            color: #666;
        }
        
        .target-node.f1 { opacity: 0.5; }
        .target-node.f2 { opacity: 0.7; }
        .target-node.f4 { opacity: 0.6; }
        
        .target-node.primary {
            border-color: #4ade80;
            border-width: 2px;
            background: linear-gradient(180deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
            opacity: 1;
        }
        
        .target-node.primary .node-label {
            color: #4ade80;
        }
        
        .target-node.primary .node-fib {
            color: #4ade80;
            opacity: 0.8;
        }
        
        /* Summary Row */
        .tree-summary {
            display: flex;
            justify-content: center;
            gap: 32px;
            margin-top: 16px;
            padding-top: 14px;
            border-top: 1px solid #2a2a2e;
            width: 100%;
        }
        
        .summary-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        
        .summary-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .summary-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 13px;
            font-weight: 600;
        }
        
        .summary-item.risk .summary-value {
            color: #f87171;
        }
        
        .summary-item.reward .summary-value {
            color: #4ade80;
        }
        
        .summary-item.rr .summary-value {
            color: #60a5fa;
        }
        
        /* Formation Metrics */
        .formation-metrics {
            display: flex;
            gap: 12px;
        }
        
        .formation-metric {
            flex: 1;
            background: rgba(30, 30, 34, 0.6);
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }
        
        .formation-metric-label {
            font-size: 10px;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .formation-metric-bar {
            height: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 6px;
        }
        
        .formation-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .formation-bar-fill.sweep {
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
        }
        
        .formation-metric-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }
        
        .formation-metric.smt {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .formation-smt-status {
            font-size: 11px;
            color: #666;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        .formation-smt-status.active {
            color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }
        
        /* Confluence List */
        .confluence-count {
            font-size: 10px;
            color: #4ade80;
            font-weight: 400;
        }
        
        .confluence-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .confluence-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: rgba(30, 30, 34, 0.6);
            border-radius: 4px;
            border-left: 3px solid #4ade80;
        }
        
        .confluence-item.bear {
            border-left-color: #f87171;
        }
        
        .confluence-id {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #ccc;
            flex: 1;
        }
        
        .confluence-fib {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #60a5fa;
            margin-right: 16px;
        }
        
        .confluence-energy {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #fbbf24;
            min-width: 35px;
            text-align: right;
        }
        
        .confluence-empty {
            text-align: center;
            padding: 16px;
            color: #555;
            font-size: 12px;
        }
        
        /* Verdict */
        .overview-section.verdict {
            background: rgba(30, 30, 34, 0.8);
            border-color: #333;
        }
        
        .verdict-lines {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .verdict-line {
            font-size: 12px;
            color: #aaa;
            padding-left: 12px;
            position: relative;
        }
        
        .verdict-line::before {
            content: '•';
            position: absolute;
            left: 0;
            color: #555;
        }
        
        .verdict-line.primary {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            padding-left: 0;
        }
        
        .verdict-line.primary::before {
            display: none;
        }
        
        /* Visual breakdown section */
        .analysis-card-visual {
            margin-bottom: 16px;
        }
        
        /* Bias row for direction dimensions */
        .analysis-bias-row {
            display: flex;
            gap: 8px;
        }
        
        .analysis-bias-item {
            flex: 1;
            background: rgba(0,0,0,0.25);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }
        
        .analysis-bias-tf {
            font-size: 10px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .analysis-bias-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            font-weight: 600;
        }
        
        .analysis-bias-value.bullish { color: #4ade80; }
        .analysis-bias-value.bearish { color: #f87171; }
        .analysis-bias-value.neutral { color: #fbbf24; }
        
        /* TF count bars for support/resistance */
        .analysis-tf-bars {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            height: 60px;
            padding: 0 10px;
        }
        
        .analysis-tf-bar {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .analysis-tf-bar-fill {
            width: 100%;
            border-radius: 4px 4px 0 0;
            min-height: 4px;
            transition: height 0.3s;
        }
        
        .analysis-tf-bar-fill.support { background: linear-gradient(180deg, #4ade80 0%, #22c55e 100%); }
        .analysis-tf-bar-fill.resistance { background: linear-gradient(180deg, #f87171 0%, #ef4444 100%); }
        .analysis-tf-bar-fill.empty { background: rgba(255,255,255,0.08); height: 4px !important; }
        
        .analysis-tf-bar-label {
            font-size: 10px;
            color: #64748b;
            font-weight: 600;
        }
        
        .analysis-tf-bar-count {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #ccc;
            font-weight: 600;
        }
        
        /* Metric row for energy/gate */
        .analysis-metric-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .analysis-metric {
            background: rgba(0,0,0,0.25);
            border-radius: 6px;
            padding: 10px 14px;
            flex: 1;
            min-width: 70px;
        }
        
        .analysis-metric-label {
            font-size: 9px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .analysis-metric-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 13px;
            font-weight: 600;
            color: #e2e8f0;
        }
        
        .analysis-metric-value.pass { color: #4ade80; }
        .analysis-metric-value.warn { color: #fbbf24; }
        .analysis-metric-value.fail { color: #f87171; }
        
        /* Calculation explanation */
        .analysis-card-calc {
            margin-top: 14px;
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.06);
        }
        
        .analysis-calc-title {
            font-size: 9px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }
        
        .analysis-calc-text {
            font-size: 12px;
            color: #94a3b8;
            line-height: 1.5;
        }
        
        /* Failed breakers visual */
        .analysis-failed-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .analysis-failed-item {
            background: rgba(0,0,0,0.25);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            border: 1px solid transparent;
        }
        
        .analysis-failed-item.failed {
            border-color: rgba(74, 222, 128, 0.3);
            background: rgba(74, 222, 128, 0.1);
        }
        
        .analysis-failed-item-label {
            font-size: 9px;
            color: #64748b;
            margin-bottom: 4px;
        }
        
        .analysis-failed-item-status {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
        }
        
        .analysis-failed-item.failed .analysis-failed-item-status { color: #4ade80; }
        .analysis-failed-item:not(.failed) .analysis-failed-item-status { color: #64748b; }
        
        /* Premium/Discount gauge */
        .analysis-gauge {
            position: relative;
            height: 20px;
            background: linear-gradient(90deg, #4ade80 0%, #fbbf24 50%, #f87171 100%);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .analysis-gauge-marker {
            position: absolute;
            top: 2px;
            bottom: 2px;
            width: 4px;
            background: #fff;
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(0,0,0,0.5);
        }
        
        .analysis-gauge-labels {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #64748b;
            margin-top: 6px;
        }
        
        /* Progress bar for burn/ratios */
        .analysis-progress {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .analysis-progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
        
        .analysis-progress-fill.good { background: linear-gradient(90deg, #4ade80, #22c55e); }
        .analysis-progress-fill.warn { background: linear-gradient(90deg, #fbbf24, #f59e0b); }
        .analysis-progress-fill.bad { background: linear-gradient(90deg, #f87171, #ef4444); }
        
        
        
        .analysis-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #333;
            background: linear-gradient(135deg, #1e1e20 0%, #252528 100%);
        }
        
        .analysis-modal-title {
            font-size: 16px;
            font-weight: 600;
            color: #60a5fa;
        }
        
        .analysis-modal-subtitle {
            font-size: 12px;
            color: #888;
            margin-top: 2px;
        }
        
        .analysis-modal-close {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.4);
            color: #ef4444;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            padding: 4px 10px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .analysis-modal-close:hover {
            background: #ef4444;
            color: #fff;
            border-color: #ef4444;
        }
        
        .analysis-modal-body {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .analysis-categories {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr auto;
            gap: 16px;
            flex: 1;
            min-height: 0;
        }
        
        .analysis-category.gate {
            grid-column: 1 / -1;
            min-height: auto;
            max-height: fit-content;
        }
        
        .analysis-category.gate .analysis-category-body {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .analysis-category.gate .analysis-dimension {
            margin-bottom: 0;
        }
        
        .analysis-category.gate .analysis-dimension .analysis-dimension-detail {
            display: none;
        }
        
        .analysis-category.gate .analysis-dimension.expanded .analysis-dimension-detail {
            display: block;
        }
        
        .analysis-category {
            background: rgba(30, 30, 32, 0.6);
            border-radius: 8px;
            border: 1px solid #333;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .analysis-category-header {
            padding: 10px 14px;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .analysis-category-toggle {
            font-size: 10px;
            color: #666;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 3px;
            background: rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        
        .analysis-category-toggle:hover {
            background: rgba(0,0,0,0.4);
            color: #aaa;
        }
        
        .analysis-category.gate .analysis-category-header {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.15) 0%, rgba(251, 191, 36, 0.05) 100%);
            color: #fbbf24;
        }
        
        .analysis-category.direction .analysis-category-header {
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.15) 0%, rgba(96, 165, 250, 0.05) 100%);
            color: #60a5fa;
        }
        
        .analysis-category.support .analysis-category-header {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
            color: #4ade80;
        }
        
        .analysis-category.resistance .analysis-category-header {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.15) 0%, rgba(248, 113, 113, 0.05) 100%);
            color: #f87171;
        }
        
        .analysis-category.energy .analysis-category-header {
            background: linear-gradient(135deg, rgba(192, 132, 252, 0.15) 0%, rgba(192, 132, 252, 0.05) 100%);
            color: #c084fc;
        }
        
        .analysis-category-body {
            padding: 10px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }
        
        .analysis-dimension {
            border-radius: 4px;
            margin-bottom: 6px;
            background: rgba(40, 40, 44, 0.4);
            overflow: hidden;
        }
        
        .analysis-dimension:last-child {
            margin-bottom: 0;
        }
        
        .analysis-dimension-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .analysis-dimension-header:hover {
            background: rgba(60, 60, 64, 0.4);
        }
        
        .analysis-dimension-left {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .analysis-dimension-name {
            font-size: 12px;
            color: #ccc;
        }
        
        .analysis-dimension-code {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #666;
            background: rgba(0,0,0,0.2);
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .analysis-dimension-expand {
            color: #666;
            font-size: 10px;
            transition: transform 0.2s;
        }
        
        .analysis-dimension.expanded .analysis-dimension-expand {
            transform: rotate(180deg);
        }
        
        .analysis-dimension-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            padding: 3px 10px;
            border-radius: 3px;
            min-width: 80px;
            text-align: center;
        }
        
        .analysis-dimension-value.pass,
        .analysis-dimension-value.aligned,
        .analysis-dimension-value.converged,
        .analysis-dimension-value.strong,
        .analysis-dimension-value.confirms,
        .analysis-dimension-value.clear,
        .analysis-dimension-value.high,
        .analysis-dimension-value.powered,
        .analysis-dimension-value.discount,
        .analysis-dimension-value.available {
            background: rgba(74, 222, 128, 0.15);
            color: #4ade80;
        }
        
        .analysis-dimension-value.warn,
        .analysis-dimension-value.moderate,
        .analysis-dimension-value.partial,
        .analysis-dimension-value.neutral,
        .analysis-dimension-value.friction,
        .analysis-dimension-value.equilibrium,
        .analysis-dimension-value.limited {
            background: rgba(251, 191, 36, 0.15);
            color: #fbbf24;
        }
        
        .analysis-dimension-value.fail,
        .analysis-dimension-value.opposed,
        .analysis-dimension-value.diverged,
        .analysis-dimension-value.weak,
        .analysis-dimension-value.none,
        .analysis-dimension-value.conflicts,
        .analysis-dimension-value.blocked,
        .analysis-dimension-value.low,
        .analysis-dimension-value.exhausted,
        .analysis-dimension-value.premium {
            background: rgba(248, 113, 113, 0.15);
            color: #f87171;
        }
        
        .analysis-dimension-detail {
            display: none;
            padding: 12px 14px;
            background: rgba(20, 20, 22, 0.6);
            border-top: 1px solid rgba(255,255,255,0.05);
            font-size: 11px;
            line-height: 1.6;
        }
        
        .analysis-dimension.expanded .analysis-dimension-detail {
            display: block;
        }
        
        .analysis-detail-question {
            color: #888;
            font-style: italic;
            margin-bottom: 10px;
        }
        
        .analysis-detail-reason {
            font-size: 12px;
            color: #e2e8f0;
            padding: 10px 12px;
            margin-bottom: 10px;
            background: rgba(96, 165, 250, 0.1);
            border-left: 3px solid #60a5fa;
            border-radius: 0 4px 4px 0;
        }
        
        .analysis-detail-calc {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 10px 12px;
            margin-bottom: 10px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
        }
        
        .analysis-detail-calc-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .analysis-detail-calc-row:last-child {
            border-bottom: none;
            padding-top: 6px;
            margin-top: 4px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-weight: 600;
        }
        
        .analysis-detail-calc-label {
            color: #888;
        }
        
        .analysis-detail-calc-value {
            color: #ccc;
        }
        
        .analysis-detail-calc-value.pass { color: #4ade80; background: rgba(74, 222, 128, 0.15); padding: 1px 6px; border-radius: 3px; }
        .analysis-detail-calc-value.fail { color: #f87171; background: rgba(248, 113, 113, 0.15); padding: 1px 6px; border-radius: 3px; }
        .analysis-detail-calc-value.warn { color: #fbbf24; background: rgba(251, 191, 36, 0.15); padding: 1px 6px; border-radius: 3px; }
        
        .analysis-detail-logic {
            margin-top: 10px;
        }
        
        .analysis-detail-logic-title {
            color: #666;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        .analysis-detail-logic-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .analysis-detail-logic-table th,
        .analysis-detail-logic-table td {
            padding: 4px 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 10px;
        }
        
        .analysis-detail-logic-table th {
            color: #666;
            font-weight: 500;
        }
        
        .analysis-detail-logic-table td {
            color: #aaa;
        }
        
        .analysis-detail-logic-table tr.active {
            background: rgba(96, 165, 250, 0.1);
        }
        
        .analysis-detail-logic-table tr.active td {
            color: #60a5fa;
        }
        
        /* Zone visualization */
        .analysis-zones {
            margin-top: 12px;
        }
        
        .analysis-zones-title {
            color: #666;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .analysis-zones-entry {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
            padding: 2px 8px;
            border-radius: 3px;
        }
        
        .analysis-zone-stack {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .analysis-zone {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: rgba(30, 30, 34, 0.6);
            border-radius: 4px;
            border-left: 3px solid #444;
            font-size: 10px;
        }
        
        .analysis-zone.tf-4h { border-left-color: #c084fc; }
        .analysis-zone.tf-1h { border-left-color: #60a5fa; }
        .analysis-zone.tf-15m { border-left-color: #4ade80; }
        .analysis-zone.tf-5m { border-left-color: #fbbf24; }
        .analysis-zone.tf-1m { border-left-color: #f87171; }
        
        .analysis-zone-tf {
            font-family: 'Roboto Mono', monospace;
            font-weight: 600;
            min-width: 32px;
            padding: 2px 6px;
            border-radius: 3px;
            text-align: center;
            font-size: 9px;
        }
        
        .analysis-zone.tf-4h .analysis-zone-tf { background: rgba(192, 132, 252, 0.2); color: #c084fc; }
        .analysis-zone.tf-1h .analysis-zone-tf { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .analysis-zone.tf-15m .analysis-zone-tf { background: rgba(74, 222, 128, 0.2); color: #4ade80; }
        .analysis-zone.tf-5m .analysis-zone-tf { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
        .analysis-zone.tf-1m .analysis-zone-tf { background: rgba(248, 113, 113, 0.2); color: #f87171; }
        
        .analysis-zone-type {
            color: #888;
            min-width: 50px;
        }
        
        .analysis-zone-type.bull { color: #4ade80; }
        .analysis-zone-type.bear { color: #f87171; }
        
        .analysis-zone-range {
            font-family: 'Roboto Mono', monospace;
            color: #ccc;
            min-width: 120px;
        }
        
        .analysis-zone-fib {
            font-family: 'Roboto Mono', monospace;
            padding: 2px 6px;
            border-radius: 3px;
            min-width: 55px;
            text-align: center;
        }
        
        .analysis-zone-fib.fresh { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-zone-fib.tested { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-zone-fib.extended { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        
        .analysis-zone-dist {
            font-family: 'Roboto Mono', monospace;
            color: #888;
            min-width: 60px;
            text-align: right;
        }
        
        .analysis-zone-status {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            min-width: 50px;
            text-align: center;
        }
        
        .analysis-zone-status.active { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-zone-status.touched { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-zone-status.broken { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        
        /* ===== ENHANCED VISUALS ===== */
        
        /* Price Ladder - Unified Support/Resistance View */
        .price-ladder {
            position: relative;
            margin: 12px 0;
            padding: 16px;
            background: linear-gradient(180deg, rgba(15,15,18,0.95) 0%, rgba(20,20,25,0.9) 100%);
            border-radius: 10px;
            border: 1px solid #333;
            min-height: 280px;
        }
        
        .price-ladder-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .price-ladder-title {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .price-ladder-legend {
            display: flex;
            gap: 12px;
            font-size: 9px;
            color: #888;
        }
        
        .price-ladder-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .price-ladder-legend-swatch {
            width: 12px;
            height: 8px;
            border-radius: 2px;
        }
        
        .price-ladder-legend-swatch.breaker-support { background: rgba(74, 222, 128, 0.4); border: 1px solid #4ade80; }
        .price-ladder-legend-swatch.fvg-support { background: rgba(74, 222, 128, 0.2); border: 1px dashed rgba(74, 222, 128, 0.5); }
        .price-ladder-legend-swatch.breaker-resist { background: rgba(248, 113, 113, 0.4); border: 1px solid #f87171; }
        .price-ladder-legend-swatch.fvg-resist { background: rgba(248, 113, 113, 0.2); border: 1px dashed rgba(248, 113, 113, 0.5); }
        
        .price-ladder-body {
            display: flex;
            height: 240px;
        }
        
        .price-ladder-axis {
            width: 60px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            border-right: 1px solid #333;
            padding-right: 8px;
            margin-right: 12px;
        }
        
        .price-ladder-axis-tick {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            color: #555;
            text-align: right;
        }
        
        .price-ladder-axis-tick.entry { color: #60a5fa; font-weight: 600; }
        .price-ladder-axis-tick.target { color: #4ade80; font-weight: 600; }
        .price-ladder-axis-tick.stop { color: #f87171; font-weight: 600; }
        
        .price-ladder-chart {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        /* Price level lines */
        .price-ladder-level {
            position: absolute;
            left: 0;
            right: 80px;
            height: 2px;
            display: flex;
            align-items: center;
        }
        
        .price-ladder-level-line {
            flex: 1;
            height: 100%;
        }
        
        .price-ladder-level.entry .price-ladder-level-line {
            background: #60a5fa;
            box-shadow: 0 0 10px rgba(96, 165, 250, 0.6);
        }
        
        .price-ladder-level.target .price-ladder-level-line {
            background: repeating-linear-gradient(90deg, #4ade80 0, #4ade80 6px, transparent 6px, transparent 10px);
        }
        
        .price-ladder-level.stop .price-ladder-level-line {
            background: #f87171;
            box-shadow: 0 0 8px rgba(248, 113, 113, 0.5);
        }
        
        .price-ladder-level-label {
            position: absolute;
            right: 0;
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            padding: 3px 8px;
            border-radius: 3px;
            white-space: nowrap;
        }
        
        .price-ladder-level.entry .price-ladder-level-label {
            background: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
            border: 1px solid rgba(96, 165, 250, 0.4);
        }
        
        .price-ladder-level.target .price-ladder-level-label {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .price-ladder-level.stop .price-ladder-level-label {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        /* Zone blocks */
        .price-ladder-zone {
            position: absolute;
            left: 0;
            right: 85px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            transition: all 0.15s;
            cursor: default;
        }
        
        .price-ladder-zone:hover {
            transform: translateX(4px);
            z-index: 10;
        }
        
        .price-ladder-zone.support-breaker {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.35) 0%, rgba(74, 222, 128, 0.15) 100%);
            border: 1px solid rgba(74, 222, 128, 0.6);
            border-left: 3px solid #4ade80;
            color: #4ade80;
        }
        
        .price-ladder-zone.support-fvg {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.08) 100%);
            border: 1px dashed rgba(74, 222, 128, 0.5);
            color: rgba(74, 222, 128, 0.9);
        }
        
        .price-ladder-zone.resist-breaker {
            background: linear-gradient(90deg, rgba(248, 113, 113, 0.35) 0%, rgba(248, 113, 113, 0.15) 100%);
            border: 1px solid rgba(248, 113, 113, 0.6);
            border-left: 3px solid #f87171;
            color: #f87171;
        }
        
        .price-ladder-zone.resist-fvg {
            background: linear-gradient(90deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.08) 100%);
            border: 1px dashed rgba(248, 113, 113, 0.5);
            color: rgba(248, 113, 113, 0.9);
        }
        
        /* TF badge colors */
        .price-ladder-zone .zone-tf {
            font-weight: 600;
            padding: 1px 4px;
            border-radius: 2px;
            margin-right: 6px;
            font-size: 8px;
        }
        
        .price-ladder-zone.tf-4h .zone-tf { background: rgba(192, 132, 252, 0.3); color: #c084fc; }
        .price-ladder-zone.tf-1h .zone-tf { background: rgba(96, 165, 250, 0.3); color: #60a5fa; }
        .price-ladder-zone.tf-15m .zone-tf { background: rgba(74, 222, 128, 0.3); color: #4ade80; }
        .price-ladder-zone.tf-5m .zone-tf { background: rgba(251, 191, 36, 0.3); color: #fbbf24; }
        
        .price-ladder-zone .zone-info {
            margin-left: auto;
            opacity: 0.7;
            font-size: 8px;
        }
        
        /* Current price arrow */
        .price-ladder-current {
            position: absolute;
            left: -6px;
            width: 0;
            height: 0;
            border-top: 7px solid transparent;
            border-bottom: 7px solid transparent;
            border-left: 10px solid #60a5fa;
            filter: drop-shadow(0 0 4px rgba(96, 165, 250, 0.8));
            z-index: 20;
        }
        
        /* R:R sidebar */
        .price-ladder-rr {
            position: absolute;
            right: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        
        .price-ladder-rr-segment {
            width: 14px;
            border-radius: 2px;
        }
        
        .price-ladder-rr-segment.reward { background: linear-gradient(180deg, #4ade80, rgba(74, 222, 128, 0.3)); }
        .price-ladder-rr-segment.risk { background: linear-gradient(0deg, #f87171, rgba(248, 113, 113, 0.3)); }
        
        .price-ladder-rr-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            color: #4ade80;
            margin: 4px 0;
        }
        
        /* Direction Flow Visual */
        .direction-flow {
            margin: 8px 0;
        }
        
        .direction-flow-row {
            display: flex;
            align-items: center;
            padding: 8px 0;
        }
        
        .direction-flow-symbol {
            width: 36px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            color: #888;
        }
        
        .direction-flow-tfs {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .direction-flow-tf {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .direction-flow-tf-label {
            font-size: 9px;
            color: #666;
            margin-bottom: 4px;
        }
        
        .direction-flow-tf-box {
            width: 44px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            position: relative;
        }
        
        .direction-flow-tf-box.bullish {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.25) 0%, rgba(74, 222, 128, 0.1) 100%);
            border: 1px solid rgba(74, 222, 128, 0.5);
            color: #4ade80;
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.2);
        }
        
        .direction-flow-tf-box.bearish {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.25) 0%, rgba(248, 113, 113, 0.1) 100%);
            border: 1px solid rgba(248, 113, 113, 0.5);
            color: #f87171;
            box-shadow: 0 0 12px rgba(248, 113, 113, 0.2);
        }
        
        .direction-flow-tf-box.neutral {
            background: rgba(100, 100, 100, 0.15);
            border: 1px solid rgba(150, 150, 150, 0.3);
            color: #888;
        }
        
        .direction-flow-arrow {
            width: 24px;
            height: 2px;
            margin: 0 -4px;
            position: relative;
            top: 4px;
        }
        
        .direction-flow-arrow::after {
            content: '';
            position: absolute;
            right: 0;
            top: -3px;
            border: 4px solid transparent;
        }
        
        .direction-flow-arrow.aligned {
            background: #4ade80;
        }
        
        .direction-flow-arrow.aligned::after {
            border-left-color: #4ade80;
        }
        
        .direction-flow-arrow.mixed {
            background: linear-gradient(90deg, #fbbf24, #f87171);
        }
        
        .direction-flow-arrow.mixed::after {
            border-left-color: #f87171;
        }
        
        .direction-flow-result {
            width: 85px;
            text-align: center;
            padding: 6px 10px;
            border-radius: 6px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
        }
        
        .direction-flow-result.aligned {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.08) 100%);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .direction-flow-result.partial {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2) 0%, rgba(251, 191, 36, 0.08) 100%);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.4);
        }
        
        .direction-flow-result.opposed, .direction-flow-result.diverged {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.08) 100%);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        /* Inversion Grid */
        .inversion-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin: 8px 0;
        }
        
        .inversion-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
            transition: all 0.2s;
        }
        
        .inversion-cell.failed {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
            border-color: rgba(74, 222, 128, 0.4);
        }
        
        .inversion-cell.active {
            background: rgba(60, 60, 60, 0.2);
            border-color: #444;
        }
        
        .inversion-cell-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            color: #888;
            margin-bottom: 6px;
        }
        
        .inversion-cell-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        .inversion-cell.failed .inversion-cell-icon { color: #4ade80; }
        .inversion-cell.active .inversion-cell-icon { color: #666; }
        
        .inversion-cell-status {
            font-size: 8px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .inversion-cell.failed .inversion-cell-status { color: #4ade80; }
        .inversion-cell.active .inversion-cell-status { color: #666; }
        
        /* ADR Burn Gauges */
        .burn-gauges {
            display: flex;
            gap: 24px;
            justify-content: center;
            padding: 8px 0;
        }
        
        .burn-gauge {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .burn-gauge-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            color: #888;
            margin-bottom: 8px;
        }
        
        .burn-gauge-ring {
            position: relative;
            width: 80px;
            height: 80px;
        }
        
        .burn-gauge-ring svg {
            transform: rotate(-90deg);
        }
        
        .burn-gauge-bg {
            fill: none;
            stroke: #333;
            stroke-width: 6;
        }
        
        .burn-gauge-fill {
            fill: none;
            stroke-width: 6;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }
        
        .burn-gauge-fill.available { stroke: #4ade80; }
        .burn-gauge-fill.limited { stroke: #fbbf24; }
        .burn-gauge-fill.exhausted { stroke: #f87171; }
        
        .burn-gauge-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            font-weight: 700;
        }
        
        .burn-gauge-value.available { color: #4ade80; }
        .burn-gauge-value.limited { color: #fbbf24; }
        .burn-gauge-value.exhausted { color: #f87171; }
        
        .burn-gauge-status {
            margin-top: 6px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .burn-gauge-status.available { color: #4ade80; }
        .burn-gauge-status.limited { color: #fbbf24; }
        .burn-gauge-status.exhausted { color: #f87171; }
        
        /* Formation Visual - FVG + Sweep */
        .formation-visual {
            position: relative;
            margin: 8px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
            height: 120px;
        }
        
        .formation-visual-bar {
            position: absolute;
            left: 30%;
            width: 40%;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
        }
        
        .formation-visual-bar.breaker {
            background: linear-gradient(90deg, rgba(96, 165, 250, 0.3) 0%, rgba(96, 165, 250, 0.15) 100%);
            border: 1px solid rgba(96, 165, 250, 0.5);
            color: #60a5fa;
        }
        
        .formation-visual-bar.fvg {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.4) 0%, rgba(74, 222, 128, 0.2) 100%);
            border: 1px solid rgba(74, 222, 128, 0.6);
            color: #4ade80;
        }
        
        .formation-visual-sweep {
            position: absolute;
            left: 15%;
            width: 2px;
            background: #fbbf24;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.5);
        }
        
        .formation-visual-sweep::before {
            content: '⚡';
            position: absolute;
            left: -8px;
            top: -10px;
            font-size: 12px;
        }
        
        .formation-visual-label {
            position: absolute;
            font-family: 'Roboto Mono', monospace;
            font-size: 8px;
            color: #888;
        }
        
        /* Attraction Zone Visual */
        .attraction-visual {
            margin: 8px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .attraction-visual-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .attraction-visual-tf {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 4px;
        }
        
        .attraction-visual-tf.bullish {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .attraction-visual-tf.bearish {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        .attraction-visual-sd {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .attraction-visual-sd-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 18px;
            font-weight: 700;
        }
        
        .attraction-visual-sd-label {
            font-size: 9px;
            color: #888;
        }
        
        .attraction-visual-phase {
            padding: 4px 10px;
            border-radius: 4px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
        }
        
        .attraction-visual-phase.fresh {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .attraction-visual-phase.tested {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.4);
        }
        
        .attraction-visual-phase.exhausted {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        .attraction-visual-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .attraction-visual-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
        
        .attraction-visual-bar-fill.bullish { background: linear-gradient(90deg, #4ade80, rgba(74, 222, 128, 0.5)); }
        .attraction-visual-bar-fill.bearish { background: linear-gradient(90deg, #f87171, rgba(248, 113, 113, 0.5)); }
        
        /* R:R Visual for Gate */
        .rr-visual {
            margin: 8px 0;
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .rr-visual-prices {
            display: flex;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        
        .rr-visual-price {
            text-align: center;
        }
        
        .rr-visual-price-label {
            font-size: 9px;
            color: #888;
            margin-bottom: 4px;
        }
        
        .rr-visual-price-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 600;
        }
        
        .rr-visual-price.entry .rr-visual-price-value { color: #60a5fa; }
        .rr-visual-price.stop .rr-visual-price-value { color: #f87171; }
        .rr-visual-price.target .rr-visual-price-value { color: #4ade80; }
        
        .rr-visual-bar {
            position: relative;
            height: 32px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        
        .rr-visual-bar-risk {
            position: absolute;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, #f87171, rgba(248, 113, 113, 0.3));
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #f87171;
        }
        
        .rr-visual-bar-reward {
            position: absolute;
            right: 0;
            height: 100%;
            background: linear-gradient(270deg, #4ade80, rgba(74, 222, 128, 0.3));
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #4ade80;
        }
        
        .rr-visual-bar-entry {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #60a5fa;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.8);
        }
        
        .rr-visual-ratio {
            text-align: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 20px;
            font-weight: 700;
        }
        
        .rr-visual-ratio.pass { color: #4ade80; }
        .rr-visual-ratio.fail { color: #f87171; }
        
        /* VIX Gauge */
        .vix-gauge {
            margin: 8px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .vix-gauge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .vix-gauge-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 24px;
            font-weight: 700;
        }
        
        .vix-gauge-value.stable { color: #4ade80; }
        .vix-gauge-value.elevated { color: #fbbf24; }
        .vix-gauge-value.high { color: #f87171; }
        
        .vix-gauge-ratio {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 4px;
        }
        
        .vix-gauge-ratio.stable {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }
        
        .vix-gauge-ratio.elevated {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }
        
        .vix-gauge-ratio.high {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }
        
        .vix-gauge-bar {
            height: 6px;
            background: linear-gradient(90deg, #4ade80 0%, #fbbf24 50%, #f87171 100%);
            border-radius: 3px;
            position: relative;
        }
        
        .vix-gauge-marker {
            position: absolute;
            top: -4px;
            width: 4px;
            height: 14px;
            background: #fff;
            border-radius: 2px;
            transform: translateX(-50%);
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.5);
        }
        
        /* Premium/Discount Gauge */
        .pd-gauge {
            margin: 8px 0;
        }
        
        .pd-gauge-bar {
            position: relative;
            height: 24px;
            background: linear-gradient(90deg, 
                rgba(74, 222, 128, 0.3) 0%, 
                rgba(74, 222, 128, 0.15) 35%,
                rgba(251, 191, 36, 0.15) 35%,
                rgba(251, 191, 36, 0.15) 65%,
                rgba(248, 113, 113, 0.15) 65%,
                rgba(248, 113, 113, 0.3) 100%
            );
            border-radius: 4px;
            border: 1px solid #444;
        }
        
        .pd-gauge-marker {
            position: absolute;
            top: -2px;
            width: 4px;
            height: 28px;
            background: #fff;
            border-radius: 2px;
            transform: translateX(-50%);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
        }
        
        .pd-gauge-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 9px;
            color: #888;
        }
        
        .pd-gauge-labels span:first-child { color: #4ade80; }
        .pd-gauge-labels span:last-child { color: #f87171; }
        
        /* Session Indicator */
        .session-visual {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .session-visual-time {
            font-family: 'Roboto Mono', monospace;
            font-size: 20px;
            font-weight: 600;
            color: #fff;
        }
        
        .session-visual-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
        }
        
        .session-visual-badge.active {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.25) 0%, rgba(74, 222, 128, 0.1) 100%);
            border: 1px solid rgba(74, 222, 128, 0.5);
            color: #4ade80;
        }
        
        .session-visual-badge.inactive {
            background: rgba(100, 100, 100, 0.2);
            border: 1px solid #555;
            color: #888;
        }
        
        /* Visual Zone Chart */
        .analysis-zone-chart {
            position: relative;
            margin: 16px 0;
            padding: 12px;
            background: rgba(15, 15, 18, 0.8);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .analysis-zone-chart-title {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        
        .analysis-zone-chart-inner {
            position: relative;
            height: 280px;
            display: flex;
        }
        
        .analysis-zone-chart-axis {
            width: 70px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px 0;
            border-right: 1px solid #333;
            margin-right: 12px;
        }
        
        .analysis-zone-chart-price {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            color: #666;
            text-align: right;
            padding-right: 8px;
        }
        
        .analysis-zone-chart-price.entry { color: #60a5fa; font-weight: 600; }
        .analysis-zone-chart-price.target { color: #4ade80; font-weight: 600; }
        .analysis-zone-chart-price.stop { color: #f87171; font-weight: 600; }
        
        .analysis-zone-chart-body {
            flex: 1;
            position: relative;
        }
        
        .analysis-zone-chart-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: #333;
        }
        
        .analysis-zone-chart-line.entry {
            background: #60a5fa;
            height: 2px;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.5);
        }
        
        .analysis-zone-chart-line.target {
            background: #4ade80;
            height: 2px;
            border-style: dashed;
            box-shadow: 0 0 8px rgba(74, 222, 128, 0.5);
        }
        
        .analysis-zone-chart-line.stop {
            background: #f87171;
            height: 2px;
            box-shadow: 0 0 8px rgba(248, 113, 113, 0.5);
        }
        
        .analysis-zone-chart-label {
            position: absolute;
            right: 0;
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            transform: translateY(-50%);
        }
        
        .analysis-zone-chart-label.entry {
            background: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
        }
        
        .analysis-zone-chart-label.target {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }
        
        .analysis-zone-chart-label.stop {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }
        
        .analysis-zone-chart-zone {
            position: absolute;
            left: 80px;
            right: 60px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding-left: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            opacity: 0.9;
            transition: opacity 0.2s;
        }
        
        .analysis-zone-chart-zone:hover {
            opacity: 1;
        }
        
        .analysis-zone-chart-zone.bull {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.3) 0%, rgba(74, 222, 128, 0.1) 100%);
            border-left: 3px solid #4ade80;
            color: #4ade80;
        }
        
        .analysis-zone-chart-zone.bear {
            background: linear-gradient(90deg, rgba(248, 113, 113, 0.3) 0%, rgba(248, 113, 113, 0.1) 100%);
            border-left: 3px solid #f87171;
            color: #f87171;
        }
        
        .analysis-zone-chart-zone-tf {
            font-weight: 600;
            min-width: 28px;
        }
        
        .analysis-zone-chart-zone.tf-4h { border-left-color: #c084fc; }
        .analysis-zone-chart-zone.tf-1h { border-left-color: #60a5fa; }
        .analysis-zone-chart-zone.tf-15m { border-left-color: #4ade80; }
        .analysis-zone-chart-zone.tf-5m { border-left-color: #fbbf24; }
        
        .analysis-zone-chart-zone.tf-4h .analysis-zone-chart-zone-tf { color: #c084fc; }
        .analysis-zone-chart-zone.tf-1h .analysis-zone-chart-zone-tf { color: #60a5fa; }
        .analysis-zone-chart-zone.tf-15m .analysis-zone-chart-zone-tf { color: #4ade80; }
        .analysis-zone-chart-zone.tf-5m .analysis-zone-chart-zone-tf { color: #fbbf24; }
        
        .analysis-zone-chart-current {
            position: absolute;
            left: 75px;
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 8px solid #60a5fa;
            transform: translateY(-50%);
        }
        
        .analysis-zones-summary {
            margin-top: 8px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-size: 10px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .analysis-zones-summary-result {
            font-weight: 600;
        }
        
        .analysis-zones-summary-result.strong { color: #4ade80; }
        .analysis-zones-summary-result.moderate { color: #fbbf24; }
        .analysis-zones-summary-result.weak { color: #f87171; }
        
        .analysis-zone-ladder {
            position: relative;
            margin: 12px 0;
            padding-left: 20px;
            border-left: 2px solid #333;
        }
        
        .analysis-zone-ladder-entry {
            position: relative;
            padding: 6px 0 6px 15px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #60a5fa;
        }
        
        .analysis-zone-ladder-entry::before {
            content: '►';
            position: absolute;
            left: -8px;
            color: #60a5fa;
            font-size: 8px;
        }
        
        .analysis-zone-ladder-target {
            position: relative;
            padding: 6px 0 6px 15px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #4ade80;
        }
        
        .analysis-zone-ladder-target::before {
            content: '◆';
            position: absolute;
            left: -8px;
            color: #4ade80;
            font-size: 8px;
        }
        
        .analysis-zone-ladder-stop {
            position: relative;
            padding: 6px 0 6px 15px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #f87171;
        }
        
        .analysis-zone-ladder-stop::before {
            content: '■';
            position: absolute;
            left: -7px;
            color: #f87171;
            font-size: 8px;
        }
        
        .analysis-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #1e1e20 0%, #252528 100%);
        }
        
        .analysis-decision {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .analysis-decision-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .analysis-decision-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            padding: 6px 16px;
            border-radius: 4px;
        }
        
        .analysis-decision-value.execute {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.1) 100%);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.3);
        }
        
        .analysis-decision-value.caution {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2) 0%, rgba(251, 191, 36, 0.1) 100%);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }
        
        .analysis-decision-value.skip {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.1) 100%);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.3);
        }
        
        .analysis-decision-value.blocked {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.3) 0%, rgba(180, 50, 50, 0.2) 100%);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.5);
        }
        
        .analysis-score {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .analysis-score-bar {
            width: 120px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .analysis-score-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .analysis-score-fill.high { background: #4ade80; }
        .analysis-score-fill.moderate { background: #fbbf24; }
        .analysis-score-fill.low { background: #f87171; }
        
        .analysis-score-text {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            color: #888;
        }
        
        .analysis-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: #60a5fa;
            font-size: 11px;
            cursor: pointer;
            padding: 6px 10px;
            border-radius: 4px;
            background: rgba(96, 165, 250, 0.1);
            border: 1px solid rgba(96, 165, 250, 0.2);
            transition: all 0.2s;
            margin-top: 12px;
        }
        
        .analysis-link:hover {
            background: rgba(96, 165, 250, 0.2);
            border-color: rgba(96, 165, 250, 0.4);
        }
        
        .analysis-link-disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .analysis-link-disabled:hover {
            background: rgba(96, 165, 250, 0.1);
            border-color: rgba(96, 165, 250, 0.2);
        }
        
        /* Confluence Button */
        .confluence-btn {
            background: linear-gradient(135deg, #7c3aed 0%, #4f46e5 100%) !important;
            border: none !important;
        }
        
        .confluence-btn:hover {
            background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%) !important;
        }
        
        /* SMT Button */
        .smt-btn {
            background: linear-gradient(135deg, #0891b2 0%, #0e7490 100%) !important;
            border: none !important;
        }
        
        .smt-btn:hover {
            background: linear-gradient(135deg, #06b6d4 0%, #14b8a6 100%) !important;
        }
        
        /* SMT Modal */
        .smt-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        .smt-modal-overlay.visible {
            display: flex;
        }
        
        .smt-modal {
            background: #1a1a1f;
            border-radius: 12px;
            width: 95vw;
            max-width: 1600px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
        }
        
        .smt-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #333;
        }
        
        .smt-modal-title {
            font-size: 18px;
            font-weight: 700;
            color: #fff;
        }
        
        .smt-modal-close {
            background: transparent;
            border: 1px solid #444;
            color: #888;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .smt-modal-close:hover {
            background: #ef4444;
            border-color: #ef4444;
            color: #fff;
        }
        
        /* SMT Modal Filters */
        .smt-modal-filters {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: #1a1a1f;
            border-bottom: 1px solid #333;
            flex-wrap: wrap;
        }
        
        .smt-filter-label {
            font-size: 10px;
            color: #666;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .smt-filter-divider {
            width: 1px;
            height: 20px;
            background: #333;
            margin: 0 8px;
        }
        
        .smt-filter-btn {
            padding: 5px 12px;
            border-radius: 4px;
            border: 1px solid #333;
            background: transparent;
            color: #555;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .smt-filter-btn:hover {
            border-color: #555;
            color: #888;
        }
        
        .smt-filter-btn.active {
            border-color: #60a5fa;
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
        }
        
        .smt-filter-btn.nq.active {
            border-color: #60a5fa;
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
        }
        
        .smt-filter-btn.es.active {
            border-color: #a78bfa;
            color: #a78bfa;
            background: rgba(167, 139, 250, 0.1);
        }
        
        .smt-filter-btn.bull.active {
            border-color: #22c55e;
            color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
        }
        
        .smt-filter-btn.bear.active {
            border-color: #ef4444;
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }
        
        .smt-filter-btn.status-active.active {
            border-color: #60a5fa;
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
        }
        
        .smt-filter-btn.status-t1.active {
            border-color: #4ade80;
            color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }
        
        .smt-filter-btn.status-t2.active {
            border-color: #16a34a;
            color: #16a34a;
            background: rgba(22, 163, 74, 0.1);
        }
        
        .smt-filter-btn.status-fail.active {
            border-color: #ef4444;
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }
        
        /* SMT Group Card */
        .smt-group-card {
            background: #1a1a1f;
            border: 1px solid #2a2a35;
            border-radius: 8px;
            margin-bottom: 12px;
            overflow: hidden;
        }
        
        .smt-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: #252530;
            border-bottom: 1px solid #333;
        }
        
        .smt-group-id {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            color: #22c55e;
            font-weight: 600;
        }
        
        .smt-group-count {
            font-size: 11px;
            color: #666;
            background: #1a1a1f;
            padding: 3px 10px;
            border-radius: 10px;
        }
        
        .smt-group-breakers {
            padding: 8px;
        }
        
        .smt-breaker-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            border-radius: 4px;
            transition: background 0.15s;
        }
        
        .smt-breaker-row:hover {
            background: #252530;
        }
        
        .smt-breaker-time {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #888;
            min-width: 90px;
        }
        
        .smt-breaker-id {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #94a3b8;
            flex: 1;
        }
        
        .smt-breaker-badges {
            display: flex;
            gap: 6px;
        }
        
        .smt-badge {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
        }
        
        .smt-badge.nq { background: rgba(96, 165, 250, 0.15); color: #60a5fa; }
        .smt-badge.es { background: rgba(167, 139, 250, 0.15); color: #a78bfa; }
        .smt-badge.bull { background: rgba(34, 197, 94, 0.15); color: #22c55e; }
        .smt-badge.bear { background: rgba(239, 68, 68, 0.15); color: #ef4444; }
        .smt-badge.tf { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        
        /* Status badges */
        .smt-badge.status-active { background: rgba(96, 165, 250, 0.15); color: #60a5fa; }
        .smt-badge.status-success-t1 { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .smt-badge.status-success-t2 { background: rgba(22, 163, 74, 0.2); color: #16a34a; font-weight: 700; }
        .smt-badge.status-failure { background: rgba(239, 68, 68, 0.15); color: #ef4444; }
        
        /* Status stat boxes */
        .smt-stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 6px 12px;
            border-radius: 6px;
            background: #252530;
            border: 1px solid #333;
            min-width: 50px;
        }
        
        .smt-stat-count {
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            font-weight: 700;
            line-height: 1.2;
        }
        
        .smt-stat-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .smt-stat-pct {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #555;
            line-height: 1;
        }
        
        .smt-stat-box.active { border-color: rgba(96, 165, 250, 0.3); }
        .smt-stat-box.active .smt-stat-count { color: #60a5fa; }
        
        .smt-stat-box.t1 { border-color: rgba(74, 222, 128, 0.3); }
        .smt-stat-box.t1 .smt-stat-count { color: #4ade80; }
        
        .smt-stat-box.t2 { border-color: rgba(22, 163, 74, 0.3); }
        .smt-stat-box.t2 .smt-stat-count { color: #16a34a; }
        
        .smt-stat-box.fail { border-color: rgba(239, 68, 68, 0.3); }
        .smt-stat-box.fail .smt-stat-count { color: #ef4444; }
        
        .smt-stat-box.winrate { border-color: rgba(251, 191, 36, 0.3); }
        .smt-stat-box.winrate .smt-stat-count { color: #fbbf24; }
        
        .smt-stat-box.nq { border-color: rgba(96, 165, 250, 0.3); }
        .smt-stat-box.nq .smt-stat-count { color: #60a5fa; }
        
        .smt-stat-box.es { border-color: rgba(167, 139, 250, 0.3); }
        .smt-stat-box.es .smt-stat-count { color: #a78bfa; }
        
        .smt-stat-box.bull { border-color: rgba(34, 197, 94, 0.3); }
        .smt-stat-box.bull .smt-stat-count { color: #22c55e; }
        
        .smt-stat-box.bear { border-color: rgba(239, 68, 68, 0.3); }
        .smt-stat-box.bear .smt-stat-count { color: #ef4444; }
        
        .smt-stat-box.tf { border-color: rgba(251, 191, 36, 0.3); }
        .smt-stat-box.tf .smt-stat-count { color: #fbbf24; }
        
        /* Active filter tags */
        .smt-filter-tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .smt-filter-tag.nq { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .smt-filter-tag.es { background: rgba(167, 139, 250, 0.2); color: #a78bfa; }
        .smt-filter-tag.bull { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        .smt-filter-tag.bear { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
        .smt-filter-tag.tf { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
        .smt-filter-tag.status-active { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .smt-filter-tag.status-t1 { background: rgba(74, 222, 128, 0.2); color: #4ade80; }
        .smt-filter-tag.status-t2 { background: rgba(22, 163, 74, 0.2); color: #16a34a; }
        .smt-filter-tag.status-fail { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
        
        .smt-modal-content {
            flex: 1;
            overflow: auto;
            padding: 0;
        }
        
        .smt-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        
        .smt-table th {
            background: #252530;
            color: #94a3b8;
            font-weight: 600;
            text-align: left;
            padding: 10px 12px;
            border-bottom: 2px solid #333;
            position: sticky;
            top: 0;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 0.5px;
        }
        
        .smt-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #2a2a35;
            color: #e2e8f0;
        }
        
        .smt-table tr:hover td {
            background: #252530;
        }
        
        .smt-table .bull { color: #22c55e; }
        .smt-table .bear { color: #ef4444; }
        .smt-table .nq { color: #60a5fa; }
        .smt-table .es { color: #a78bfa; }
        
        .smt-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }
        
        .smt-badge.bull { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        .smt-badge.bear { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
        .smt-badge.sync { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        .smt-badge.div { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
        .smt-badge.none { background: rgba(100, 116, 139, 0.2); color: #64748b; }
        
        .smt-quality {
            font-family: 'Roboto Mono', monospace;
            font-weight: 600;
        }
        
        .smt-quality.high { color: #22c55e; }
        .smt-quality.med { color: #fbbf24; }
        .smt-quality.low { color: #ef4444; }
        
        /* Confluence Modal - Enterprise Design */
        .confluence-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #08080a;
            z-index: 10000;
            display: none;
        }
        
        .confluence-modal-overlay.visible {
            display: flex;
            flex-direction: column;
        }
        
        .confluence-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 24px;
            background: linear-gradient(180deg, #0f0f12 0%, #0a0a0c 100%);
            border-bottom: 1px solid #1f1f24;
        }
        
        .confluence-modal-title {
            font-size: 15px;
            font-weight: 600;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: 0.3px;
        }
        
        .confluence-modal-title span {
            color: #a78bfa;
            font-size: 18px;
        }
        
        .confluence-live-badge {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: #4ade80;
            background: rgba(74, 222, 128, 0.12);
            border: 1px solid rgba(74, 222, 128, 0.25);
            padding: 4px 12px;
            border-radius: 4px;
            margin-left: 16px;
            animation: livePulse 2s ease-in-out infinite;
            display: none;
            letter-spacing: 0.5px;
        }
        
        .confluence-live-badge.visible {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        @keyframes livePulse {
            0%, 100% { opacity: 1; border-color: rgba(74, 222, 128, 0.4); }
            50% { opacity: 0.7; border-color: rgba(74, 222, 128, 0.15); }
        }
        
        .confluence-modal-close {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.4);
            color: #ef4444;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            padding: 6px 14px;
            border-radius: 4px;
            line-height: 1;
            transition: all 0.15s;
        }
        
        .confluence-modal-close:hover {
            color: #fff;
            background: #ef4444;
            border-color: #ef4444;
        }
        
        .confluence-modal-time-header {
            height: 32px;
            background: #0c0c0e;
            border-bottom: 1px solid #1a1a1e;
            position: relative;
            overflow: hidden;
        }
        
        .confluence-time-inner {
            position: absolute;
            height: 100%;
            display: flex;
            align-items: center;
        }
        
        .confluence-time-tick {
            position: absolute;
            font-size: 10px;
            color: #4a4a52;
            font-family: 'Roboto Mono', monospace;
            transform: translateX(-50%);
            letter-spacing: 0.3px;
        }
        
        .confluence-modal-body {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: #050506;
        }
        
        .confluence-scroll-container {
            height: 100%;
            overflow-x: auto;
            overflow-y: auto;
            position: relative;
            background: #050506;
        }
        
        .confluence-chart-inner {
            position: relative;
            min-height: 100%;
            padding-left: 24px;
            padding-top: 16px;
            padding-bottom: 16px;
            background: #050506;
        }
        
        .confluence-cursor-line {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(180, 150, 255, 0.95);
            pointer-events: none;
            z-index: 10001;
            display: none;
            box-shadow: 0 0 12px rgba(180, 150, 255, 0.8), 0 0 25px rgba(168, 140, 255, 0.5);
        }
        
        .confluence-cursor-line.visible {
            display: block;
        }
        
        .confluence-cursor-line.live {
            background: rgba(74, 222, 128, 0.85);
            width: 2px;
            box-shadow: 0 0 4px rgba(74, 222, 128, 0.4);
        }
        
        .confluence-cursor-time {
            position: fixed;
            background: linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%);
            color: #fff;
            padding: 5px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-family: 'Roboto Mono', monospace;
            font-weight: 600;
            pointer-events: none;
            z-index: 10004;
            display: none;
            transform: translateX(-50%);
            box-shadow: 0 0 15px rgba(167, 139, 250, 0.7), 0 2px 10px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.5px;
        }
        
        .confluence-cursor-time.live {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            box-shadow: 0 0 6px rgba(74, 222, 128, 0.4);
        }
        
        .confluence-card {
            position: absolute;
            background: #0c0c0f;
            border-radius: 6px;
            overflow: hidden;
            min-width: 100px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.5);
            border: 1px solid #1a1a1e;
            transition: all 0.2s ease;
        }
        
        .confluence-card.cursor-highlight {
            border-color: rgba(180, 150, 255, 0.8);
            background: #12121a;
            box-shadow: 
                0 0 0 2px rgba(180, 150, 255, 0.4),
                0 0 25px rgba(180, 150, 255, 0.3),
                0 0 50px rgba(168, 140, 255, 0.15);
        }
        
        .confluence-card.cursor-highlight-live {
            border-color: rgba(74, 222, 128, 0.8);
            background: #0c1410;
            box-shadow: 
                0 0 0 2px rgba(74, 222, 128, 0.4),
                0 0 25px rgba(74, 222, 128, 0.35),
                0 0 50px rgba(74, 222, 128, 0.2);
        }
        
        .ccard-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: linear-gradient(180deg, #131316 0%, #0c0c0f 100%);
            border-left: 3px solid #888;
            border-bottom: 1px solid #1a1a1e;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            min-height: 35px;
            box-sizing: border-box;
        }
        
        .ccard-tf { font-weight: 700; letter-spacing: 0.3px; }
        .ccard-sym { color: #9ca3af; }
        .ccard-dir { font-weight: 700; font-size: 13px; }
        .ccard-spacer { flex: 1; }
        
        .ccard-zone-info {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #6b7280;
        }
        
        .ccard-zone-pct {
            padding: 1px 5px;
            border-radius: 3px;
            background: rgba(107, 114, 128, 0.15);
        }
        .ccard-zone-pct.good { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .ccard-zone-pct.partial { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .ccard-zone-pct.bad { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        
        .ccard-status {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.3px;
        }
        .ccard-status.success {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }
        .ccard-status.fail {
            background: rgba(239, 68, 68, 0.15);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.25);
        }
        
        .confluence-card-body {
            height: 220px;
            position: relative;
            background: #0c0c0f;
        }
        
        .confluence-card.cursor-highlight .confluence-card-body,
        .confluence-card.cursor-highlight-live .confluence-card-body {
            background: #0f0f14;
        }
        
        .confluence-card-body svg {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* Cursor label - Light Glow Style */
        .confluence-cursor-label {
            position: fixed;
            background: rgba(240, 235, 255, 0.92);
            border: 1px solid rgba(168, 140, 255, 0.6);
            border-radius: 4px;
            padding: 5px 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #1a1a2e;
            pointer-events: none;
            z-index: 10003;
            white-space: nowrap;
            box-shadow: 0 0 20px rgba(180, 160, 255, 0.5), 0 0 40px rgba(168, 140, 255, 0.3), 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .confluence-cursor-label.live {
            background: rgba(230, 255, 240, 0.92);
            border-color: rgba(74, 222, 128, 0.7);
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.5), 0 0 40px rgba(74, 222, 128, 0.3), 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .confluence-labels-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10002;
        }
        
        .confluence-no-data {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4a4a52;
            font-size: 14px;
            font-family: 'Roboto Mono', monospace;
        }
        
        /* ===== TRADE TABS (compact, positioned in swimlane) ===== */
        .trade-tab {
            height: 26px;
            min-width: 28px;
            padding: 0 10px;
            background: #1a1a1f;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            border: 2px solid;
            border-radius: 13px;
            position: absolute;
            z-index: 15;
        }
        
        .trade-tab-left {
            /* Rounded pill - no special corners */
        }
        
        .trade-tab-right {
            /* Rounded pill - no special corners */
        }
        
        .trade-tab:hover {
            filter: brightness(1.3);
            z-index: 10;
        }
        
        /* Tab colors */
        .trade-tab.pending { 
            border-color: #fbbf24; 
            color: #fbbf24; 
            animation: tab-blink 1s ease-in-out infinite;
        }
        .trade-tab.filled { border-color: #3b82f6; color: #3b82f6; }
        .trade-tab.denied { border-color: #f97316; color: #f97316; }
        .trade-tab.win { border-color: #22c55e; color: #22c55e; }
        .trade-tab.loss { border-color: #ef4444; color: #ef4444; }
        .trade-tab.cancelled { border-color: #6b7280; color: #6b7280; }
        
        /* Tiny close reason subscript (c=cancel, e=eod) */
        .trade-tab .close-reason {
            font-size: 7px;
            vertical-align: sub;
            opacity: 0.8;
            margin-left: 1px;
        }
        
        @keyframes tab-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        /* ===== TRADE DETAIL MODAL (v6.9.0) ===== */
        .trade-modal-backdrop {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .trade-modal-backdrop.active { display: flex; }
        
        .trade-modal {
            background: #ffffff;
            border-radius: 12px;
            width: 1200px;
            max-width: 98vw;
            height: 98vh;
            max-height: 98vh;
            overflow: hidden;
            box-shadow: 0 30px 80px rgba(0,0,0,0.3);
            border: 1px solid #e0e0e5;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        /* Close Button */
        .tm-close {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 32px; height: 32px; border-radius: 8px; border: none;
            background: rgba(0,0,0,0.05); color: #666; font-size: 18px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            z-index: 10;
        }
        .tm-close:hover { background: rgba(0,0,0,0.1); color: #333; }
        
        /* Tabs - Integrated look */
        .tm-tabs { 
            display: flex; 
            background: #ffffff; 
            border-bottom: 1px solid #e0e0e5;
            flex-shrink: 0;
        }
        .tm-tab {
            flex: 1; padding: 16px 20px; font-size: 13px; font-weight: 600; color: #888;
            text-align: center; cursor: pointer; border-bottom: 3px solid transparent;
            transition: all 0.15s; display: flex; align-items: center; justify-content: center; gap: 10px;
            background: #fafafa;
        }
        .tm-tab:first-child { justify-content: flex-start; }
        .tm-tab:hover { color: #333; background: #f5f5f5; }
        .tm-tab.active { 
            color: #1a1a2e; 
            border-bottom-color: #3b82f6; 
            background: #ffffff;
        }
        .tm-tab-symbol { font-family: 'Roboto Mono', monospace; font-size: 18px; font-weight: 700; color: #1a1a2e; }
        .tm-tab.active .tm-tab-symbol { color: #1a1a2e; }
        .tm-tab-tf { font-size: 11px; font-weight: 700; padding: 3px 8px; border-radius: 4px; background: #e0e7ff; color: #4f46e5; }
        .tm-tab-dir { font-size: 11px; font-weight: 700; padding: 3px 8px; border-radius: 4px; }
        .tm-tab-dir.bull { background: rgba(34,197,94,0.15); color: #16a34a; }
        .tm-tab-dir.bear { background: rgba(239,68,68,0.15); color: #dc2626; }
        .tm-tab-status { font-size: 11px; font-weight: 700; padding: 3px 10px; border-radius: 4px; margin-left: 4px; }
        .tm-tab-status.win { background: rgba(34,197,94,0.12); color: #16a34a; }
        .tm-tab-status.loss { background: rgba(239,68,68,0.12); color: #dc2626; }
        .tm-tab-status.filtered { background: rgba(249,115,22,0.12); color: #ea580c; }
        .tm-tab-status.pending { background: rgba(59,130,246,0.12); color: #2563eb; }
        .tm-tab-status.cancelled { background: rgba(107,114,128,0.12); color: #6b7280; }
        .tm-tab-pnl { font-family: 'Roboto Mono', monospace; font-size: 16px; font-weight: 700; margin-left: 6px; }
        .tm-tab-pnl.win { color: #16a34a; }
        .tm-tab-pnl.loss { color: #dc2626; }
        .tm-tab-pnl.neutral { color: #666; }
        /* Breaker tab styling */
        #tm-tab-breaker { font-family: 'Roboto Mono', monospace; font-size: 12px; font-weight: 700; color: #555; }
        #tm-tab-breaker.active { color: #333; }
        
        /* Tab Content - Fill available space */
        .tm-content { 
            display: none; 
            padding: 12px; 
            flex: 1;
            overflow-y: auto; 
            background: #f8f8fa; 
        }
        .tm-content.active { display: flex; flex-direction: column; }
        
        /* Panels - No headers */
        .tm-panel {
            background: #ffffff;
            border-radius: 10px;
            border: 1px solid #e0e0e8;
            overflow: hidden;
        }
        
        /* Trade Tab - Compact but Detailed Layout */
        .tm-trade-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 14px;
        }
        
        /* Gates Panel - Removed, using new v3 layout */
        
        /* Setup Panel - Right Top */
        .tm-setup-panel { 
            background: linear-gradient(135deg, #eff6ff 0%, #f8faff 100%);
            border-color: #bfdbfe;
        }
        .tm-setup-content { padding: 14px; display: grid; grid-template-columns: 1fr 100px; gap: 12px; }
        .tm-prices { display: flex; flex-direction: column; gap: 6px; }
        .tm-price-row {
            display: flex; align-items: center; padding: 10px 12px;
            background: rgba(255,255,255,0.8); border-radius: 6px; border-left: 4px solid;
        }
        .tm-price-row.target { border-left-color: #16a34a; }
        .tm-price-row.entry { border-left-color: #2563eb; }
        .tm-price-row.stop { border-left-color: #dc2626; }
        .tm-price-label { font-size: 10px; color: #666; text-transform: uppercase; width: 50px; }
        .tm-price-value { font-family: 'Roboto Mono', monospace; font-size: 14px; font-weight: 600; flex: 1; color: #222; }
        .tm-price-row.target .tm-price-value { color: #16a34a; }
        .tm-price-row.entry .tm-price-value { color: #2563eb; }
        .tm-price-row.stop .tm-price-value { color: #dc2626; }
        .tm-price-pts { font-family: 'Roboto Mono', monospace; font-size: 10px; color: #888; }
        .tm-price-pts.target-pts { color: #16a34a; font-weight: 700; font-size: 11px; }
        .tm-price-pts.stop-pts { color: #dc2626; font-weight: 700; font-size: 11px; }
        .tm-rr-box {
            background: rgba(255,255,255,0.8); border-radius: 6px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .tm-rr-value { font-family: 'Roboto Mono', monospace; font-size: 22px; font-weight: 700; color: #ca8a04; }
        .tm-rr-value.good { color: #16a34a; }
        .tm-rr-label { font-size: 9px; color: #888; text-transform: uppercase; }
        
        /* Entry Thresholds - Below Setup */
        .tm-thresholds { 
            padding: 10px 14px;
            border-top: 1px solid rgba(191,219,254,0.5);
            display: flex;
            gap: 12px;
            justify-content: space-around;
            background: rgba(255,255,255,0.5);
        }
        .tm-threshold {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .tm-threshold-pct {
            font-size: 10px;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 4px;
        }
        .tm-threshold.weak .tm-threshold-pct { background: rgba(234,179,8,0.15); color: #ca8a04; }
        .tm-threshold.moderate .tm-threshold-pct { background: rgba(59,130,246,0.15); color: #2563eb; }
        .tm-threshold.strong .tm-threshold-pct { background: rgba(34,197,94,0.15); color: #16a34a; }
        .tm-threshold-price {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: #333;
        }
        .tm-threshold-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
        }
        
        /* Outcome Panel - Close Reason & Terminal State */
        .tm-outcome-panel { 
            background: linear-gradient(135deg, #fefce8 0%, #fffef5 100%);
            border-color: #fde68a;
        }
        .tm-outcome-content {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .tm-outcome-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .tm-outcome-label {
            font-size: 10px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            min-width: 140px;
        }
        .tm-outcome-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #333;
            flex: 1;
        }
        .tm-terminal-badge {
            font-size: 10px;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 4px;
        }
        .tm-terminal-badge.success { background: rgba(34,197,94,0.12); color: #16a34a; }
        .tm-terminal-badge.failure { background: rgba(239,68,68,0.12); color: #dc2626; }
        .tm-terminal-badge.active { background: rgba(59,130,246,0.12); color: #2563eb; }
        
        /* Timeline Panel - Right Middle */
        .tm-timeline-panel { 
            background: linear-gradient(135deg, #faf5ff 0%, #fcfaff 100%);
            border-color: #e9d5ff;
        }
        .tm-timeline-content { padding: 14px; }
        .tm-timeline-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .tm-tl-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }
        .tm-tl-dot {
            width: 28px; height: 28px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 11px; font-weight: 700; border: 2px solid;
            background: #fff;
        }
        .tm-tl-dot.created { border-color: #eab308; color: #ca8a04; }
        .tm-tl-dot.filled { background: #2563eb; border-color: #2563eb; color: #fff; }
        .tm-tl-dot.win { background: #16a34a; border-color: #16a34a; color: #fff; }
        .tm-tl-dot.loss { background: #dc2626; border-color: #dc2626; color: #fff; }
        .tm-tl-dot.filtered { background: #ea580c; border-color: #ea580c; color: #fff; }
        .tm-tl-dot.pending { border-color: #d1d5db; color: #9ca3af; }
        .tm-tl-dot.cancelled { background: #6b7280; border-color: #6b7280; color: #fff; }
        .tm-tl-info { margin-top: 6px; text-align: center; max-width: 150px; }
        .tm-tl-info .label { display: block; font-size: 11px; font-weight: 600; color: #333; }
        .tm-tl-info .time { display: block; font-family: 'Roboto Mono', monospace; font-size: 10px; color: #555; }
        .tm-tl-info .price { display: block; font-family: 'Roboto Mono', monospace; font-size: 10px; color: #2563eb; font-weight: 600; }
        .tm-tl-info .reason { display: block; font-size: 9px; color: #888; margin-top: 2px; line-height: 1.2; word-wrap: break-word; }
        .tm-tl-info .filter-reason { 
            font-family: 'Roboto Mono', monospace;
            font-size: 10px; 
            color: #c2410c; 
            background: rgba(251,146,60,0.1);
            padding: 4px 6px;
            border-radius: 4px;
            margin-top: 6px;
            max-width: 180px;
        }
        .tm-tl-connector {
            flex: 0 0 40px;
            height: 3px;
            background: linear-gradient(90deg, #d1d5db, #22c55e);
            margin: 0 -8px;
            margin-top: -20px;
        }
        .tm-tl-connector.loss { background: linear-gradient(90deg, #d1d5db, #ef4444); }
        .tm-tl-connector.filtered { background: linear-gradient(90deg, #d1d5db, #f97316); }
        .tm-tl-connector.pending { background: #e5e7eb; }
        
        /* Confluence Panel - Full Width Bottom, Highlighted */
        .tm-confluence-panel {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #eef2ff 0%, #f5f7ff 100%);
            border-radius: 10px;
            border: 2px solid #c7d2fe;
        }
        .tm-confluence-content {
            padding: 16px;
        }
        .tm-confluence-summary {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 14px;
        }
        .tm-conf-score {
            font-family: 'Roboto Mono', monospace;
            font-size: 24px;
            font-weight: 700;
            color: #1e1b4b;
        }
        .tm-conf-score span { font-size: 14px; color: #888; font-weight: 400; }
        .tm-conf-badge {
            font-size: 11px;
            font-weight: 700;
            padding: 5px 12px;
            border-radius: 6px;
            text-transform: uppercase;
        }
        .tm-conf-badge.entry { background: #16a34a; color: #fff; }
        .tm-conf-badge.filtered { background: #ea580c; color: #fff; }
        .tm-factors-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .tm-factor {
            display: flex;
            gap: 10px;
            padding: 12px;
            background: #fff;
            border-radius: 8px;
            border-left: 4px solid;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }
        .tm-factor.pos { border-left-color: #16a34a; background: rgba(34,197,94,0.04); }
        .tm-factor.zero { border-left-color: #d1d5db; }
        .tm-factor.neg { border-left-color: #dc2626; background: rgba(239,68,68,0.04); }
        .tm-factor-score { 
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            font-weight: 700; 
            min-width: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tm-factor.pos .tm-factor-score { color: #16a34a; }
        .tm-factor.zero .tm-factor-score { color: #9ca3af; }
        .tm-factor.neg .tm-factor-score { color: #dc2626; }
        .tm-factor-info { flex: 1; min-width: 0; }
        .tm-factor-name { font-size: 12px; font-weight: 600; color: #333; margin-bottom: 2px; }
        .tm-factor-reason { font-size: 11px; color: #555; line-height: 1.3; }
        .tm-confluence-dimmed { opacity: 0.5; }
        .tm-confluence-dimmed .tm-confluence-content { text-align: center; padding: 24px; color: #888; font-size: 12px; }
        
        /* Blocked message */
        .tm-blocked-msg {
            padding: 8px 12px;
            background: rgba(239,68,68,0.08);
            border-radius: 6px;
            font-size: 11px;
            color: #dc2626;
            margin-top: 6px;
        }
        
        /* ===== TRADE TAB V2 - Scoring First Layout ===== */
        .tm-trade-grid-v2 {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        /* ═══════════════════════════════════════════════════════════════
           V7 ANALYST FOCUS - Scoring & Gates prominent, Setup minimal
           ═══════════════════════════════════════════════════════════════ */
        
        .tm-report {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            line-height: 1.4;
            color: #1e293b;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 0;
            background: #f1f5f9;
            flex: 1;
        }
        
        /* ─────────────────────────────────────────────────────────────
           RESULT HEADER - Outcome dominates
           ───────────────────────────────────────────────────────────── */
        .tm-result-header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 14px 18px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }
        
        .tm-result-header.win { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-left: 5px solid #22c55e; }
        .tm-result-header.loss { background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-left: 5px solid #ef4444; }
        .tm-result-header.filtered { background: linear-gradient(135deg, #fff7ed 0%, #ffedd5 100%); border-left: 5px solid #f97316; }
        
        .tm-result-outcome {
            font-size: 26px;
            font-weight: 800;
        }
        .tm-result-outcome.win { color: #16a34a; }
        .tm-result-outcome.loss { color: #dc2626; }
        .tm-result-outcome.filtered { color: #ea580c; }
        
        .tm-result-closetype {
            font-size: 14px;
            font-weight: 600;
            opacity: 0.7;
        }
        
        .tm-result-r {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 600;
        }
        .tm-result-r.win { color: #16a34a; }
        .tm-result-r.loss { color: #dc2626; }
        
        .tm-result-detail {
            font-size: 12px;
            color: #64748b;
            font-family: 'Roboto Mono', monospace;
        }
        
        /* Hypothetical section */
        .tm-result-hypothetical-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 8px 12px;
            background: #f8fafc;
            border: 1px dashed #cbd5e1;
            border-radius: 6px;
            margin-left: 16px;
        }
        
        .tm-hypo-header {
            font-size: 10px;
            font-weight: 700;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .tm-hypo-boxes {
            display: flex;
            gap: 10px;
        }
        
        .tm-hypo-box {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 6px 10px;
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            min-width: 100px;
        }
        
        .tm-hypo-label {
            font-size: 9px;
            font-weight: 700;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .tm-hypo-outcome {
            font-size: 14px;
            font-weight: 800;
            color: #64748b;
        }
        .tm-hypo-outcome.win { color: #16a34a; }
        .tm-hypo-outcome.loss { color: #dc2626; }
        
        .tm-hypo-pnl {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: #64748b;
        }
        .tm-hypo-pnl.win { color: #16a34a; }
        .tm-hypo-pnl.loss { color: #dc2626; }
        
        .tm-hypo-r {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
        }
        .tm-hypo-r.win { color: #16a34a; }
        .tm-hypo-r.loss { color: #dc2626; }
        
        .tm-hypo-detail {
            font-size: 10px;
            color: #64748b;
            font-family: 'Roboto Mono', monospace;
        }
        
        .tm-result-pnl {
            font-family: 'Roboto Mono', monospace;
            font-size: 20px;
            font-weight: 700;
        }
        .tm-result-pnl.win { color: #16a34a; }
        .tm-result-pnl.loss { color: #dc2626; }
        
        .tm-result-r {
            font-size: 14px;
            color: #64748b;
        }
        
        .tm-result-divider {
            width: 1px;
            height: 36px;
            background: #e2e8f0;
            margin: 0 8px;
        }
        
        .tm-result-close {
            flex: 1;
        }
        
        .tm-result-close-main {
            font-size: 14px;
            font-weight: 600;
            color: #334155;
        }
        
        .tm-result-close-rule {
            font-family: 'Roboto Mono', monospace;
            font-weight: 700;
            color: #7c3aed;
        }
        
        .tm-result-close-detail {
            font-size: 12px;
            color: #64748b;
            display: block;
        }
        
        .tm-result-score {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: rgba(255,255,255,0.7);
            border-radius: 8px;
        }
        
        .tm-result-score-num {
            font-family: 'Roboto Mono', monospace;
            font-size: 24px;
            font-weight: 800;
            color: #4338ca;
        }
        
        .tm-result-badge {
            font-size: 10px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
            background: #16a34a;
            color: #fff;
        }
        .tm-result-badge.filtered { background: #ea580c; }
        
        /* Card Result - the actual class used in HTML */
        .tm-card-result {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
        }
        .tm-card-result.win { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-left: 5px solid #22c55e; }
        .tm-card-result.loss { background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-left: 5px solid #ef4444; }
        .tm-card-result.filtered { background: linear-gradient(135deg, #fff7ed 0%, #ffedd5 100%); border-left: 5px solid #f97316; }
        
        .tm-result-left { flex: 0 0 auto; display: flex; flex-direction: column; gap: 2px; }
        .tm-result-center { flex: 1; text-align: center; padding: 0 24px; border-left: 1px solid rgba(0,0,0,0.1); border-right: 1px solid rgba(0,0,0,0.1); margin: 0 20px; }
        .tm-result-right { flex: 0 0 auto; text-align: center; }
        
        .tm-result-close-label { font-size: 10px; color: #64748b; text-transform: uppercase; }
        .tm-result-close-value { font-size: 16px; font-weight: 700; color: #334155; margin-top: 2px; }
        
        .tm-result-score { font-family: 'Roboto Mono', monospace; font-size: 36px; font-weight: 800; color: #4338ca; line-height: 1; }
        
        /* Gates + Rules side by side */
        .tm-row-gates-rules {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        /* Timeline bar - horizontal */
        .tm-timeline-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }
        
        .tm-tl-step {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tm-tl-dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 700;
        }
        .tm-tl-dot.created { background: #fef3c7; color: #b45309; }
        .tm-tl-dot.filled { background: #dbeafe; color: #1d4ed8; }
        .tm-tl-dot.win { background: #dcfce7; color: #16a34a; }
        .tm-tl-dot.loss { background: #fee2e2; color: #dc2626; }
        .tm-tl-dot.filtered { background: #ffedd5; color: #ea580c; }
        .tm-tl-dot.pending { background: #f3f4f6; color: #6b7280; }
        
        .tm-tl-info { display: flex; flex-direction: column; }
        .tm-tl-label { font-weight: 600; color: #334155; font-size: 12px; }
        .tm-tl-time { font-family: 'Roboto Mono', monospace; font-size: 11px; color: #64748b; }
        .tm-tl-price { font-family: 'Roboto Mono', monospace; font-size: 11px; color: #4338ca; font-weight: 600; }
        .tm-tl-arrow { color: #cbd5e1; font-size: 18px; }
        
        /* Setup bar - horizontal */
        .tm-setup-bar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 10px 16px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
            font-size: 12px;
            flex-wrap: wrap;
        }
        
        .tm-setup-divider {
            width: 1px;
            height: 20px;
            background: #e2e8f0;
        }
        
        .tm-setup-zones {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }
        
        .tm-zone-tag {
            font-size: 10px;
            font-family: 'Roboto Mono', monospace;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
        }
        .tm-zone-tag.weak { background: #fef3c7; color: #92400e; }
        .tm-zone-tag.mod { background: #dbeafe; color: #1e40af; }
        .tm-zone-tag.strong { background: #dcfce7; color: #166534; }
        
        /* ─────────────────────────────────────────────────────────────
           COMPACT INFO BAR - Timeline + Setup in one row
           ───────────────────────────────────────────────────────────── */
        .tm-info-bar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
            font-size: 12px;
        }
        
        .tm-info-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tm-info-label {
            font-size: 10px;
            font-weight: 700;
            color: #94a3b8;
            text-transform: uppercase;
        }
        
        .tm-info-divider {
            width: 1px;
            height: 24px;
            background: #e2e8f0;
        }
        
        .tm-tl-compact {
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: 'Roboto Mono', monospace;
        }
        
        .tm-tl-step { color: #475569; }
        .tm-tl-arrow { color: #94a3b8; }
        .tm-tl-price { color: #4338ca; font-weight: 600; }
        .tm-tl-final.win { color: #16a34a; font-weight: 600; }
        .tm-tl-final.loss { color: #dc2626; font-weight: 600; }
        
        .tm-setup-compact {
            display: flex;
            align-items: center;
            gap: 12px;
            font-family: 'Roboto Mono', monospace;
        }
        
        .tm-setup-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .tm-setup-item .lbl { color: #64748b; font-size: 11px; }
        .tm-setup-item .val { color: #334155; font-weight: 600; font-family: 'Roboto Mono', monospace; }
        .tm-setup-item .pts { font-weight: 700; font-size: 11px; font-family: 'Roboto Mono', monospace; }
        .tm-setup-item .pts.pos { color: #16a34a; }
        .tm-setup-item .pts.neg { color: #dc2626; }
        .tm-setup-item .rr { color: #4338ca; font-weight: 700; font-size: 14px; font-family: 'Roboto Mono', monospace; }
        
        /* ─────────────────────────────────────────────────────────────
           MAIN CONTENT - 2 column grid for Scoring + Gates
           ───────────────────────────────────────────────────────────── */
        .tm-main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            flex: 1;
        }
        
        .tm-card {
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06);
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
        }
        
        .tm-card-title {
            font-size: 11px;
            font-weight: 700;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        /* ─────────────────────────────────────────────────────────────
           SCORING CARD - Primary focus
           ───────────────────────────────────────────────────────────── */
        .tm-card-scoring {
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
            border-top: 3px solid #7c3aed;
            padding: 10px 12px;
        }
        
        .tm-card-title {
            font-size: 10px;
            font-weight: 700;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .tm-scoring-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        
        .tm-scoring-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 6px;
            background: #fafafa;
        }
        
        .tm-scoring-item.has-score { background: linear-gradient(90deg, #faf5ff 0%, #fff 100%); border-left: 3px solid #a78bfa; }
        .tm-scoring-item.zero { opacity: 0.7; }
        
        .tm-scoring-badge {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            flex-shrink: 0;
        }
        .tm-scoring-badge.pos { background: #16a34a; color: #fff; }
        .tm-scoring-badge.zero { background: #e5e7eb; color: #6b7280; }
        .tm-scoring-badge.neg { background: #dc2626; color: #fff; }
        
        .tm-scoring-info { flex: 1; min-width: 0; }
        .tm-scoring-name { font-weight: 600; color: #334155; font-size: 12px; text-transform: uppercase; letter-spacing: 0.3px; }
        .tm-scoring-reason { font-size: 11px; color: #64748b; margin-top: 2px; line-height: 1.3; word-wrap: break-word; }
        .tm-scoring-details { font-size: 10px; color: #94a3b8; margin-top: 3px; font-family: 'Roboto Mono', monospace; word-wrap: break-word; }
        
        /* ─────────────────────────────────────────────────────────────
           GATES CARD - Primary focus
           ───────────────────────────────────────────────────────────── */
        .tm-card-gates {
            border-top: 3px solid #22c55e;
        }
        
        .tm-card-gates .tm-card-title { border-color: #bbf7d0; }
        
        .tm-gates-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .tm-gate-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 6px;
            background: #f0fdf4;
            border-left: 3px solid #86efac;
        }
        
        .tm-gate-item.fail {
            background: #fef2f2;
            border-left-color: #fca5a5;
        }
        
        .tm-gate-icon {
            font-size: 16px;
            width: 24px;
            text-align: center;
        }
        .tm-gate-item .tm-gate-icon { color: #16a34a; }
        .tm-gate-item.fail .tm-gate-icon { color: #dc2626; }
        
        .tm-gate-info { flex: 1; min-width: 0; }
        .tm-gate-code { font-family: 'Roboto Mono', monospace; font-weight: 700; font-size: 11px; color: #334155; min-width: 100px; }
        .tm-gate-reason { font-size: 12px; color: #64748b; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        /* ─────────────────────────────────────────────────────────────
           RULES CARD - Full width at bottom
           ───────────────────────────────────────────────────────────── */
        .tm-card-rules {
            border-top: 3px solid #f59e0b;
        }
        
        .tm-card-rules .tm-card-title { border-color: #fde68a; }
        
        .tm-rules-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .tm-rule-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 6px;
            background: #fafafa;
        }
        
        .tm-rule-item.triggered {
            background: linear-gradient(90deg, #fffbeb 0%, #fef3c7 100%);
            border: 1px solid #fde68a;
        }
        
        .tm-rule-icon {
            font-size: 14px;
            width: 20px;
            text-align: center;
        }
        .tm-rule-item .tm-rule-icon { color: #9ca3af; }
        .tm-rule-item.triggered .tm-rule-icon { color: #f59e0b; }
        
        .tm-rule-code {
            font-family: 'Roboto Mono', monospace;
            font-weight: 700;
            font-size: 11px;
            color: #475569;
            min-width: 100px;
        }
        
        .tm-rule-reason {
            flex: 1;
            font-size: 12px;
            color: #64748b;
        }
        
        .tm-rule-item.triggered .tm-rule-reason {
            color: #92400e;
            font-weight: 500;
        }
        
        .tm-rule-tag {
            font-size: 10px;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 4px;
            background: #f59e0b;
            color: #fff;
        }
        
        /* Timeline inline - inside rules card */
        .tm-timeline-inline {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-top: 10px;
            padding: 10px 12px;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            font-size: 12px;
            font-family: 'Roboto Mono', monospace;
        }
        
        .tm-tl-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: #475569;
        }
        
        .tm-tl-text {
            display: flex;
            flex-direction: column;
            line-height: 1.3;
        }
        
        .tm-tl-lbl {
            font-size: 11px;
            font-weight: 600;
            color: #334155;
        }
        
        .tm-tl-time {
            font-size: 11px;
            color: #64748b;
        }
        
        .tm-tl-dot-sm {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            background: #e2e8f0;
            color: #475569;
        }
        /* Event type color coding */
        .tm-tl-dot-sm.pending { background: #fef3c7; color: #b45309; }
        .tm-tl-dot-sm.filled { background: #dbeafe; color: #1d4ed8; }
        .tm-tl-dot-sm.exited { background: #dcfce7; color: #16a34a; }
        .tm-tl-dot-sm.closed { background: #d1fae5; color: #059669; }
        .tm-tl-dot-sm.cancelled { background: #fee2e2; color: #dc2626; }
        .tm-tl-dot-sm.rejected { background: #fecaca; color: #b91c1c; }
        .tm-tl-dot-sm.expired { background: #f3e8ff; color: #7c3aed; }
        
        .tm-timeline-inline .tm-tl-arrow { color: #94a3b8; font-size: 16px; }
        .tm-timeline-inline .tm-tl-price { color: #4338ca; font-weight: 600; font-size: 11px; }
        
        /* ─────────────────────────────────────────────────────────────
           ZONES - Small row if present
           ───────────────────────────────────────────────────────────── */
        .tm-zones-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }
        
        .tm-zones-label {
            font-size: 10px;
            font-weight: 700;
            color: #94a3b8;
            text-transform: uppercase;
        }
        
        .tm-zone-tag {
            padding: 4px 10px;
            border-radius: 4px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
        }
        .tm-zone-tag.weak { background: #fef3c7; color: #92400e; }
        .tm-zone-tag.mod { background: #dbeafe; color: #1e40af; }
        .tm-zone-tag.strong { background: #dcfce7; color: #166534; }
        
        .tm-zone-tag .pct { font-weight: 700; margin-right: 4px; }
        
        /* OLD CSS - kept for backwards compat */
        .tm-blocked-msg code {
            font-family: 'Roboto Mono', monospace;
            color: #b91c1c;
            font-size: 10px;
        }
        
        /* Breaker Tab */
        .tm-breaker-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        .tm-breaker-grid .tm-full { grid-column: 1 / -1; }
        
        /* Pattern Panel */
        .tm-pattern-panel {
            background: #fff;
            border: 1px solid #e5e7eb;
        }
        .tm-pattern-flow { 
            display: flex; 
            align-items: flex-start; 
            padding: 20px 16px; 
            gap: 4px; 
            justify-content: center; 
        }
        .tm-pattern-node { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            min-width: 90px; 
        }
        .tm-pattern-dot {
            width: 44px; height: 44px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; font-weight: 700; border: 2px solid;
            flex-shrink: 0;
        }
        .tm-pattern-dot.high { background: rgba(34,197,94,0.08); border-color: #22c55e; color: #16a34a; }
        .tm-pattern-dot.low { background: rgba(239,68,68,0.08); border-color: #ef4444; color: #dc2626; }
        .tm-pattern-dot.br { background: rgba(59,130,246,0.08); border-color: #3b82f6; color: #2563eb; }
        .tm-pattern-info { margin-top: 8px; text-align: center; }
        .tm-pattern-time { font-family: 'Roboto Mono', monospace; font-size: 11px; color: #9ca3af; }
        .tm-pattern-price { font-family: 'Roboto Mono', monospace; font-size: 13px; font-weight: 600; color: #374151; margin-top: 2px; }
        .tm-pattern-note { font-size: 10px; color: #6b7280; margin-top: 1px; }
        .tm-pattern-note.swing { color: #d97706; }
        .tm-pattern-note.fvg { color: #059669; }
        .tm-pattern-connector { 
            width: 20px; height: 2px; background: #d1d5db; 
            margin-top: 21px;
            flex-shrink: 0;
        }
        
        /* Metrics Panel */
        .tm-metrics-panel {
            background: #fff;
            border: 1px solid #e5e7eb;
        }
        .tm-metrics-content { 
            padding: 16px;
        }
        .tm-metrics-grid {
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 1px;
            background: #e5e7eb;
            border-radius: 6px;
            overflow: hidden;
        }
        .tm-metric { 
            text-align: center; 
            padding: 14px 10px; 
            background: #fff;
        }
        .tm-metric-val { 
            display: block;
            font-family: 'Roboto Mono', monospace; 
            font-size: 15px; 
            font-weight: 600; 
            color: #111827; 
        }
        .tm-metric-val.good { color: #059669; }
        .tm-metric-lbl { 
            display: block;
            font-size: 10px; 
            font-weight: 500;
            color: #9ca3af; 
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            margin-top: 4px; 
        }
        
        /* Fib Panel */
        .tm-fib-panel {
            background: #fff;
            border: 1px solid #e5e7eb;
        }
        .tm-fib-content { padding: 16px; }
        .tm-fib-values {
            display: flex;
            gap: 12px;
            margin-bottom: 14px;
        }
        .tm-fib-val-item {
            flex: 1;
            text-align: center;
            padding: 12px 10px;
            background: #f9fafb;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }
        .tm-fib-val-lbl { 
            display: block;
            font-family: 'Roboto Mono', monospace; 
            font-size: 9px; 
            color: #9ca3af;
            letter-spacing: 0.3px;
            margin-bottom: 4px;
        }
        .tm-fib-val-num { 
            display: block;
            font-family: 'Roboto Mono', monospace; 
            font-size: 18px; 
            font-weight: 700;
            color: #111827;
        }
        .tm-fib-val-num.peak { color: #d97706; }
        .tm-fib-val-num.fb { color: #2563eb; }
        .tm-fib-levels { }
        .tm-fib-row {
            display: flex; 
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f3f4f6;
        }
        .tm-fib-row:last-child { border-bottom: none; }
        .tm-fib-row::before {
            content: '';
            width: 3px;
            height: 16px;
            border-radius: 2px;
            margin-right: 10px;
            flex-shrink: 0;
        }
        .tm-fib-row.f0::before { background: #ef4444; }
        .tm-fib-row.f1::before { background: #f97316; }
        .tm-fib-row.f3::before { background: #84cc16; }
        .tm-fib-row.f4::before { background: #22c55e; }
        .tm-fib-lbl { 
            font-family: 'Roboto Mono', monospace; 
            font-size: 11px; 
            color: #6b7280; 
            flex: 1;
        }
        .tm-fib-price { 
            font-family: 'Roboto Mono', monospace; 
            font-size: 13px; 
            font-weight: 600; 
            color: #111827; 
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-left">
            <div class="logo"><span class="logo-icon"></span> SigXFlow</div>
            <div class="stats-row">
                <div class="stat-compact success"><span id="stat-success">-</span> S</div>
                <div class="stat-compact fail"><span id="stat-fail">-</span> F</div>
                <div class="stat-compact win"><span id="stat-winrate">-</span></div>
            </div>
        </div>
        
        <div class="nav-group">
            <button class="btn inactive" id="mode-explore" onclick="setMode('explore')">🔍 Explore</button>
            <button class="btn live" id="mode-live" onclick="setMode('live')">🔴 Live</button>
            <button class="btn confluence-btn" onclick="openConfluenceModal()">◈ Confluence</button>
            <button class="btn smt-btn" onclick="openSmtModal()">◇ SMT</button>
            <div class="divider"></div>
            <div class="settings-group">
                <select class="select-styled" id="load-limit" onchange="loadData(true)">
                    <option value="8">Load 8hr</option>
                    <option value="12">Load 12hr</option>
                    <option value="24" selected>Load 1 day</option>
                    <option value="48">Load 2 days</option>
                    <option value="72">Load 3 days</option>
                    <option value="96">Load 4 days</option>
                    <option value="120">Load 5 days</option>
                    <option value="144">Load 6 days</option>
                </select>
                <select class="select-styled" id="refresh-interval" onchange="setRefreshInterval()">
                    <option value="0">Auto: Off</option>
                    <option value="30" selected>Auto: 30s</option>
                    <option value="60">Auto: 1m</option>
                    <option value="300">Auto: 5m</option>
                </select>
                <span class="countdown" id="countdown"></span>
                <button class="btn secondary" onclick="loadData(true)">↻</button>
                <button class="btn primary" onclick="goToLatest()">Latest →|</button>
            </div>
        </div>
    </div>
    
    <!-- Toolbar -->
    <div class="toolbar">
        <div class="legend">
            <div class="legend-item"><div class="legend-swatch nq-bull"></div>NQ Bull</div>
            <div class="legend-item"><div class="legend-swatch nq-bear"></div>NQ Bear</div>
            <div class="legend-item"><div class="legend-swatch es-bull"></div>ES Bull</div>
            <div class="legend-item"><div class="legend-swatch es-bear"></div>ES Bear</div>
            <div class="legend-divider"></div>
            <div class="legend-item"><div class="legend-dot win">S</div>Success</div>
            <div class="legend-item"><div class="legend-dot loss">F</div>Failure</div>
            <div class="legend-divider"></div>
            <div class="legend-item"><div class="legend-swatch entry"></div>Entry</div>
        </div>
        
        <div class="toolbar-right">
            <span class="status-msg" id="status-msg"></span>
            <div class="filter-group">
                <button class="filter-btn nq active" id="filter-nq" onclick="toggleFilter('nq')">NQ</button>
                <button class="filter-btn es active" id="filter-es" onclick="toggleFilter('es')">ES</button>
            </div>
            <div class="filter-group">
                <button class="filter-btn bull active" id="filter-bull" onclick="toggleFilter('bull')"><span class="arrow-up"></span> Bull</button>
                <button class="filter-btn bear active" id="filter-bear" onclick="toggleFilter('bear')"><span class="arrow-down"></span> Bear</button>
            </div>
        </div>
    </div>
    
    <!-- Main Wrapper -->
    <div class="main-wrapper">
        <!-- Chart Area -->
        <div class="chart-area">
            <div class="header-row">
                <div class="left-header" id="data-start">--</div>
                <div class="time-header-wrapper">
                    <div class="timeline-track" id="timeline-track">
                        <div class="timeline-viewport" id="viewport-indicator"></div>
                    </div>
                    <div class="time-header" id="time-header"></div>
                </div>
            </div>
            <div class="scroll-container" id="scroll-container">
                <div class="scroll-inner">
                    <div class="left-panel" id="left-panel"></div>
                    <div class="right-panel">
                        <div class="chart-inner" id="chart-inner"></div>
                    </div>
                </div>
                <!-- Main chart live cursor line -->
                <div class="main-cursor-line" id="main-cursor-line"></div>
            </div>
            <div class="sticky-date" id="sticky-date"></div>
        </div>
        
        <!-- Detail Panel -->
        <div class="detail-panel">
            <div class="panel-header">
                <span class="panel-type" id="panel-type">Details</span>
            </div>
            <div class="panel-content" id="panel-content">
                <div class="panel-empty">
                    <div class="panel-empty-icon">📋</div>
                    <div class="panel-empty-text">
                        Click a breaker bar or entry line to see details
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>
    
    <!-- Main chart live cursor time badge -->
    <div class="main-cursor-time" id="main-cursor-time"></div>
    
    <!-- Analysis Modal -->
    <div class="analysis-modal-overlay" id="analysis-modal" onclick="closeAnalysisModal(event)">
        <div class="analysis-modal" onclick="event.stopPropagation()">
            <!-- Hero Section with Decision -->
            <div class="analysis-hero">
                <button class="analysis-hero-close" onclick="closeAnalysisModal()">&times;</button>
                <div class="analysis-hero-top">
                    <div class="analysis-hero-decision">
                        <span class="analysis-decision-badge" id="analysis-decision-badge">EXECUTE</span>
                        <div>
                            <div class="analysis-hero-id" id="analysis-hero-id">NQ_1m_20250115_1205</div>
                            <div class="analysis-hero-meta" id="analysis-hero-meta">10:05 AM ET</div>
                        </div>
                    </div>
                    <div class="analysis-hero-score">
                        <div class="analysis-score-big" id="analysis-score-big">18/21</div>
                        <div class="analysis-score-label">Quality Score</div>
                    </div>
                </div>
            </div>
            
            <!-- Category Tabs -->
            <div class="analysis-tabs" id="analysis-tabs">
                <!-- Tabs generated by JS -->
            </div>
            
            <!-- Content Area -->
            <div class="analysis-content" id="analysis-content">
                <!-- Category panels generated by JS -->
            </div>
        </div>
    </div>

    <!-- Confluence Modal -->
    <div class="confluence-modal-overlay" id="confluence-modal">
        <div class="confluence-modal-header">
            <div class="confluence-modal-title"><span>◈</span> Confluence View <span class="confluence-live-badge" id="confluence-live-badge">● LIVE</span></div>
            <button class="confluence-modal-close" onclick="closeConfluenceModal()">&times;</button>
        </div>
        <div class="confluence-modal-time-header" id="confluence-time-header">
            <div class="confluence-time-inner" id="confluence-time-inner"></div>
        </div>
        <div class="confluence-modal-body">
            <div class="confluence-scroll-container" id="confluence-scroll">
                <div class="confluence-chart-inner" id="confluence-chart-inner">
                    <!-- Cards rendered here -->
                </div>
            </div>
        </div>
        <div class="confluence-cursor-line" id="confluence-cursor-line"></div>
        <div class="confluence-cursor-time" id="confluence-cursor-time"></div>
        <div class="confluence-labels-container" id="confluence-labels-container"></div>
    </div>

    <!-- SMT Modal -->
    <!-- SMT Modal - Breakers with Linked SMT IDs -->
    <div class="smt-modal-overlay" id="smt-modal-overlay" onclick="closeSmtModal(event)">
        <div class="smt-modal" onclick="event.stopPropagation()">
            <div class="smt-modal-header">
                <div class="smt-modal-title">◇ SMT Linked Breakers</div>
                <button class="smt-modal-close" onclick="closeSmtModal()">✕</button>
            </div>
            <!-- Filters -->
            <div class="smt-modal-filters">
                <span class="smt-filter-label">SYMBOL</span>
                <button class="smt-filter-btn nq active" id="smt-filter-nq" onclick="toggleSmtFilter('nq')">NQ</button>
                <button class="smt-filter-btn es active" id="smt-filter-es" onclick="toggleSmtFilter('es')">ES</button>
                <span class="smt-filter-divider"></span>
                <span class="smt-filter-label">DIRECTION</span>
                <button class="smt-filter-btn bull active" id="smt-filter-bull" onclick="toggleSmtFilter('bull')">↑ Bull</button>
                <button class="smt-filter-btn bear active" id="smt-filter-bear" onclick="toggleSmtFilter('bear')">↓ Bear</button>
                <span class="smt-filter-divider"></span>
                <span class="smt-filter-label">TIMEFRAME</span>
                <button class="smt-filter-btn active" id="smt-filter-1m" onclick="toggleSmtFilter('1m')">1m</button>
                <button class="smt-filter-btn active" id="smt-filter-5m" onclick="toggleSmtFilter('5m')">5m</button>
                <button class="smt-filter-btn active" id="smt-filter-15m" onclick="toggleSmtFilter('15m')">15m</button>
                <button class="smt-filter-btn active" id="smt-filter-1h" onclick="toggleSmtFilter('1h')">1h</button>
                <span class="smt-filter-divider"></span>
                <span class="smt-filter-label">STATUS</span>
                <button class="smt-filter-btn status-active active" id="smt-filter-active" onclick="toggleSmtFilter('active')">Active</button>
                <button class="smt-filter-btn status-t1 active" id="smt-filter-t1" onclick="toggleSmtFilter('t1')">T1</button>
                <button class="smt-filter-btn status-t2 active" id="smt-filter-t2" onclick="toggleSmtFilter('t2')">T2</button>
                <button class="smt-filter-btn status-fail active" id="smt-filter-fail" onclick="toggleSmtFilter('fail')">Fail</button>
            </div>
            <div class="smt-modal-content" id="smt-modal-content">
                <!-- Content populated by JS -->
            </div>
        </div>
    </div>

    <!-- Trade Detail Modal (v6.9.0) -->
    <div class="trade-modal-backdrop" id="trade-modal-backdrop" onclick="closeTradeModal(event)">
        <div class="trade-modal" onclick="event.stopPropagation()">
            <!-- Close Button -->
            <button class="tm-close" onclick="closeTradeModal()">✕</button>
            
            <!-- Tabs -->
            <div class="tm-tabs">
                <div class="tm-tab active" onclick="switchTradeModalTab(0)" id="tm-tab-trade">
                    <span class="tm-tab-symbol" id="tm-tab-symbol">NQ</span>
                    <span class="tm-tab-tf" id="tm-tab-tf">1M</span>
                    <span class="tm-tab-dir" id="tm-tab-dir">BULL</span>
                    <span class="tm-tab-status" id="tm-tab-status">CANCELLED</span>
                    <span class="tm-tab-pnl" id="tm-tab-pnl">+2.13</span>
                </div>
                <div class="tm-tab" onclick="switchTradeModalTab(1)" id="tm-tab-breaker">Breaker Details</div>
            </div>
            
            <!-- Trade Details Tab -->
            <div class="tm-content active" id="tm-trade-content">
                <!-- Content rendered dynamically -->
            </div>
            
            <!-- Breaker Details Tab -->
            <div class="tm-content" id="tm-breaker-content">
                <!-- Content rendered dynamically -->
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIG =====
        const FIREBASE_URL = "https://sigxflow-default-rtdb.firebaseio.com/snapshots.json";
        const SMT_FIREBASE_URL = "https://sigxflow-default-rtdb.firebaseio.com/smt_signals.json";
        const TRADES_FIREBASE_URL = "https://sigxflow-default-rtdb.firebaseio.com/trades.json";
        const BREAKERS_FIREBASE_URL = "https://sigxflow-default-rtdb.firebaseio.com/breakers";
        const PIXELS_PER_MINUTE = 35;
        const BAR_HEIGHT = 26;  // Height of breaker bars
        const BAR_GAP = 3;      // Gap between stacked bars
        const LANE_PADDING = 6; // Top/bottom padding in swimlanes
        const TF_HEADER_HEIGHT = 2;
        const LEFT_PANEL_MIN_HEIGHT = 68; // Minimum based on left panel content
        
        const TF_ORDER = ['1m', '5m', '15m', '1h', '4h'];
        const TF_DISPLAY = { '4h': '4H', '1h': '1H', '15m': '15m', '5m': '5m', '1m': '1m' };
        const SYMBOLS = ['NQ', 'ES'];
        
        // ===== STATE =====
        let allData = [];
        let smtData = [];  // SMT signals
        let tradesData = {}; // Trade records keyed by breaker_id
        let breakerDetailsCache = {}; // Cached breaker details from /breakers endpoint
        let smtCache = {}; // For incremental SMT updates
        let lastSmtFetchTime = null; // Track last SMT fetch for incremental updates
        let breakerCache = {}; // For incremental updates
        let windowStartMin = 0;
        let windowEndMin = 0;
        let dataMinTime = 0;
        let dataMaxTime = 0;
        let isLive = true;
        let isFirstLoad = true;
        let lastFetchedTime = null; // Track last observation_time for incremental fetch
        let lastLoadLimit = null; // Track if limit changed (requires full reload)
        let refreshTimer = null;
        let countdownTimer = null;
        let countdownSecs = 0;
        let selectedEntryMin = null;
        let selectedBreakerId = null;
        let lockedConfluenceMin = null;
        let entryTimes = [];
        let chartAbortController = null; // For cleaning up event listeners
        let renderedBars = []; // Cached bar elements for fast highlight
        let renderedLaneLabels = []; // Cached lane labels
        let laneStats = {}; // Stats per tf/symbol/direction
        let detailCursorInterval = null; // For detail panel live cursor
        let mainCursorInterval = null; // For main chart live cursor
        
        const filters = {
            nq: true, es: true,
            bull: true, bear: true
        };
        
        // ===== UTILITIES =====
        function datetimeToMin(datetime) {
            const parts = datetime.replace('T', ' ').split(' ');
            const dateParts = parts[0].split('-');
            const timeParts = (parts[1] || '00:00').split(':');
            const d = new Date(
                parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]),
                parseInt(timeParts[0]), parseInt(timeParts[1])
            );
            return Math.floor(d.getTime() / 60000);
        }
        
        function minToTime(m) {
            const d = new Date(m * 60000);
            return d.getHours().toString().padStart(2, '0') + ':' + 
                   d.getMinutes().toString().padStart(2, '0');
        }
        
        function minToDateTime(m) {
            const d = new Date(m * 60000);
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            return months[d.getMonth()] + ' ' + d.getDate() + ', ' + minToTime(m);
        }
        
        function minToDateStr(m) {
            const d = new Date(m * 60000);
            const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            return days[d.getDay()] + ' ' + months[d.getMonth()] + ' ' + d.getDate();
        }
        
        function minToDateKey(m) {
            // Returns YYYY-MM-DD for comparison
            const d = new Date(m * 60000);
            return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
        }
        
        function minToShortDateTime(m) {
            // Returns compact date+time like "1/14 10:05"
            const d = new Date(m * 60000);
            return (d.getMonth() + 1) + '/' + d.getDate() + ' ' + 
                   d.getHours().toString().padStart(2, '0') + ':' + 
                   d.getMinutes().toString().padStart(2, '0');
        }
        
        function minToDuration(startMin, endMin) {
            const mins = endMin - startMin;
            if (mins < 60) return mins + 'm';
            const hrs = Math.floor(mins / 60);
            const rem = mins % 60;
            return rem > 0 ? `${hrs}h ${rem}m` : `${hrs}h`;
        }
        
        let toastTimeout = null;
        
        function showToast(msg, type = '') {
            const el = document.getElementById('status-msg');
            el.textContent = msg;
            el.className = 'status-msg ' + type;
            // Clear previous timeout and set new one
            if (toastTimeout) clearTimeout(toastTimeout);
            if (type !== 'error') {
                toastTimeout = setTimeout(() => {
                    el.textContent = '';
                    toastTimeout = null;
                }, 5000);
            }
        }
        
        // ===== STACKING ALGORITHM =====
        function assignStackPositions(breakers) {
            if (!breakers.length) return [];
            
            const sorted = [...breakers].sort((a, b) => a.startMin - b.startMin);
            const stackEnds = [];
            
            sorted.forEach(b => {
                let stackIdx = 0;
                while (stackIdx < stackEnds.length && stackEnds[stackIdx] > b.startMin) {
                    stackIdx++;
                }
                
                b.stackIdx = stackIdx;
                stackEnds[stackIdx] = b.endMin + 1;
            });
            
            return sorted;
        }
        
        // ===== WINDOW MANAGEMENT =====
        function setWindow(startMin, endMin, label) {
            windowStartMin = startMin;
            windowEndMin = endMin;
            
            updateViewportIndicator();
        }
        
        function updateMiniTimeline() {
            updateViewportIndicator();
        }
        
        function setMode(mode) {
            isLive = (mode === 'live');
            
            const exploreBtn = document.getElementById('mode-explore');
            const liveBtn = document.getElementById('mode-live');
            
            if (isLive) {
                liveBtn.classList.remove('inactive');
                exploreBtn.classList.remove('explore-active');
                exploreBtn.classList.add('inactive');
                // Show live confluence if data exists and nothing selected/locked
                if (allData.length > 0 && lockedConfluenceMin === null && !selectedBreakerId && !selectedSmtId) {
                    showLiveConfluence();
                }
                // Start main cursor
                startMainCursor();
            } else {
                exploreBtn.classList.remove('inactive');
                exploreBtn.classList.add('explore-active');
                liveBtn.classList.add('inactive');
                // Clear live highlights
                clearLiveHighlight();
                // Clear main cursor
                if (mainCursorInterval) {
                    clearInterval(mainCursorInterval);
                    mainCursorInterval = null;
                }
                const cursorLine = document.getElementById('main-cursor-line');
                const cursorTime = document.getElementById('main-cursor-time');
                if (cursorLine) cursorLine.classList.remove('visible');
                if (cursorTime) cursorTime.style.display = 'none';
                // Only show empty panel if nothing selected/locked
                if (lockedConfluenceMin === null && !selectedBreakerId && !selectedSmtId) {
                    showEmptyPanel();
                }
            }
            
            loadData();
        }
        
        function goToLatest() {
            if (dataMaxTime === 0) {
                showToast('No data loaded', 'error');
                return;
            }
            
            const container = document.getElementById('scroll-container');
            container.scrollLeft = container.scrollWidth;
        }
        
        function shiftWindow(direction) {
            if (dataMinTime === 0 || dataMaxTime === 0) {
                showToast('No data loaded', 'error');
                return;
            }
            
            const windowHours = getLoadHours();
            const shift = direction * windowHours * 60;
            let newStart = windowStartMin + shift;
            let newEnd = windowEndMin + shift;
            
            if (newStart < dataMinTime) {
                newStart = dataMinTime;
                newEnd = newStart + windowHours * 60;
            }
            if (newEnd > dataMaxTime) {
                newEnd = dataMaxTime;
                newStart = Math.max(dataMinTime, newEnd - windowHours * 60);
            }
            
            if (newStart === windowStartMin && newEnd === windowEndMin) {
                showToast('No more data in that direction', 'error');
                return;
            }
            
            windowStartMin = newStart;
            windowEndMin = newEnd;
            setWindow(windowStartMin, windowEndMin, 'Custom ' + windowHours + 'hr');
            renderChart();
            
            setTimeout(() => {
                const container = document.getElementById('scroll-container');
                if (direction > 0) {
                    container.scrollLeft = 0;
                } else {
                    container.scrollLeft = container.scrollWidth;
                }
            }, 50);
        }
        
        function advanceLiveWindow() {
            // Get current time in minutes (matching how datetimeToMin works)
            const now = new Date();
            const nowMin = Math.floor(now.getTime() / 60000);
            
            // In live mode, always extend window to current time (even if data hasn't arrived yet)
            const windowSize = windowEndMin - windowStartMin;
            windowEndMin = Math.max(dataMaxTime, nowMin); // extend to current time
            windowStartMin = Math.max(dataMinTime, windowEndMin - windowSize);
            
            // Also update dataMaxTime for other calculations
            if (nowMin > dataMaxTime) {
                dataMaxTime = nowMin;
            }
            
            setWindow(windowStartMin, windowEndMin, 'Live');
            renderChart();
            
            // Scroll to right edge and show live confluence (only if nothing selected/locked)
            setTimeout(() => {
                const container = document.getElementById('scroll-container');
                container.scrollLeft = container.scrollWidth;
                // Update cursor after scroll
                updateMainCursor();
                if (lockedConfluenceMin === null && !selectedBreakerId && !selectedSmtId) {
                    showLiveConfluence();
                }
            }, 50);
        }
        
        // ===== FILTERS =====
        function toggleFilter(key) {
            filters[key] = !filters[key];
            // Convert camelCase to kebab-case for button ID
            const btnId = 'filter-' + key.replace(/([A-Z])/g, '-$1').toLowerCase();
            const btn = document.getElementById(btnId);
            if (btn) btn.classList.toggle('active', filters[key]);
            renderChart();
        }
        
        // ===== DATA LOADING =====
        function getLoadHours() {
            const el = document.getElementById('load-limit');
            return el ? parseInt(el.value) : 8;
        }
        
        function loadData(forceFullLoad = false) {
            const currentHours = getLoadHours();
            
            const needsFullLoad = forceFullLoad || 
                                  !lastFetchedTime || 
                                  lastLoadLimit !== currentHours ||
                                  Object.keys(breakerCache).length === 0;
            
            lastLoadLimit = currentHours;
            
            if (needsFullLoad) {
                // Full load with server-side time filtering
                showToast('Loading...', '');
                
                // Also reload SMT data and trades data
                loadSmtData();
                loadTradesData();
                
                // For multi-day loads during market closures, always use fallback
                // (indexed query uses wall clock time which misses old data when market is closed)
                const useFullLoad = currentHours >= 24;
                
                if (useFullLoad) {
                    // Load all data and filter client-side based on LATEST DATA TIME
                    console.log(`📊 Loading ${currentHours} hours - using full load for accuracy`);
                    
                    fetch(FIREBASE_URL)
                        .then(r => {
                            if (!r.ok) throw new Error('HTTP ' + r.status);
                            return r.json();
                        })
                        .then(data => {
                            if (!data) throw new Error('No data');
                            
                            // Snapshot key IS the timestamp (e.g. "2026-01-21T0731")
                            // Convert to entries with observation_time from key
                            let entries = Object.entries(data)
                                .filter(([k, v]) => v && typeof v === 'object')
                                .map(([k, v]) => {
                                    // Convert key "2026-01-21T0731" to "2026-01-21T07:31"
                                    let obsTime = k;
                                    if (k.match(/^\d{4}-\d{2}-\d{2}T\d{4}$/)) {
                                        obsTime = k.slice(0, 13) + ':' + k.slice(13);
                                    }
                                    return [k, { ...v, observation_time: obsTime }];
                                });
                            
                            if (entries.length === 0) throw new Error('No valid data');
                            
                            // Find the latest observation time
                            let latestTime = '';
                            let earliestTime = 'Z';
                            entries.forEach(([k, v]) => {
                                if (v.observation_time > latestTime) latestTime = v.observation_time;
                                if (v.observation_time < earliestTime) earliestTime = v.observation_time;
                            });
                            
                            console.log(`📊 Full data range: ${earliestTime} to ${latestTime}`);
                            
                            // Calculate cutoff from LATEST DATA TIME (not wall clock)
                            const latestMin = datetimeToMin(latestTime);
                            const cutoffMin = latestMin - (currentHours * 60);
                            
                            console.log(`📊 Filtering to ${currentHours} hours before latest data (cutoff: ${minToDateTime(cutoffMin)})`);
                            
                            // Filter to only include snapshots within time range
                            const beforeFilter = entries.length;
                            entries = entries.filter(([k, v]) => {
                                const snapMin = datetimeToMin(v.observation_time);
                                return snapMin >= cutoffMin;
                            });
                            
                            console.log(`📊 After filter: ${entries.length} snapshots (removed ${beforeFilter - entries.length})`);
                            
                            // Sort by time
                            entries.sort((a, b) => {
                                const tsA = a[1].observation_time || '';
                                const tsB = b[1].observation_time || '';
                                return tsA.localeCompare(tsB);
                            });
                            
                            const limited = {};
                            entries.forEach(([k, v]) => limited[k] = v);
                            
                            processFirebaseData(limited, true);
                        })
                        .catch(err => {
                            showToast('Error: ' + err.message, 'error');
                            console.error(err);
                        });
                } else {
                    // For short time ranges (<24h), use indexed query with wall clock time
                    // Since the key IS the timestamp now, we need to filter differently
                    const now = new Date();
                    const cutoffDate = new Date(now.getTime() - (currentHours * 60 * 60 * 1000));
                    
                    const pad = n => n.toString().padStart(2, '0');
                    // Key format is "2026-01-21T0731" (no colon in time)
                    const cutoffKey = `${cutoffDate.getFullYear()}-${pad(cutoffDate.getMonth()+1)}-${pad(cutoffDate.getDate())}T${pad(cutoffDate.getHours())}${pad(cutoffDate.getMinutes())}`;
                    
                    console.log(`📊 Loading ${currentHours} hours of data`);
                    console.log(`📊 Cutoff key: ${cutoffKey}`);
                    
                    // Query by key (since key IS the timestamp)
                    const filteredUrl = FIREBASE_URL + 
                        '?orderBy="$key"&startAt="' + cutoffKey + '"';
                    
                    fetch(filteredUrl)
                        .then(r => {
                            if (!r.ok) throw new Error('HTTP ' + r.status);
                            return r.json();
                        })
                        .then(data => {
                            if (!data) throw new Error('No data');
                            
                            // Convert keys to observation_time
                            let entries = Object.entries(data)
                                .filter(([k, v]) => v && typeof v === 'object')
                                .map(([k, v]) => {
                                    let obsTime = k;
                                    if (k.match(/^\d{4}-\d{2}-\d{2}T\d{4}$/)) {
                                        obsTime = k.slice(0, 13) + ':' + k.slice(13);
                                    }
                                    return [k, { ...v, observation_time: obsTime }];
                                });
                            
                            if (entries.length === 0) throw new Error('No valid data');
                            
                            const times = entries.map(([k, v]) => v.observation_time).sort();
                            console.log(`✓ Query returned ${entries.length} snapshots`);
                            console.log(`✓ Data range: ${times[0]} to ${times[times.length-1]}`);
                            
                            entries.sort((a, b) => {
                                const tsA = a[1].observation_time || '';
                                const tsB = b[1].observation_time || '';
                                return tsA.localeCompare(tsB);
                            });
                            
                            const limited = {};
                            entries.forEach(([k, v]) => limited[k] = v);
                            
                            processFirebaseData(limited, true);
                        })
                        .catch(err => {
                            showToast('Error: ' + err.message, 'error');
                            console.error(err);
                        });
                }
            } else {
                // Incremental load - only fetch newer data from Firebase
                // Also refresh SMT data and trades data
                loadSmtData(true);
                loadTradesData();
                
                // Convert lastFetchedTime from "2026-01-21T07:31" to key format "2026-01-21T0731"
                const lastKey = lastFetchedTime ? lastFetchedTime.replace(':', '') : '';
                const url = FIREBASE_URL + 
                    '?orderBy="$key"&startAfter="' + lastKey + '"';
                
                console.log('Incremental fetch:', url);
                
                fetch(url)
                    .then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.json();
                    })
                    .then(data => {
                        if (!data || Object.keys(data).length === 0) {
                            // In Live mode, advance window to current time even if no data
                            if (isLive) {
                                advanceLiveWindow();
                                showToast('Live - no new data', '');
                            } else {
                                showToast('No new data', '');
                            }
                            return;
                        }
                        
                        // Convert keys to snapshots with observation_time
                        const converted = {};
                        Object.entries(data).forEach(([k, v]) => {
                            if (v && typeof v === 'object') {
                                let obsTime = k;
                                if (k.match(/^\d{4}-\d{2}-\d{2}T\d{4}$/)) {
                                    obsTime = k.slice(0, 13) + ':' + k.slice(13);
                                }
                                converted[k] = { ...v, observation_time: obsTime };
                            }
                        });
                        
                        console.log('Incremental data:', Object.keys(converted).length, 'snapshots');
                        processIncrementalData(converted);
                    })
                    .catch(err => {
                        // If query fails (no index), show error with instructions
                        console.error('Incremental fetch failed:', err);
                        showToast('Index needed - see console', 'error');
                    });
            }
        }
        
        function processFirebaseData(snapshots, isFullLoad = true) {
            if (isFullLoad) {
                breakerCache = {}; // Reset cache on full load
            }
            
            let snapshotList = Array.isArray(snapshots) 
                ? snapshots 
                : Object.values(snapshots).filter(s => s);
            
            if (snapshotList.length === 0) {
                showToast('No data', 'error');
                return;
            }
            
            snapshotList.sort((a, b) => {
                const tsA = a.observation_time || '';
                const tsB = b.observation_time || '';
                return tsA.localeCompare(tsB);
            });
            
            // Track the latest observation time for incremental fetches
            const latestSnap = snapshotList[snapshotList.length - 1];
            lastFetchedTime = latestSnap.observation_time;
            
            let minTime = Infinity, maxTime = 0;
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                if (ts) {
                    const min = datetimeToMin(ts);
                    if (min < minTime) minTime = min;
                    if (min > maxTime) maxTime = min;
                }
            });
            
            dataMinTime = minTime;
            dataMaxTime = maxTime;
            
            console.log(`📊 Processing ${snapshotList.length} snapshots`);
            console.log(`📊 Time range: ${minToDateTime(minTime)} to ${minToDateTime(maxTime)}`);
            console.log(`📊 Duration: ${((maxTime - minTime) / 60).toFixed(1)} hours`);
            
            // In live mode, extend window to current time
            const now = new Date();
            const nowMin = Math.floor(now.getTime() / 60000);
            
            if (isLive && nowMin > dataMaxTime) {
                windowEndMin = nowMin; // extend to current time
                dataMaxTime = nowMin;
            } else {
                windowEndMin = dataMaxTime;
            }
            windowStartMin = dataMinTime;
            
            setWindow(windowStartMin, windowEndMin, 'Latest');
            
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                const datetime = ts.replace('T', ' ');
                const absMin = datetimeToMin(ts);
                
                // Breakers are direct children of snapshot (not under 'breakers' key)
                Object.entries(snap).forEach(([id, b]) => {
                    // Skip non-breaker fields
                    if (id === 'observation_time' || typeof b !== 'object' || !b) return;
                    
                    // Parse all fields from breaker ID
                    // Format: NQ-1m-260121T1548-260121T1600-25446-25492-15z-39r-L
                    // [0]symbol-[1]tf-[2]detection-[3]confirmation-[4]L2-[5]H2-[6]zone-[7]range-[8]dir
                    const idParts = id.split('-');
                    const symbol = idParts[0] || 'ES';
                    const tf = idParts[1] || '1m';
                    const dir = idParts[idParts.length - 1] === 'S' ? 'bear' : 'bull';
                    const formationTime = idParts[2] || ''; // detection time
                    const confirmationTime = idParts[3] || ''; // MSS confirmation time
                    
                    // Parse price levels from ID
                    const sweepLow = parseInt(idParts[4]) || 0;   // L2: Sweep low price
                    const breakerHigh = parseInt(idParts[5]) || 0; // H2: Breaker high price
                    const zoneStr = idParts[6] || '0z';
                    const rangeStr = idParts[7] || '0r';
                    const zoneSize = parseInt(zoneStr.replace('z', '')) || 0;
                    const fibRange = parseInt(rangeStr.replace('r', '')) || 0;
                    
                    // For display, use H2 as the main price
                    const price = breakerHigh;
                    
                    if (!breakerCache[id]) {
                        breakerCache[id] = {
                            id,
                            displayId: b.display_id || id,
                            symbol: symbol.toUpperCase(),
                            tf: tf.toLowerCase(),
                            dir: dir.toLowerCase(),
                            sweepLow: sweepLow,       // L2
                            breakerHigh: breakerHigh, // H2
                            price: price,
                            zoneSize: zoneSize,
                            fibRange: fibRange,
                            formationTime: formationTime,
                            confirmationTime: confirmationTime,
                            status: 'ACTIVE',
                            zonePct: 0,
                            t1Time: null,
                            t2Time: null,
                            events: [],
                            currentFib: 0,
                            maxFib: 0,
                            linkedSmtId: b.linked_smt_id || null
                        };
                    }
                    
                    // Update linked_smt_id if present
                    if (b.linked_smt_id) {
                        breakerCache[id].linkedSmtId = b.linked_smt_id;
                    }
                    
                    // Update display_id if we get a newer one
                    if (b.display_id) {
                        breakerCache[id].displayId = b.display_id;
                    }
                    
                    // Update zone_pct
                    if (b.zone_pct !== undefined) {
                        breakerCache[id].zonePct = parseFloat(b.zone_pct) || 0;
                    }
                    
                    // Parse fib - current_fib and max_fib fields
                    const currentFib = parseFloat(b.current_fib) || 0;
                    const maxFib = parseFloat(b.max_fib) || 0;
                    
                    // Get snapshot price
                    const snapshotPrice = b.price || 0;
                    
                    // Avoid duplicate events (same timestamp)
                    if (!breakerCache[id].events.some(e => e.absMin === absMin)) {
                        breakerCache[id].events.push({ datetime, absMin, fib: currentFib, maxFib: maxFib, price: snapshotPrice });
                    }
                    breakerCache[id].currentFib = currentFib;
                    breakerCache[id].maxFib = Math.max(breakerCache[id].maxFib, maxFib);
                    
                    // Update status if present (new format: SUCCESS_T1, SUCCESS_T2_TERMINATED, FAILURE_TERMINATED, etc.)
                    if (b.status) {
                        const upperStatus = b.status.toUpperCase();
                        if (upperStatus !== 'ACTIVE') {
                            breakerCache[id].status = b.status;
                            
                            // Track T1 and T2 milestone times
                            if (upperStatus.startsWith('SUCCESS_T1') && !breakerCache[id].t1Time) {
                                breakerCache[id].t1Time = absMin;
                            }
                            if (upperStatus.startsWith('SUCCESS_T2') && !breakerCache[id].t2Time) {
                                // Also set T1 time if not already set (T2 implies T1 was reached)
                                if (!breakerCache[id].t1Time) {
                                    breakerCache[id].t1Time = absMin;
                                }
                                breakerCache[id].t2Time = absMin;
                            }
                        }
                    }
                });
            });
            
            
            finalizeBreakers();
            
            // Load linked_smt_ids from breakers collection
            loadLinkedSmtIds();
            
            showToast('Loaded ' + allData.length + ' breakers', 'success');
        }
        
        function loadLinkedSmtIds() {
            // Fetch breaker records to get linked_smt_id
            fetch(BREAKERS_FIREBASE_URL + '.json')
                .then(r => r.json())
                .then(data => {
                    if (!data) {
                        console.log('📊 No breaker records found for linked_smt_id');
                        return;
                    }
                    
                    let linkedCount = 0;
                    Object.entries(data).forEach(([key, breaker]) => {
                        if (breaker && breaker.linked_smt_id) {
                            // Find matching breaker in cache by ID
                            // The key might be the breaker_id or the record key
                            const breakerId = breaker.breaker_id || key;
                            
                            if (breakerCache[breakerId]) {
                                breakerCache[breakerId].linkedSmtId = breaker.linked_smt_id;
                                linkedCount++;
                            } else {
                                // Try matching by key directly
                                if (breakerCache[key]) {
                                    breakerCache[key].linkedSmtId = breaker.linked_smt_id;
                                    linkedCount++;
                                }
                            }
                        }
                    });
                    
                    console.log(`📊 Loaded ${linkedCount} linked_smt_ids from breakers collection`);
                    
                    // Update allData reference
                    allData = Object.values(breakerCache);
                    
                    // Re-render chart to show SMT indicators on bars
                    if (linkedCount > 0) {
                        renderChart();
                    }
                })
                .catch(err => {
                    console.warn('📊 Error loading linked_smt_ids:', err);
                });
        }
        
        function processIncrementalData(snapshots) {
            let snapshotList = Array.isArray(snapshots) 
                ? snapshots 
                : Object.values(snapshots).filter(s => s);
            
            if (snapshotList.length === 0) {
                showToast('No new data', '');
                return;
            }
            
            snapshotList.sort((a, b) => {
                const tsA = a.observation_time || '';
                const tsB = b.observation_time || '';
                return tsA.localeCompare(tsB);
            });
            
            // Update lastFetchedTime
            const latestSnap = snapshotList[snapshotList.length - 1];
            lastFetchedTime = latestSnap.observation_time;
            
            // Update max time
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                if (ts) {
                    const min = datetimeToMin(ts);
                    if (min > dataMaxTime) dataMaxTime = min;
                }
            });
            
            // Merge into cache
            let newBreakers = 0;
            
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                const datetime = ts.replace('T', ' ');
                const absMin = datetimeToMin(ts);
                
                // Breakers are direct children of snapshot (not under 'breakers' key)
                Object.entries(snap).forEach(([id, b]) => {
                    // Skip non-breaker fields
                    if (id === 'observation_time' || typeof b !== 'object' || !b) return;
                    
                    // Parse all fields from breaker ID
                    // Format: NQ-1m-260121T1548-260121T1600-25446-25492-15z-39r-L
                    // [0]symbol-[1]tf-[2]detection-[3]confirmation-[4]L2-[5]H2-[6]zone-[7]range-[8]dir
                    const idParts = id.split('-');
                    const symbol = idParts[0] || 'ES';
                    const tf = idParts[1] || '1m';
                    const dir = idParts[idParts.length - 1] === 'S' ? 'bear' : 'bull';
                    const formationTime = idParts[2] || '';
                    const confirmationTime = idParts[3] || '';
                    
                    // Parse price levels from ID
                    const sweepLow = parseInt(idParts[4]) || 0;   // L2: Sweep low price
                    const breakerHigh = parseInt(idParts[5]) || 0; // H2: Breaker high price
                    const zoneStr = idParts[6] || '0z';
                    const rangeStr = idParts[7] || '0r';
                    const zoneSize = parseInt(zoneStr.replace('z', '')) || 0;
                    const fibRange = parseInt(rangeStr.replace('r', '')) || 0;
                    
                    const price = breakerHigh;
                    
                    if (!breakerCache[id]) {
                        breakerCache[id] = {
                            id,
                            displayId: b.display_id || id,
                            symbol: symbol.toUpperCase(),
                            tf: tf.toLowerCase(),
                            dir: dir.toLowerCase(),
                            sweepLow: sweepLow,
                            breakerHigh: breakerHigh,
                            price: price,
                            zoneSize: zoneSize,
                            fibRange: fibRange,
                            formationTime: formationTime,
                            confirmationTime: confirmationTime,
                            status: 'ACTIVE',
                            zonePct: 0,
                            t1Time: null,
                            t2Time: null,
                            events: [],
                            currentFib: 0,
                            maxFib: 0,
                            linkedSmtId: b.linked_smt_id || null
                        };
                        newBreakers++;
                    }
                    
                    // Update linked_smt_id if present
                    if (b.linked_smt_id) {
                        breakerCache[id].linkedSmtId = b.linked_smt_id;
                    }
                    
                    // Update display_id if we get a newer one
                    if (b.display_id) {
                        breakerCache[id].displayId = b.display_id;
                    }
                    
                    // Update zone_pct
                    if (b.zone_pct !== undefined) {
                        breakerCache[id].zonePct = parseFloat(b.zone_pct) || 0;
                    }
                    
                    // Parse fib - current_fib and max_fib fields
                    const currentFib = parseFloat(b.current_fib) || 0;
                    const maxFib = parseFloat(b.max_fib) || 0;
                    
                    // Get snapshot price
                    const snapshotPrice = b.price || 0;
                    
                    // Avoid duplicate events (same timestamp)
                    if (!breakerCache[id].events.some(e => e.absMin === absMin)) {
                        breakerCache[id].events.push({ datetime, absMin, fib: currentFib, maxFib: maxFib, price: snapshotPrice });
                    }
                    breakerCache[id].currentFib = currentFib;
                    breakerCache[id].maxFib = Math.max(breakerCache[id].maxFib, maxFib);
                    
                    // Update status if present (new format: SUCCESS_T1, SUCCESS_T2_TERMINATED, FAILURE_TERMINATED, etc.)
                    if (b.status) {
                        const upperStatus = b.status.toUpperCase();
                        if (upperStatus !== 'ACTIVE') {
                            breakerCache[id].status = b.status;
                            
                            // Track T1 and T2 milestone times
                            if (upperStatus.startsWith('SUCCESS_T1') && !breakerCache[id].t1Time) {
                                breakerCache[id].t1Time = absMin;
                            }
                            if (upperStatus.startsWith('SUCCESS_T2') && !breakerCache[id].t2Time) {
                                // Also set T1 time if not already set (T2 implies T1 was reached)
                                if (!breakerCache[id].t1Time) {
                                    breakerCache[id].t1Time = absMin;
                                }
                                breakerCache[id].t2Time = absMin;
                            }
                        }
                    }
                });
            });
            
            // Update window to include new data
            // In live mode, keep window size fixed and slide it, extending to current time
            if (isLive) {
                const now = new Date();
                const nowMin = Math.floor(now.getTime() / 60000);
                const windowSize = windowEndMin - windowStartMin;
                // Extend to current time if ahead of latest data
                windowEndMin = Math.max(dataMaxTime, nowMin);
                windowStartMin = Math.max(dataMinTime, windowEndMin - windowSize);
            } else {
                windowEndMin = dataMaxTime;
            }
            setWindow(windowStartMin, windowEndMin, 'Latest');
            
            finalizeBreakers();
            
            showToast(`+${snapshotList.length} snapshots, ${newBreakers} new breakers`, 'success');
        }
        
        // Prune data outside retention window to prevent memory growth
        function pruneOldData() {
            if (dataMaxTime === 0) return;
            
            // Use load limit + 30 min buffer as retention window
            const loadHours = getLoadHours();
            const retentionMinutes = (loadHours * 60) + 30;
            const cutoffMin = dataMaxTime - retentionMinutes;
            
            console.log(`📊 Prune check: retention=${loadHours}h, cutoff=${minToDateTime(cutoffMin)}, maxTime=${minToDateTime(dataMaxTime)}`);
            
            let pruned = 0;
            
            for (const id in breakerCache) {
                const breaker = breakerCache[id];
                // Remove breakers that ended before the cutoff
                if (breaker.endMin && breaker.endMin < cutoffMin) {
                    delete breakerCache[id];
                    pruned++;
                }
            }
            
            // Update dataMinTime
            if (pruned > 0) {
                const remaining = Object.values(breakerCache);
                if (remaining.length > 0) {
                    dataMinTime = Math.min(...remaining.map(d => d.startMin || d.events[0]?.absMin || dataMaxTime));
                }
            }
        }
        
        // Parse confirmation time from breaker ID
        // Format: ES-15m-260120T1000-260121T0715-6865-24p-S
        //                            ^^^^^^^^^^^^^ confirmation time
        function parseConfirmationTime(breakerId) {
            const parts = breakerId.split('-');
            // parts: [asset, tf, formationTime, confirmationTime, price, range, dir]
            if (parts.length >= 4) {
                const confTime = parts[3]; // e.g. "260121T0715"
                // Parse: YYMMDDTHHMM
                const match = confTime.match(/^(\d{2})(\d{2})(\d{2})T(\d{2})(\d{2})$/);
                if (match) {
                    const [_, yy, mm, dd, hh, min] = match;
                    const year = 2000 + parseInt(yy);
                    const month = parseInt(mm);
                    const day = parseInt(dd);
                    const hour = parseInt(hh);
                    const minute = parseInt(min);
                    // Convert to absolute minutes
                    return datetimeToMin(`${year}-${String(month).padStart(2,'0')}-${String(day).padStart(2,'0')}T${String(hour).padStart(2,'0')}:${String(minute).padStart(2,'0')}`);
                }
            }
            return null;
        }
        
        function finalizeBreakers() {
            
            // First, set startMin/endMin on all breakers in cache
            for (const id in breakerCache) {
                const d = breakerCache[id];
                if (d.events.length > 0) {
                    d.events.sort((a, b) => a.absMin - b.absMin);
                    
                    // Try to get confirmation time from breaker ID
                    const confirmMin = parseConfirmationTime(id);
                    if (confirmMin) {
                        d.startMin = confirmMin;
                    } else {
                        // Fallback to first observation
                        d.startMin = d.events[0]?.absMin || 0;
                    }
                    d.endMin = d.events[d.events.length - 1]?.absMin || 0;
                    
                    // Ensure startMin <= endMin
                    if (d.startMin > d.endMin) {
                        d.endMin = d.startMin;
                    }
                }
            }
            
            const beforePrune = Object.keys(breakerCache).length;
            
            // Prune old data (needs endMin to be set first)
            pruneOldData();
            
            const afterPrune = Object.keys(breakerCache).length;
            if (beforePrune !== afterPrune) {
                console.log(`📊 Pruned ${beforePrune - afterPrune} old breakers`);
            }
            
            allData = Object.values(breakerCache);
            allData.forEach(d => {
                // Limit events per breaker to prevent huge fib charts
                if (d.events.length > 500) {
                    d.events = d.events.slice(-500);
                }
                // Use symbol from cache (parsed from ID during load)
                if (!d.symbol) {
                    d.symbol = d.id.toUpperCase().includes('NQ') ? 'NQ' : 'ES';
                }
            });
            
            // Extract 1M NQ Bull entry times
            entryTimes = allData
                .filter(d => d.symbol === 'NQ' && d.tf === '1m' && d.dir === 'bull')
                .map(d => d.startMin);
            
            updateStats();
            renderChart();
            
            // Refresh confluence modal if open
            if (confluenceModalOpen) {
                // Save scroll position before re-rendering
                const scroll = document.getElementById('confluence-scroll');
                const savedScrollLeft = scroll ? scroll.scrollLeft : 0;
                
                renderConfluenceModal();
                
                // Restore scroll position (or scroll to end in live mode on first load only)
                setTimeout(() => {
                    const scrollEl = document.getElementById('confluence-scroll');
                    if (scrollEl) {
                        scrollEl.scrollLeft = savedScrollLeft;
                    }
                }, 10);
            }
            
            // In live mode: always scroll to latest and show live confluence
            // In explore mode: only scroll on first load
            if (isLive || isFirstLoad) {
                setTimeout(() => {
                    const container = document.getElementById('scroll-container');
                    container.scrollLeft = container.scrollWidth;
                    updateViewportIndicator();
                    // Update cursor position after scroll
                    if (isLive) {
                        updateMainCursor();
                    }
                    // Only show live confluence if nothing selected/locked
                    if (isLive && lockedConfluenceMin === null && !selectedBreakerId && !selectedSmtId) {
                        showLiveConfluence();
                    }
                }, 50);
                isFirstLoad = false;
            }
        }
        
        // ===== STATUS PARSING =====
        // Parse new status format: ACTIVE, SUCCESS_T1, SUCCESS_T1_TERMINATED, SUCCESS_T2_TERMINATED, FAILURE_TERMINATED
        function parseStatus(status) {
            if (!status) return { icon: '-', cssClass: 'none', isSuccess: false, isFail: false, isTerminated: false };
            
            const s = status.toUpperCase();
            
            // Handle legacy 'success' format
            if (s === 'SUCCESS') {
                return { icon: 'T2', cssClass: 'success', isSuccess: true, isFail: false, isTerminated: true };
            }
            
            // SUCCESS_T2_TERMINATED - full win
            if (s.startsWith('SUCCESS_T2')) {
                return { icon: 'T2', cssClass: 'success', isSuccess: true, isFail: false, isTerminated: true };
            }
            
            // SUCCESS_T1_TERMINATED - partial win (hit T1, stopped before T2)
            if (s === 'SUCCESS_T1_TERMINATED' || s.startsWith('SUCCESS_T1_TERMINATED:')) {
                return { icon: 'T1', cssClass: 'success', isSuccess: true, isFail: false, isTerminated: true };
            }
            
            // SUCCESS_T1 - hit T1 milestone, still tracking toward T2
            if (s === 'SUCCESS_T1') {
                return { icon: 'T1', cssClass: 'success', isSuccess: true, isFail: false, isTerminated: false };
            }
            
            // FAILURE_TERMINATED - terminated before T1
            if (s.startsWith('FAILURE_TERMINATED') || s.startsWith('FAILED:')) {
                const reason = s.includes(':') ? s.split(':')[1] : '';
                return { icon: 'F', cssClass: 'fail', isSuccess: false, isFail: true, isTerminated: true, reason };
            }
            
            // ACTIVE - still monitoring
            if (s === 'ACTIVE') {
                return { icon: '-', cssClass: 'active', isSuccess: false, isFail: false, isTerminated: false };
            }
            
            // Unknown/default
            return { icon: '-', cssClass: 'none', isSuccess: false, isFail: false, isTerminated: false };
        }
        
        // ===== STATS =====
        function updateStats() {
            // Calculate overall stats (NQ Bull 1M only - the primary trading signal)
            const primary = { success: 0, fail: 0 };
            
            // Calculate stats per tf/symbol/direction
            laneStats = {};
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    ['bull', 'bear'].forEach(dir => {
                        laneStats[`${tf}-${symbol}-${dir}`] = { success: 0, fail: 0 };
                    });
                });
            });
            
            allData.forEach(d => {
                const parsed = parseStatus(d.status);
                const tf = d.tf.replace('hr', 'h');
                const key = `${tf}-${d.symbol}-${d.dir}`;
                
                // Primary stats: NQ Bull 1M only
                if (tf === '1m' && d.symbol === 'NQ' && d.dir === 'bull') {
                    if (parsed.isSuccess && parsed.isTerminated) primary.success++;
                    else if (parsed.isFail) primary.fail++;
                }
                
                // Per-lane stats
                if (laneStats[key]) {
                    if (parsed.isSuccess && parsed.isTerminated) laneStats[key].success++;
                    else if (parsed.isFail) laneStats[key].fail++;
                }
            });
            
            const completed = primary.success + primary.fail;
            const winRate = completed > 0 ? Math.round(primary.success / completed * 100) : 0;
            
            document.getElementById('stat-success').textContent = primary.success;
            document.getElementById('stat-fail').textContent = primary.fail;
            document.getElementById('stat-winrate').textContent = winRate + '%';
        }
        
        function getLaneStats(tf, symbol, dir) {
            const key = `${tf}-${symbol}-${dir}`;
            const stats = laneStats[key] || { success: 0, fail: 0 };
            const total = stats.success + stats.fail;
            const pct = total > 0 ? Math.round(stats.success / total * 100) : 0;
            return { wins: stats.success, losses: stats.fail, total, pct };
        }
        
        // ===== RENDERING =====
        function renderChart() {
            // Clean up previous event listeners
            if (chartAbortController) {
                chartAbortController.abort();
                chartAbortController = null;
            }
            chartAbortController = new AbortController();
            const signal = chartAbortController.signal;
            
            const leftPanel = document.getElementById('left-panel');
            const chartInner = document.getElementById('chart-inner');
            const timeHeader = document.getElementById('time-header');
            
            leftPanel.innerHTML = '';
            chartInner.innerHTML = '';
            timeHeader.innerHTML = '';
            
            // Clear cached element arrays
            renderedBars = [];
            renderedLaneLabels = [];
            
            // Preserve selections across re-renders (both explore and live mode)
            const preservedEntryMin = selectedEntryMin;
            const preservedBreakerId = selectedBreakerId;
            const preservedSmtId = selectedSmtId;
            
            selectedEntryMin = null;
            selectedBreakerId = null;
            selectedSmtId = null;
            
            // Calculate chart width based on data, add padding for future fade effect
            const chartWidth = (windowEndMin - windowStartMin) * PIXELS_PER_MINUTE + PIXELS_PER_MINUTE;
            
            chartInner.style.width = chartWidth + 'px';
            timeHeader.style.width = chartWidth + 'px';
            
            // Time header ticks - snap to 5-minute boundaries
            const tickInterval = 5;
            const firstTick = Math.ceil(windowStartMin / tickInterval) * tickInterval;
            
            // Track dates for separators
            let lastDateKey = null;
            const dateSeparators = []; // Store positions for chart separators
            
            // For multi-day views, show date in time labels
            const loadHours = getLoadHours();
            const showDateInLabels = loadHours >= 24;
            
            for (let m = firstTick; m <= windowEndMin; m += tickInterval) {
                const x = (m - windowStartMin) * PIXELS_PER_MINUTE;
                const currentDateKey = minToDateKey(m);
                
                // Add date separator when day changes
                if (lastDateKey !== null && currentDateKey !== lastDateKey) {
                    // Store for chart vertical line
                    dateSeparators.push({ x: x, date: minToDateStr(m) });
                }
                lastDateKey = currentDateKey;
                
                const tick = document.createElement('div');
                tick.className = 'time-tick-label';
                tick.style.left = x + 'px';
                
                // Show date+time for multi-day views, just time for single day
                if (showDateInLabels) {
                    tick.textContent = minToShortDateTime(m);
                } else {
                    tick.textContent = minToTime(m);
                }
                timeHeader.appendChild(tick);
            }
            
            // Add date separators to chart (vertical lines spanning full height)
            dateSeparators.forEach(sep => {
                const line = document.createElement('div');
                line.className = 'date-separator';
                line.style.left = sep.x + 'px';
                chartInner.appendChild(line);
            });
            
            // Store date separators for sticky date calculation
            window.dateSeparatorPositions = dateSeparators;
            
            // Filter data for window
            let windowData = allData.filter(d => {
                if (d.endMin < windowStartMin || d.startMin > windowEndMin) return false;
                if (d.symbol === 'NQ' && !filters.nq) return false;
                if (d.symbol === 'ES' && !filters.es) return false;
                if (d.dir === 'bull' && !filters.bull) return false;
                if (d.dir === 'bear' && !filters.bear) return false;
                return true;
            });
            
            // Limit total bars to prevent browser crash (prioritize recent)
            const MAX_BARS = 500;
            if (windowData.length > MAX_BARS) {
                windowData.sort((a, b) => b.endMin - a.endMin);
                windowData = windowData.slice(0, MAX_BARS);
            }
            
            // Group by TF → Symbol
            const grouped = {};
            TF_ORDER.forEach(tf => {
                grouped[tf] = { NQ: [], ES: [] };
            });
            
            windowData.forEach(d => {
                const tf = d.tf.replace('hr', 'h');
                if (grouped[tf] && grouped[tf][d.symbol]) {
                    grouped[tf][d.symbol].push(d);
                }
            });
            
            // Determine which symbols are visible
            const visibleSymbols = SYMBOLS.filter(s => filters[s.toLowerCase()]);
            
            let totalHeight = 0;
            
            // Render TF sections
            TF_ORDER.forEach((tf, tfIndex) => {
                // TF divider spacer for left panel (matches chart divider height)
                const tfSpacer = document.createElement('div');
                tfSpacer.className = 'tf-spacer';
                tfSpacer.dataset.tf = tf;
                leftPanel.appendChild(tfSpacer);
                
                // TF divider - chart
                const tfHeaderChart = document.createElement('div');
                tfHeaderChart.className = 'tf-header-chart';
                // Width set via CSS to be viewport-based
                tfHeaderChart.dataset.tf = tf;
                chartInner.appendChild(tfHeaderChart);
                
                // TF_HEADER_HEIGHT for divider
                totalHeight += TF_HEADER_HEIGHT;
                
                // Calculate lane heights for all symbols in this TF first
                const laneHeights = {};
                let tfGroupHeight = 0;
                
                visibleSymbols.forEach((symbol, idx) => {
                    const breakers = grouped[tf][symbol];
                    const stackedBreakers = assignStackPositions(breakers);
                    const maxStack = stackedBreakers.length > 0 
                        ? Math.max(...stackedBreakers.map(b => b.stackIdx)) + 1 
                        : 1;
                    
                    // Calculate height needed for breaker stacking
                    const breakerStackHeight = LANE_PADDING * 2 + maxStack * (BAR_HEIGHT + BAR_GAP) - BAR_GAP;
                    
                    // Use the larger of left panel minimum or breaker stack needs
                    const laneHeight = Math.max(LEFT_PANEL_MIN_HEIGHT, breakerStackHeight);
                    
                    laneHeights[symbol] = laneHeight;
                    tfGroupHeight += laneHeight;
                });
                
                // Create TF group container for left panel
                const tfGroup = document.createElement('div');
                tfGroup.className = 'tf-group';
                // Height determined by children via flexbox
                tfGroup.dataset.tf = tf;
                
                // TF accent bar spanning all symbols
                const tfLabel = tf.toUpperCase();
                const tfAccent = document.createElement('div');
                tfAccent.className = 'tf-group-accent';
                tfAccent.dataset.tf = tf;
                tfAccent.textContent = tfLabel;
                tfGroup.appendChild(tfAccent);
                
                // Lanes container
                const tfLanes = document.createElement('div');
                tfLanes.className = 'tf-group-lanes';
                
                // Symbol lanes within this TF
                visibleSymbols.forEach((symbol, symbolIdx) => {
                    const breakers = grouped[tf][symbol];
                    const stackedBreakers = assignStackPositions(breakers);
                    const laneHeight = laneHeights[symbol];
                    
                    // Get stats for this lane
                    const bullStats = getLaneStats(tf, symbol, 'bull');
                    const bearStats = getLaneStats(tf, symbol, 'bear');
                    
                    // Lane row
                    const laneRow = document.createElement('div');
                    laneRow.className = 'lane-row';
                    // Only set explicit height if breakers need more than minimum
                    if (laneHeight > LEFT_PANEL_MIN_HEIGHT) {
                        laneRow.style.height = laneHeight + 'px';
                    }
                    laneRow.dataset.tf = tf;
                    laneRow.dataset.symbol = symbol;
                    
                    // Horizontal layout: symbol left, stats right
                    laneRow.innerHTML = `
                        <span class="symbol-badge ${symbol.toLowerCase()}">${symbol}</span>
                        <div class="lane-stats">
                            <div class="lane-stat-row">
                                <span class="lane-stat-dir bull"></span>
                                <span class="lane-stat-counts">${bullStats.wins}/${bullStats.losses}</span>
                                <div class="lane-stat-bar">
                                    <div class="lane-stat-fill bull" style="width: ${bullStats.pct}%"></div>
                                </div>
                                <span class="lane-stat-pct ${bullStats.total > 0 ? 'bull' : 'neutral'}">${bullStats.total > 0 ? bullStats.pct + '%' : '-'}</span>
                            </div>
                            <div class="lane-stat-row">
                                <span class="lane-stat-dir bear"></span>
                                <span class="lane-stat-counts">${bearStats.wins}/${bearStats.losses}</span>
                                <div class="lane-stat-bar">
                                    <div class="lane-stat-fill bear" style="width: ${bearStats.pct}%"></div>
                                </div>
                                <span class="lane-stat-pct ${bearStats.total > 0 ? 'bear' : 'neutral'}">${bearStats.total > 0 ? bearStats.pct + '%' : '-'}</span>
                            </div>
                        </div>
                    `;
                    
                    tfLanes.appendChild(laneRow);
                    
                    // Cache lane row for highlighting
                    renderedLaneLabels.push({ el: laneRow, tf: tf, symbol: symbol });
                    
                    // Swimlane
                    const swimlane = document.createElement('div');
                    swimlane.className = 'swimlane';
                    swimlane.style.width = chartWidth + 'px';
                    // Only set explicit height if breakers need more than minimum
                    if (laneHeight > LEFT_PANEL_MIN_HEIGHT) {
                        swimlane.style.height = laneHeight + 'px';
                    }
                    swimlane.dataset.symbol = symbol;
                    swimlane.dataset.tf = tf;
                    
                    // Render breaker bars with stacking
                    stackedBreakers.forEach(b => {
                        const bar = createBreakerBar(b, laneHeight);
                        swimlane.appendChild(bar);
                        // Cache bar with its time data for fast highlight
                        renderedBars.push({
                            el: bar,
                            startMin: b.startMin,
                            endMin: b.endMin,
                            tf: tf,
                            symbol: symbol
                        });
                        
                        // Trade tabs - show for all breakers with trades
                        const trade = getTradeForBreaker(b.id);
                        if (trade) {
                            const barStartX = Math.max(0, (b.startMin - windowStartMin) * PIXELS_PER_MINUTE);
                            const barEndX = (b.endMin - windowStartMin) * PIXELS_PER_MINUTE;
                            const barTop = LANE_PADDING + b.stackIdx * (BAR_HEIGHT + BAR_GAP);
                            
                            // NEW SCHEMA ONLY
                            const decision = trade.status?.decision || '';
                            const phase = trade.status?.phase || '';
                            const tradeOutcome = trade.outcomes?.trade_outcome || '';
                            const displayCloseReason = getDisplayCloseReason(trade);
                            
                            const isFiltered = decision === 'FILTERED';
                            const wasFilled = trade.events?.some(e => e.event === 'FILLED') || false;
                            
                            // Left tab - entry state
                            const leftTab = document.createElement('div');
                            leftTab.className = 'trade-tab trade-tab-left';
                            leftTab.style.left = (barStartX - 30) + 'px';
                            leftTab.style.top = barTop + 'px';
                            
                            if (isFiltered) {
                                leftTab.classList.add('denied');
                                leftTab.textContent = 'D';
                                leftTab.title = displayCloseReason || 'Filtered';
                            } else if (phase === 'PENDING') {
                                leftTab.classList.add('pending');
                                leftTab.textContent = 'P';
                                leftTab.title = 'Pending Entry';
                            } else if (phase === 'FILLED' || phase === 'CLOSED') {
                                leftTab.classList.add('filled');
                                leftTab.textContent = 'F';
                                leftTab.title = 'Filled';
                            } else {
                                leftTab.classList.add('pending');
                                leftTab.textContent = 'P';
                                leftTab.title = 'Pending';
                            }
                            
                            leftTab.addEventListener('click', (e) => {
                                e.stopPropagation();
                                showTradeModal(trade);
                            });
                            swimlane.appendChild(leftTab);
                            
                            // Right tab - exit state (for closed trades)
                            if (phase === 'CLOSED') {
                                const rightTab = document.createElement('div');
                                rightTab.className = 'trade-tab trade-tab-right';
                                rightTab.style.left = barEndX + 'px';
                                rightTab.style.top = barTop + 'px';
                                
                                // Derive win/loss from pnl_points
                                const pnlPts = trade.outcomes?.close_details?.pnl_points;
                                
                                if (isFiltered) {
                                    rightTab.classList.add('denied');
                                    rightTab.textContent = 'D';
                                    rightTab.title = displayCloseReason || 'Filtered';
                                } else if (pnlPts !== undefined) {
                                    // Use P&L to determine win/loss
                                    const isWin = pnlPts >= 0;
                                    rightTab.classList.add(isWin ? 'win' : 'loss');
                                    rightTab.textContent = isWin ? 'W' : 'L';
                                    rightTab.title = `${isWin ? 'Win' : 'Loss'} - ${displayCloseReason} (${pnlPts >= 0 ? '+' : ''}${pnlPts.toFixed(1)})`;
                                } else if (tradeOutcome === 'CANCELLED') {
                                    rightTab.classList.add('cancelled');
                                    rightTab.textContent = 'C';
                                    rightTab.title = 'Cancelled - ' + displayCloseReason;
                                } else {
                                    rightTab.classList.add('cancelled');
                                    rightTab.textContent = 'C';
                                    rightTab.title = displayCloseReason || 'Closed';
                                }
                                
                                rightTab.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    showTradeModal(trade);
                                });
                                swimlane.appendChild(rightTab);
                            }
                        }
                    });
                    
                    // Render SMT markers in defensive asset lane
                    const tfNorm = tf.replace('hr', 'h').toLowerCase();
                    const smtForLane = smtData.filter(smt => {
                        const smtTfNorm = smt.tf.replace('m', 'm').replace('h', 'h').toLowerCase();
                        return smtTfNorm === tfNorm && 
                               smt.defensiveAsset === symbol &&
                               smt.smtMin >= windowStartMin && 
                               smt.smtMin <= windowEndMin;
                    });
                    
                    smtForLane.forEach(smt => {
                        const marker = createSmtMarker(smt, 0, laneHeight);
                        swimlane.appendChild(marker);
                    });
                    
                    chartInner.appendChild(swimlane);
                    totalHeight += laneHeight;
                });
                
                tfGroup.appendChild(tfLanes);
                leftPanel.appendChild(tfGroup);
            });
            
            // Render entry lines spanning full chart height
            // Subtract a few pixels for perfect alignment
            totalHeight -= 3;
            
            const windowEntries = entryTimes
                .filter(t => t >= windowStartMin && t <= windowEndMin)
                .slice(-100); // Limit entry lines
            
            windowEntries.forEach(entryMin => {
                const x = (entryMin - windowStartMin) * PIXELS_PER_MINUTE;
                
                // Entry line in chart
                const entryLine = document.createElement('div');
                entryLine.className = 'entry-line';
                entryLine.style.left = x + 'px';
                entryLine.dataset.entryMin = entryMin;
                entryLine.title = 'Entry: ' + minToTime(entryMin);
                entryLine.onclick = () => selectEntry(entryMin);
                chartInner.appendChild(entryLine);
            });
            
            // Add cursor line
            const cursorLine = document.createElement('div');
            cursorLine.className = 'cursor-line';
            cursorLine.id = 'cursor-line';
            chartInner.appendChild(cursorLine);
            
            // Add click cursor line (solid yellow on click)
            const clickCursorLine = document.createElement('div');
            clickCursorLine.className = 'click-cursor-line';
            clickCursorLine.id = 'click-cursor-line';
            chartInner.appendChild(clickCursorLine);
            
            // Set chart inner height so absolute positioned elements span correctly
            chartInner.style.height = totalHeight + 'px';
            
            // Add cursor time tooltip to body (so it's not clipped)
            let cursorTime = document.getElementById('cursor-time');
            if (!cursorTime) {
                cursorTime = document.createElement('div');
                cursorTime.className = 'cursor-time';
                cursorTime.id = 'cursor-time';
                document.body.appendChild(cursorTime);
            }
            
            // Cursor line event handlers on scroll container
            const scrollContainer = document.getElementById('scroll-container');
            let lastClientX = null;
            let lastCursorMin = null;
            let cursorUpdatePending = false;
            
            function updateCursorPosition(clientX, isScroll = false) {
                const scrollRect = scrollContainer.getBoundingClientRect();
                const leftPanelWidth = 195; // matches .left-panel width
                
                // Check if mouse is actually over the chart area (not left panel)
                const mouseOverChart = clientX > scrollRect.left + leftPanelWidth;
                
                const x = clientX - scrollRect.left - leftPanelWidth + scrollContainer.scrollLeft;
                if (mouseOverChart && x >= 0 && x <= chartWidth) {
                    cursorLine.style.left = x + 'px';
                    cursorLine.classList.add('visible');
                    cursorLine.classList.remove('live-cursor'); // Switch from live to user cursor
                    
                    // Calculate cursor time
                    const cursorMin = Math.round(windowStartMin + x / PIXELS_PER_MINUTE);
                    
                    // Always update tooltip position
                    cursorTime.textContent = minToTime(cursorMin);
                    cursorTime.style.display = 'block';
                    cursorTime.style.left = (clientX - 30) + 'px';
                    cursorTime.style.top = (scrollRect.top - 30) + 'px';
                    
                    // Only update panel and highlights if cursor minute changed
                    // Skip heavy operations during scroll - only update on mousemove
                    if (cursorMin !== lastCursorMin && !isScroll) {
                        lastCursorMin = cursorMin;
                        
                        // Show confluence at cursor position in right panel (only if not locked and no selection)
                        if (lockedConfluenceMin === null && !selectedSmtId && !selectedBreakerId) {
                            showCursorConfluence(cursorMin);
                        }
                        
                        // Highlight bars at cursor (yellow)
                        highlightCursorActive(cursorMin);
                    }
                } else {
                    cursorLine.classList.remove('visible');
                    cursorTime.style.display = 'none';
                    
                    // Clear cursor highlights when leaving chart area
                    if (!isScroll) {
                        clearCursorHighlight();
                    }
                }
            }
            
            scrollContainer.addEventListener('mousemove', (e) => {
                lastClientX = e.clientX;
                updateCursorPosition(e.clientX, false);
            }, { signal });
            
            scrollContainer.addEventListener('scroll', () => {
                if (lastClientX !== null && !cursorUpdatePending) {
                    cursorUpdatePending = true;
                    requestAnimationFrame(() => {
                        updateCursorPosition(lastClientX, true);
                        cursorUpdatePending = false;
                    });
                }
            }, { signal });
            
            scrollContainer.addEventListener('mouseleave', () => {
                lastClientX = null;
                cursorLine.classList.remove('visible');
                cursorTime.style.display = 'none';
                
                // Clear cursor highlights
                clearCursorHighlight();
                
                // Restore appropriate panel state
                if (selectedBreakerId) {
                    // Keep breaker detail view
                    showBreakerDetail(selectedBreakerId);
                } else if (lockedConfluenceMin !== null) {
                    // Keep locked confluence view
                    showCursorConfluence(lockedConfluenceMin);
                } else if (selectedSmtId) {
                    showSmtDetail(selectedSmtId);
                } else if (isLive) {
                    showLiveConfluence();
                } else {
                    showEmptyPanel();
                }
            }, { signal });
            
            // Click on chart to select time (but not on breakers or entry lines)
            chartInner.addEventListener('click', (e) => {
                // Only handle clicks directly on chart or swimlanes
                if (e.target.classList.contains('breaker-bar') || 
                    e.target.classList.contains('entry-line') ||
                    e.target.classList.contains('smt-marker') ||
                    e.target.closest('.breaker-bar') ||
                    e.target.closest('.entry-line') ||
                    e.target.closest('.smt-marker')) {
                    return;
                }
                
                const rect = chartInner.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const clickedMin = Math.round(windowStartMin + x / PIXELS_PER_MINUTE);
                selectTimeContext(clickedMin);
            }, { signal });
            
            // Update scroll listener
            const container = document.getElementById('scroll-container');
            container.removeEventListener('scroll', onScroll);
            container.addEventListener('scroll', onScroll, { signal });
            
            // Setup viewport drag handlers
            setupViewportHandlers();
            
            // Restore selections (both explore and live mode)
            if (preservedBreakerId) {
                selectedBreakerId = preservedBreakerId;
                document.querySelectorAll(`.breaker-bar[data-breaker-id="${preservedBreakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                // Show breaker detail panel
                showBreakerDetail(preservedBreakerId);
            } else if (lockedConfluenceMin !== null) {
                highlightActiveAtEntry(lockedConfluenceMin);
                showCursorConfluence(lockedConfluenceMin);
                // Restore click cursor line position
                const clickCursorLine = document.getElementById('click-cursor-line');
                if (clickCursorLine) {
                    const xPos = (lockedConfluenceMin - windowStartMin) * PIXELS_PER_MINUTE;
                    clickCursorLine.style.left = xPos + 'px';
                    clickCursorLine.classList.add('visible');
                }
            } else if (preservedEntryMin) {
                selectedEntryMin = preservedEntryMin;
                lockedConfluenceMin = preservedEntryMin;
                highlightActiveAtEntry(preservedEntryMin);
                showCursorConfluence(preservedEntryMin);
                // Highlight entry line and markers if they exist
                document.querySelectorAll('.entry-line').forEach(el => {
                    if (parseInt(el.dataset.entryMin) === preservedEntryMin) {
                        el.classList.add('selected');
                    }
                });
            } else if (preservedSmtId) {
                selectedSmtId = preservedSmtId;
                document.querySelectorAll(`.smt-marker[data-smt-id="${preservedSmtId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                showSmtDetail(preservedSmtId);
            } else if (isLive) {
                // In live mode, show current confluence
                showLiveConfluence();
            } else {
                // In explore mode with no selection, show empty panel
                clearEntryHighlight();
                showEmptyPanel();
            }
            
            // Update viewport indicator after DOM is ready
            setTimeout(updateViewportIndicator, 50);
            
            // Start main chart live cursor in live mode
            if (isLive) {
                startMainCursor();
            }
        }
        
        // Main chart live cursor
        function startMainCursor() {
            if (mainCursorInterval) {
                clearInterval(mainCursorInterval);
            }
            updateMainCursor();
            // Update every 200ms for smoother tracking
            mainCursorInterval = setInterval(updateMainCursor, 200);
        }
        
        function updateMainCursor() {
            const cursorLine = document.getElementById('main-cursor-line');
            const cursorTime = document.getElementById('main-cursor-time');
            
            if (!isLive) {
                if (cursorLine) cursorLine.classList.remove('visible');
                if (cursorTime) cursorTime.style.display = 'none';
                return;
            }
            
            const container = document.getElementById('scroll-container');
            if (!container || !cursorLine || !cursorTime) return;
            
            const now = new Date();
            const currentMin = Math.floor(now.getTime() / 60000);
            
            // Calculate chart X position for current time
            const leftPanelWidth = 195;
            const chartX = (currentMin - windowStartMin) * PIXELS_PER_MINUTE;
            
            // Position within scroll-container (absolute)
            const posX = chartX + leftPanelWidth;
            
            // Show cursor if current time is within window range
            if (currentMin >= windowStartMin && currentMin <= windowEndMin) {
                // Cursor line - absolute position in scroll-container
                cursorLine.style.left = posX + 'px';
                cursorLine.classList.add('visible');
                
                // Check if visible in viewport for time badge
                const scrollLeft = container.scrollLeft;
                const containerWidth = container.clientWidth;
                const visibleX = posX - scrollLeft;
                
                if (visibleX >= leftPanelWidth && visibleX <= containerWidth) {
                    // Time badge - fixed position above chart
                    const scrollRect = container.getBoundingClientRect();
                    cursorTime.textContent = minToTime(currentMin);
                    cursorTime.style.display = 'block';
                    cursorTime.style.left = (scrollRect.left + visibleX - 30) + 'px';
                    cursorTime.style.top = (scrollRect.top - 30) + 'px';
                } else {
                    cursorTime.style.display = 'none';
                }
            } else {
                cursorLine.classList.remove('visible');
                cursorTime.style.display = 'none';
            }
        }
        
        // ===== SMT DATA LOADING =====
        function loadSmtData(incremental = false) {
            return fetch(SMT_FIREBASE_URL)
                .then(r => r.json())
                .then(data => {
                    console.log('📊 SMT Data Load - Raw response:', data ? Object.keys(data).length + ' records' : 'null/empty');
                    
                    if (!data) {
                        console.warn('📊 SMT: No data returned from Firebase');
                        if (!incremental) smtData = [];
                        return;
                    }
                    
                    // For full load, clear cache
                    if (!incremental) {
                        smtData = [];
                        smtCache = {};
                    }
                    
                    const errors = [];
                    let newCount = 0;
                    let updatedCount = 0;
                    let validationFailCount = 0;
                    
                    Object.entries(data).forEach(([key, smt]) => {
                        // STRICT VALIDATION - all fields required
                        const missing = [];
                        if (!smt.smt_id) missing.push('smt_id');
                        if (!smt.dir) missing.push('dir');
                        if (!smt.tf) missing.push('tf');
                        if (!smt.smt_time) missing.push('smt_time');
                        if (!smt.last_detected) missing.push('last_detected');
                        if (!smt.methods) missing.push('methods');
                        if (smt.strength === undefined) missing.push('strength');
                        if (!smt.roles) missing.push('roles');
                        if (!smt.es) missing.push('es');
                        if (!smt.nq) missing.push('nq');
                        if (!smt.criteria) missing.push('criteria');
                        if (smt.quality === undefined) missing.push('quality');
                        if (!smt.status) missing.push('status');
                        
                        if (missing.length > 0) {
                            errors.push(`${key}: Missing fields: ${missing.join(', ')}`);
                            validationFailCount++;
                            if (validationFailCount <= 3) {
                                console.warn('📊 SMT Validation fail (top-level):', key, missing);
                            }
                            return;
                        }
                        
                        // Validate nested required fields
                        const nestedMissing = [];
                        if (!smt.roles.defensive) nestedMissing.push('roles.defensive');
                        if (!smt.roles.sweep) nestedMissing.push('roles.sweep');
                        if (smt.es.prev_price === undefined) nestedMissing.push('es.prev_price');
                        if (smt.es.curr_price === undefined) nestedMissing.push('es.curr_price');
                        if (!smt.es.structure) nestedMissing.push('es.structure');
                        if (!smt.es.prev_time) nestedMissing.push('es.prev_time');
                        if (!smt.es.curr_time) nestedMissing.push('es.curr_time');
                        if (smt.nq.prev_price === undefined) nestedMissing.push('nq.prev_price');
                        if (smt.nq.curr_price === undefined) nestedMissing.push('nq.curr_price');
                        if (!smt.nq.structure) nestedMissing.push('nq.structure');
                        if (!smt.nq.prev_time) nestedMissing.push('nq.prev_time');
                        if (!smt.nq.curr_time) nestedMissing.push('nq.curr_time');
                        
                        // Validate criteria fields
                        if (smt.criteria.is_sync === undefined) nestedMissing.push('criteria.is_sync');
                        if (smt.criteria.sweep_magnitude_ok === undefined) nestedMissing.push('criteria.sweep_magnitude_ok');
                        if (smt.criteria.defensive_held === undefined) nestedMissing.push('criteria.defensive_held');
                        
                        if (nestedMissing.length > 0) {
                            errors.push(`${key}: Missing nested fields: ${nestedMissing.join(', ')}`);
                            validationFailCount++;
                            if (validationFailCount <= 3) {
                                console.warn('📊 SMT Validation fail (nested):', key, nestedMissing);
                            }
                            return;
                        }
                        
                        // For incremental updates, skip if unchanged
                        if (incremental && smtCache[smt.smt_id]) {
                            const cached = smtCache[smt.smt_id];
                            if (cached.lastDetected === smt.last_detected && cached.status === smt.status) {
                                return;
                            }
                        }
                        
                        // Parse smt_time to minutes
                        const smtMin = datetimeToMin(smt.smt_time);
                        if (isNaN(smtMin)) {
                            errors.push(`${key}: Invalid smt_time format: ${smt.smt_time}`);
                            return;
                        }
                        
                        // Normalize direction: L/long/bull → 'bull', S/short/bear → 'bear'
                        let rawDir = (smt.dir || '').toLowerCase();
                        if (!rawDir && smt.smt_id) {
                            const lastChar = smt.smt_id.slice(-1).toLowerCase();
                            rawDir = lastChar;
                        }
                        const normalizedDir = (rawDir === 'l' || rawDir === 'long' || rawDir === 'bull' || rawDir === 'bullish') ? 'bull' : 'bear';
                        
                        const parsed = {
                            id: key,
                            smtId: smt.smt_id,
                            dir: normalizedDir,
                            tf: smt.tf.toLowerCase(),
                            smtTime: smt.smt_time,
                            smtMin: smtMin,
                            barIndex: smt.bar_index || 0,
                            lastDetected: smt.last_detected,
                            
                            // Methods and strength
                            methods: smt.methods,
                            strength: smt.strength,
                            
                            // Roles
                            defensiveAsset: smt.roles.defensive,
                            sweepAsset: smt.roles.sweep,
                            leadingAsset: smt.roles.leading || smt.roles.defensive,
                            
                            // ES swing data
                            es: {
                                prevPrice: smt.es.prev_price,
                                currPrice: smt.es.curr_price,
                                structure: smt.es.structure,
                                prevTime: smt.es.prev_time,
                                currTime: smt.es.curr_time
                            },
                            
                            // NQ swing data
                            nq: {
                                prevPrice: smt.nq.prev_price,
                                currPrice: smt.nq.curr_price,
                                structure: smt.nq.structure,
                                prevTime: smt.nq.prev_time,
                                currTime: smt.nq.curr_time
                            },
                            
                            // Criteria
                            criteria: {
                                sweptLevel: smt.criteria.swept_level || null,
                                isDaily: smt.criteria.is_daily || false,
                                isWeekly: smt.criteria.is_weekly || false,
                                isMidnight: smt.criteria.is_midnight || false,
                                isSession: smt.criteria.is_session || false,
                                isHtf: smt.criteria.is_htf || false,
                                isSync: smt.criteria.is_sync,
                                sweepMagnitudeOk: smt.criteria.sweep_magnitude_ok,
                                defensiveHeld: smt.criteria.defensive_held
                            },
                            
                            // Quality score (0-10)
                            quality: smt.quality,
                            
                            // Status
                            status: smt.status
                        };
                        
                        // For incremental updates, update or add
                        if (incremental) {
                            const existingIdx = smtData.findIndex(s => s.smtId === parsed.smtId);
                            if (existingIdx >= 0) {
                                smtData[existingIdx] = parsed;
                                updatedCount++;
                            } else {
                                smtData.push(parsed);
                                newCount++;
                            }
                        } else {
                            smtData.push(parsed);
                        }
                        
                        // Update cache
                        smtCache[parsed.smtId] = { lastDetected: parsed.lastDetected, status: parsed.status };
                    });
                    
                    // Log errors if any
                    if (errors.length > 0) {
                        console.warn(`📊 SMT validation errors: ${errors.length} failed, ${smtData.length} passed`);
                        if (errors.length <= 5) {
                            errors.forEach(e => console.warn('  -', e));
                        }
                    }
                    
                    // Check for duplicates
                    const smtIds = smtData.map(s => s.smtId);
                    const duplicates = smtIds.filter((id, idx) => smtIds.indexOf(id) !== idx);
                    if (duplicates.length > 0) {
                        console.warn(`📊 Duplicate SMT IDs: ${duplicates.length}`);
                    }
                    
                    if (incremental) {
                        console.log(`📊 SMT incremental: ${newCount} new, ${updatedCount} updated (total: ${smtData.length})`);
                    } else {
                        console.log(`📊 Loaded ${smtData.length} SMT signals (${validationFailCount} failed validation)`);
                    }
                    
                    lastSmtFetchTime = new Date().toISOString();
                })
                .catch(err => {
                    console.error('Error loading SMT data:', err);
                    smtData = [];
                });
        }
        
        function createSmtMarker(smt, laneTop, laneHeight) {
            const x = (smt.smtMin - windowStartMin) * PIXELS_PER_MINUTE;
            
            const marker = document.createElement('div');
            // Add status class for visual differentiation
            const statusClass = smt.status !== 'ACTIVE' ? ' smt-' + smt.status.toLowerCase() : '';
            marker.className = 'smt-marker ' + smt.dir + statusClass;
            marker.style.left = x + 'px';
            marker.style.top = laneTop + 'px';
            marker.style.height = laneHeight + 'px';
            marker.dataset.smtId = smt.smtId;
            
            // Diamond in center
            const diamond = document.createElement('div');
            diamond.className = 'smt-diamond';
            marker.appendChild(diamond);
            
            // Click handler
            marker.addEventListener('click', (e) => {
                e.stopPropagation();
                selectSmt(smt.smtId);
            });
            
            return marker;
        }
        
        let selectedSmtId = null;
        
        function selectSmt(smtId) {
            // Clear previous selections
            document.querySelectorAll('.breaker-bar.selected').forEach(el => el.classList.remove('selected'));
            document.querySelectorAll('.smt-marker.selected').forEach(el => el.classList.remove('selected'));
            clearEntryHighlight();
            selectedEntryMin = null;
            selectedBreakerId = null;
            lockedConfluenceMin = null;
            
            // Toggle selection
            if (selectedSmtId === smtId) {
                selectedSmtId = null;
                showEmptyPanel();
            } else {
                selectedSmtId = smtId;
                document.querySelectorAll(`.smt-marker[data-smt-id="${smtId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                showSmtDetail(smtId);
            }
        }
        
        function showSmtDetail(smtId) {
            const smt = smtData.find(s => s.smtId === smtId);
            if (!smt) return;
            
            const pt = document.getElementById('panel-time'); if (pt) pt.textContent = minToTime(smt.smtMin);
            document.getElementById('panel-type').textContent = 'SMT Signal';
            document.getElementById('panel-type').classList.remove('live');
            
            // Format helpers
            const formatPrice = (asset, p) => {
                if (p === null || p === undefined) return '-';
                return Math.round(p).toLocaleString('en-US');
            };
            const formatDelta = (val) => {
                if (val === null || val === undefined) return '-';
                const sign = val >= 0 ? '+' : '';
                return sign + Math.round(val).toLocaleString('en-US');
            };
            
            // Render mini chart SVG
            const renderSmtMiniChart = (type, data, asset) => {
                const prevPrice = data.prevPrice;
                const currPrice = data.currPrice;
                const prevTime = data.prevTime.split('T')[1].substring(0,5);
                const currTime = data.currTime.split('T')[1].substring(0,5);
                
                const w = 150, h = 60;
                const padL = 38, padR = 38, padT = 10, padB = 14;
                const chartW = w - padL - padR;
                const chartH = h - padT - padB;
                
                const minP = Math.min(prevPrice, currPrice);
                const maxP = Math.max(prevPrice, currPrice);
                const range = maxP - minP || 1;
                const yPad = range * 0.25;
                const yMin = minP - yPad;
                const yMax = maxP + yPad;
                
                const priceToY = (p) => padT + chartH - ((p - yMin) / (yMax - yMin)) * chartH;
                
                const x1 = padL;
                const x2 = w - padR;
                const y1 = priceToY(prevPrice);
                const y2 = priceToY(currPrice);
                
                return `
                    <svg class="smt-div-svg" viewBox="0 0 ${w} ${h}" preserveAspectRatio="xMidYMid meet">
                        <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y1}" stroke="#2a2a2e" stroke-width="1" stroke-dasharray="2,2" />
                        <line class="chart-line" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" />
                        <circle class="chart-point prev" cx="${x1}" cy="${y1}" r="3.5" />
                        <circle class="chart-point curr" cx="${x2}" cy="${y2}" r="4" />
                        <text class="price-label prev" x="${x1 - 6}" y="${y1 + 3}" text-anchor="end" font-size="10">${formatPrice(asset, prevPrice)}</text>
                        <text class="price-label curr" x="${x2 + 6}" y="${y2 + 3}" text-anchor="start" font-size="10">${formatPrice(asset, currPrice)}</text>
                        <text class="time-label" x="${x1}" y="${h - 2}" text-anchor="middle" font-size="9">${prevTime}</text>
                        <text class="time-label" x="${x2}" y="${h - 2}" text-anchor="middle" font-size="9">${currTime}</text>
                    </svg>
                `;
            };
            
            // Get sweep and defensive data
            const sweepAsset = smt.sweepAsset;
            const defAsset = smt.defensiveAsset;
            const sweepData = sweepAsset === 'NQ' ? smt.nq : smt.es;
            const defData = defAsset === 'NQ' ? smt.nq : smt.es;
            
            // Calculate price changes
            const sweepDelta = sweepData.currPrice - sweepData.prevPrice;
            const defDelta = defData.currPrice - defData.prevPrice;
            
            // Direction descriptions
            const dirLabel = smt.dir === 'bull' ? 'BULLISH' : 'BEARISH';
            const dirIcon = smt.dir === 'bull' ? '↑' : '↓';
            const expectation = smt.dir === 'bull' ? 'Expect upward move' : 'Expect downward move';
            
            // Status
            const statusClass = smt.status === 'ACTIVE' ? 'active' : 
                               smt.status === 'INVALIDATED' ? 'invalidated' : 'expired';
            
            // Quality (0-100 scale) - compute color gradient from red to dark green
            const qScore = smt.quality;
            // Color gradient: 0=red(#dc2626), 50=yellow(#fbbf24), 100=dark green(#166534)
            const getQualityColor = (score) => {
                if (score <= 50) {
                    // Red to yellow (0-50)
                    const ratio = score / 50;
                    const r = Math.round(220 - (220 - 251) * ratio);
                    const g = Math.round(38 + (191 - 38) * ratio);
                    const b = Math.round(38 + (36 - 38) * ratio);
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    // Yellow to dark green (50-100)
                    const ratio = (score - 50) / 50;
                    const r = Math.round(251 - (251 - 22) * ratio);
                    const g = Math.round(191 - (191 - 101) * ratio);
                    const b = Math.round(36 + (52 - 36) * ratio);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            };
            const qualityBgColor = getQualityColor(qScore);
            
            // Build all criteria - show checkmark for true, blank for false
            const allCriteria = [
                { label: 'Daily', ok: smt.criteria.isDaily },
                { label: 'Weekly', ok: smt.criteria.isWeekly },
                { label: 'Midnight', ok: smt.criteria.isMidnight },
                { label: 'Session', ok: smt.criteria.isSession },
                { label: 'HTF', ok: smt.criteria.isHtf },
                { label: 'Sync', ok: smt.criteria.isSync },
                { label: 'Sweep', ok: smt.criteria.sweepMagnitudeOk },
                { label: 'Held', ok: smt.criteria.defensiveHeld }
            ];
            
            // Swept level display
            const sweptLevel = smt.criteria.sweptLevel || '—';
            
            // Extract detection time from smt_time
            const smtTimeParts = smt.smtTime.split('T');
            const detectionTime = smtTimeParts[1] ? smtTimeParts[1].substring(0, 5) : '';
            
            document.getElementById('panel-content').innerHTML = `
                <!-- Status & Quality Header -->
                <div class="smt-header-row">
                    <div class="smt-status-pill ${statusClass}">${smt.status}</div>
                    <div class="smt-quality-score" style="background: ${qualityBgColor}">
                        <span class="smt-quality-num">${smt.quality.toFixed(1)}</span>
                    </div>
                </div>
                
                <!-- Direction Headline -->
                <div class="smt-direction-block ${smt.dir}">
                    <div class="smt-dir-icon">${dirIcon}</div>
                    <div class="smt-dir-info">
                        <div class="smt-dir-label">${dirLabel}</div>
                        <div class="smt-dir-expect">${expectation}</div>
                    </div>
                    <div class="smt-dir-methods">
                        ${smt.methods.map(m => `<span class="smt-method-pill">${m}</span>`).join('')}
                    </div>
                </div>
                
                <!-- The Divergence Chart -->
                <div class="detail-section">
                    <div class="smt-section-title">The Divergence ${detectionTime ? `@ ${detectionTime}` : ''}</div>
                    <div class="smt-div-chart">
                        <!-- Sweep Panel -->
                        <div class="smt-div-panel sweep">
                            <div class="smt-div-header">
                                <div class="smt-div-title">
                                    <span class="smt-div-role">Sweep</span>
                                    <span class="smt-div-asset ${sweepAsset.toLowerCase()}">${sweepAsset}</span>
                                </div>
                                <span class="smt-div-structure ${sweepData.structure}">${sweepData.structure}</span>
                            </div>
                            <div class="smt-div-chart-area">
                                ${renderSmtMiniChart('sweep', sweepData, sweepAsset)}
                            </div>
                            <div class="smt-div-delta ${sweepDelta >= 0 ? 'positive' : 'negative'}">${formatDelta(sweepDelta)}</div>
                        </div>
                        
                        <!-- VS Divider -->
                        <div class="smt-div-vs">≠</div>
                        
                        <!-- Defender Panel -->
                        <div class="smt-div-panel defender">
                            <div class="smt-div-header">
                                <div class="smt-div-title">
                                    <span class="smt-div-role">Defender</span>
                                    <span class="smt-div-asset ${defAsset.toLowerCase()}">${defAsset}</span>
                                </div>
                                <span class="smt-div-structure ${defData.structure}">${defData.structure}</span>
                            </div>
                            <div class="smt-div-chart-area">
                                ${renderSmtMiniChart('defender', defData, defAsset)}
                            </div>
                            <div class="smt-div-delta ${defDelta >= 0 ? 'positive' : 'negative'}">${formatDelta(defDelta)}</div>
                        </div>
                    </div>
                </div>
                
                <!-- Criteria - Big Rows -->
                <div class="detail-section">
                    <div class="smt-section-title">Signal Criteria ${sweptLevel !== '—' ? `<span style="float:right;color:#60a5fa;font-weight:600;font-size:11px;">Swept: ${sweptLevel}</span>` : ''}</div>
                    <div class="smt-criteria-list">
                        ${allCriteria.map(c => `
                            <div class="smt-criteria-row ${c.ok ? 'ok' : ''}">
                                <span class="smt-criteria-label">${c.label}</span>
                                <span class="smt-criteria-status">${c.ok ? '✓' : '—'}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <!-- Meta Footer -->
                <div class="smt-footer-section">
                    <div class="smt-footer-row">
                        <span class="smt-footer-label">Signal Time</span>
                        <span class="smt-footer-value time">${smt.smtTime}</span>
                    </div>
                    <div class="smt-footer-row">
                        <span class="smt-footer-label">Timeframe</span>
                        <span class="smt-footer-value tf">${smt.tf.toUpperCase()}</span>
                    </div>
                    <div class="smt-footer-row">
                        <span class="smt-footer-label">ID</span>
                        <span class="smt-footer-value id">${smt.smtId}</span>
                    </div>
                </div>
            `;
        }
        
        function createBreakerBar(b, laneHeight) {
            const startX = Math.max(0, (b.startMin - windowStartMin) * PIXELS_PER_MINUTE);
            
            // In live mode, cap active breaker end at current time
            let effectiveEndMin = b.endMin;
            if (isLive && b.status.toUpperCase() === 'ACTIVE') {
                const now = new Date();
                const currentMin = Math.floor(now.getTime() / 60000);
                effectiveEndMin = Math.min(b.endMin, currentMin);
            }
            
            const endX = (effectiveEndMin - windowStartMin) * PIXELS_PER_MINUTE;
            const barWidth = Math.max(endX - startX, 6); // minimum 6px width
            
            // Calculate vertical position - top aligned with padding
            const topOffset = LANE_PADDING + b.stackIdx * (BAR_HEIGHT + BAR_GAP);
            
            const bar = document.createElement('div');
            bar.className = 'breaker-bar ' + b.symbol.toLowerCase() + ' ' + b.dir;
            
            if (b.status.toUpperCase() !== 'ACTIVE') {
                bar.classList.add('completed');
            }
            
            // Add SMT linked class and indicator
            if (b.linkedSmtId) {
                bar.classList.add('has-smt');
                
                const smtIndicator = document.createElement('div');
                smtIndicator.className = 'smt-link-indicator';
                smtIndicator.textContent = 'SMT';
                smtIndicator.title = 'Linked SMT: ' + b.linkedSmtId;
                bar.appendChild(smtIndicator);
            }
            
            bar.style.left = startX + 'px';
            bar.style.width = barWidth + 'px';
            bar.style.top = topOffset + 'px';
            bar.style.height = BAR_HEIGHT + 'px';
            bar.dataset.breakerId = b.id;
            bar.dataset.startMin = b.startMin;
            bar.dataset.endMin = b.endMin;
            
            // Right-side container for fib and status
            const rightGroup = document.createElement('div');
            rightGroup.className = 'bar-right-group';
            
            // Show fib on wider bars (right side, before status) - currentFib/maxFib and points
            if (barWidth > 40) {
                const fibSpan = document.createElement('span');
                fibSpan.className = 'bar-fib';
                
                const currFib = (b.currentFib || b.maxFib || 0).toFixed(1);
                const maxFib = (b.maxFib || 0).toFixed(1);
                const fibRange = b.fibRange || 0;
                
                // Fib text
                const fibText = document.createElement('span');
                fibText.className = 'bar-fib-value';
                fibText.textContent = `${currFib}/${maxFib}`;
                fibSpan.appendChild(fibText);
                
                // Fib range in box
                if (fibRange > 0) {
                    const rangeBox = document.createElement('span');
                    rangeBox.className = 'bar-points';
                    rangeBox.textContent = `${fibRange}r`;
                    fibSpan.appendChild(rangeBox);
                }
                
                rightGroup.appendChild(fibSpan);
            }
            
            // Status badges - show highest milestone reached: T2 > T1, or F on failure
            if (b.t2Time) {
                // T2 reached - show T2 badge only
                const t2Dot = document.createElement('div');
                t2Dot.className = 'status-dot success';
                t2Dot.textContent = 'T2';
                rightGroup.appendChild(t2Dot);
            } else if (b.t1Time) {
                // T1 reached but not T2 - show T1 badge only
                const t1Dot = document.createElement('div');
                t1Dot.className = 'status-dot success';
                t1Dot.textContent = 'T1';
                rightGroup.appendChild(t1Dot);
            }
            
            // Failure badge
            const parsed = parseStatus(b.status);
            if (parsed.isFail) {
                const fDot = document.createElement('div');
                fDot.className = 'status-dot fail';
                fDot.textContent = 'F';
                if (parsed.reason) {
                    fDot.title = parsed.reason;
                }
                rightGroup.appendChild(fDot);
            }
            
            bar.appendChild(rightGroup);
            
            // T1 milestone marker on timeline
            if (b.t1Time && b.t1Time >= b.startMin && b.t1Time <= b.endMin) {
                const t1X = (b.t1Time - b.startMin) * PIXELS_PER_MINUTE;
                const t1Marker = document.createElement('div');
                t1Marker.className = 'milestone-marker t1';
                t1Marker.style.left = t1X + 'px';
                t1Marker.title = 'T1 reached';
                bar.appendChild(t1Marker);
            }
            
            // Click to show details
            bar.addEventListener('click', (e) => {
                e.stopPropagation();
                selectBreaker(b.id);
            });
            
            return bar;
        }
        
        // ===== DETAIL PANEL =====
        function showEmptyPanel() {
            const pt = document.getElementById('panel-time'); if (pt) pt.textContent = '';
            document.getElementById('panel-type').textContent = 'Details';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="panel-empty">
                    <div class="panel-empty-icon">📋</div>
                    <div class="panel-empty-text">
                        Click a breaker bar or entry line to see details
                    </div>
                </div>
            `;
        }
        
        function showCursorConfluence(cursorMin) {
            const activeBreakers = allData.filter(d => 
                d.startMin <= cursorMin && d.endMin >= cursorMin
            );
            
            // Sort: 1m first, then 5m, 15m, 1h, 4h last; within TF: NQ before ES
            const tfOrder = { '1m': 1, '5m': 2, '15m': 3, '1h': 4, '1hr': 4, '4h': 5, '4hr': 5 };
            const symOrder = { 'NQ': 1, 'ES': 2 };
            const sortedActive = [...activeBreakers].sort((a, b) => {
                const tfA = tfOrder[a.tf.replace('hr', 'h')] || 99;
                const tfB = tfOrder[b.tf.replace('hr', 'h')] || 99;
                if (tfA !== tfB) return tfA - tfB;
                const symA = symOrder[a.symbol] || 99;
                const symB = symOrder[b.symbol] || 99;
                if (symA !== symB) return symA - symB;
                return a.dir === 'bull' ? -1 : 1;
            });
            
            const pt = document.getElementById('panel-time'); if (pt) pt.textContent = minToTime(cursorMin);
            document.getElementById('panel-type').textContent = 'Confluence';
            document.getElementById('panel-type').classList.remove('live');
            
            if (sortedActive.length === 0) {
                document.getElementById('panel-content').innerHTML = `<div class="confluence-no-active">No active breakers at this time</div>`;
                return;
            }
            
            let html = '<div class="stack-container">';
            sortedActive.forEach(breaker => {
                html += generateStackedBreaker(breaker);
            });
            html += '</div>';
            
            document.getElementById('panel-content').innerHTML = html;
        }
        
        function showLiveConfluence() {
            // Use actual current time, not last data time
            const now = new Date();
            const currentMin = Math.floor(now.getTime() / 60000);
            
            // Extend dataMaxTime to current time if behind (so chart shows current time)
            if (currentMin > dataMaxTime && dataMaxTime > 0) {
                dataMaxTime = currentMin;
            }
            
            highlightLiveActive();
            
            // Position cursor line at current time (if chart is rendered)
            const cursorLine = document.getElementById('cursor-line');
            if (cursorLine && windowStartMin) {
                const xPos = (currentMin - windowStartMin) * PIXELS_PER_MINUTE;
                if (xPos >= 0) {
                    cursorLine.style.left = xPos + 'px';
                    cursorLine.classList.add('visible', 'live-cursor');
                }
            }
            
            const activeBreakers = allData.filter(d => 
                d.startMin <= currentMin && d.endMin >= currentMin
            );
            
            // Sort: 1m first, then 5m, 15m, 1h, 4h last; within TF: NQ before ES
            const tfOrder = { '1m': 1, '5m': 2, '15m': 3, '1h': 4, '1hr': 4, '4h': 5, '4hr': 5 };
            const symOrder = { 'NQ': 1, 'ES': 2 };
            const sortedActive = [...activeBreakers].sort((a, b) => {
                const tfA = tfOrder[a.tf.replace('hr', 'h')] || 99;
                const tfB = tfOrder[b.tf.replace('hr', 'h')] || 99;
                if (tfA !== tfB) return tfA - tfB;
                const symA = symOrder[a.symbol] || 99;
                const symB = symOrder[b.symbol] || 99;
                if (symA !== symB) return symA - symB;
                return a.dir === 'bull' ? -1 : 1;
            });
            
            const pt = document.getElementById('panel-time'); if (pt) pt.textContent = minToTime(currentMin);
            document.getElementById('panel-type').textContent = 'Live Confluence';
            document.getElementById('panel-type').classList.add('live');
            
            if (sortedActive.length === 0) {
                document.getElementById('panel-content').innerHTML = `<div class="confluence-no-active">No active breakers</div>`;
                return;
            }
            
            let html = '<div class="stack-container">';
            sortedActive.forEach(breaker => {
                html += generateStackedBreaker(breaker);
            });
            html += '</div>';
            
            document.getElementById('panel-content').innerHTML = html;
        }
        
        // TF colors matching left panel
        const TF_COLORS = {
            '4h': '#f87171', '4hr': '#f87171',
            '1h': '#fbbf24', '1hr': '#fbbf24',
            '15m': '#4ade80',
            '5m': '#60a5fa',
            '1m': '#c084fc'
        };
        
        function generateStackedBreaker(breaker) {
            const tf = breaker.tf.replace('hr', 'h');
            const tfDisplay = TF_DISPLAY[tf] || breaker.tf;
            const tfColor = TF_COLORS[breaker.tf] || '#888';
            const isBull = breaker.dir === 'bull';
            const dirColor = isBull ? '#4ade80' : '#f87171';
            const events = breaker.events;
            const isSelected = selectedBreakerId === breaker.id ? ' selected' : '';
            
            if (events.length < 2) {
                return `
                    <div class="stack-item${isSelected}" data-breaker-id="${breaker.id}" onclick="selectBreaker('${breaker.id}')">
                        <div class="stack-label" style="border-left-color:${tfColor}">
                            <span class="stack-tf" style="color:${tfColor}">${tfDisplay}</span>
                            <span class="stack-sym">${breaker.symbol}</span>
                            <span class="stack-dir" style="color:${dirColor}">${breaker.dir.toUpperCase()}</span>
                        </div>
                        <div class="stack-empty">No data</div>
                    </div>
                `;
            }
            
            const combinedChart = generateCombinedFibPriceChart(breaker, dirColor);
            
            // Get time range for cursor positioning
            const minTime = events[0].absMin;
            const maxTime = events[events.length - 1].absMin;
            
            return `
                <div class="stack-item${isSelected}" data-breaker-id="${breaker.id}" onclick="selectBreaker('${breaker.id}')">
                    <div class="stack-label" style="border-left-color:${tfColor}">
                        <span class="stack-tf" style="color:${tfColor}">${tfDisplay}</span>
                        <span class="stack-sym">${breaker.symbol}</span>
                        <span class="stack-dir" style="color:${dirColor}">${breaker.dir.toUpperCase()}</span>
                        <span class="stack-spacer"></span>
                        <span class="stack-legend">
                            <span class="legend-item"><span class="legend-line dashed" style="border-color:${dirColor}"></span><span style="color:${dirColor}">Peak</span></span>
                            <span class="legend-item"><span class="legend-line" style="background:${dirColor}"></span><span style="color:${dirColor}">Fib</span></span>
                        </span>
                    </div>
                    <div class="stack-charts-wrapper" data-min-time="${minTime}" data-max-time="${maxTime}">
                        <div class="stack-charts">
                            ${combinedChart}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function generateCombinedFibPriceChart(breaker, dirColor, svgHeight = 200) {
            const events = breaker.events;
            const width = 420;
            const height = svgHeight;
            const padding = { top: 12, right: 52, bottom: 24, left: 36 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minTime = events[0].absMin;
            const maxTime = events[events.length - 1].absMin;
            const timeRange = maxTime - minTime || 1;
            
            const breakerPrice = breaker.price || 0;
            const isBull = breaker.dir === 'bull';
            
            const lastEvent = events[events.length - 1];
            const currentPrice = lastEvent.price || 0;
            
            // Dynamic Y-axis: 0-3.2 (T2) unless fib exceeds 3.2
            const maxFibInData = Math.max(...events.map(e => Math.max(e.fib || 0, e.maxFib || 0)));
            const fibCeil = maxFibInData > 3.2 ? Math.ceil(maxFibInData) : 3.2;
            
            const fibToY = (fib) => {
                if (isBull) {
                    return padding.top + chartHeight - (fib / fibCeil) * chartHeight;
                } else {
                    return padding.top + (fib / fibCeil) * chartHeight;
                }
            };
            
            let sampledEvents = events;
            if (events.length > 100) {
                const step = Math.ceil(events.length / 80);
                sampledEvents = events.filter((e, i) => i === 0 || i === events.length - 1 || i % step === 0);
            }
            
            const fibPoints = sampledEvents.map(e => ({
                x: padding.left + ((e.absMin - minTime) / timeRange) * chartWidth,
                y: fibToY(e.fib || 0),
                fib: e.fib || 0
            }));
            
            const peakPoints = sampledEvents.map(e => ({
                x: padding.left + ((e.absMin - minTime) / timeRange) * chartWidth,
                y: fibToY(e.maxFib || e.fib || 0),
                fib: e.maxFib || e.fib || 0
            }));
            
            let peakX = fibPoints[0].x, peakY = fibPoints[0].y, peakFib = 0;
            fibPoints.forEach(p => {
                if (p.fib > peakFib) { peakFib = p.fib; peakX = p.x; peakY = p.y; }
            });
            
            const fibPath = fibPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            const peakPath = peakPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            const zeroY = fibToY(0);
            const areaPath = fibPath + ` L ${fibPoints[fibPoints.length-1].x} ${zeroY} L ${fibPoints[0].x} ${zeroY} Z`;
            const breakerY = fibToY(1.0);
            
            // Breaker Zone - calculated from actual zone data
            // The ID has two price fields that need to be interpreted based on direction
            const fibRange = breaker.fibRange || 1;
            const zoneSize = breaker.zoneSize || 0;
            const price1 = breaker.sweepLow || 0;
            const price2 = breaker.breakerHigh || breaker.price || 0;
            
            // Calculate zone fib values based on direction
            // Use min/max to ensure correct price interpretation regardless of ID field order
            let zoneTopFib, zoneBottomFib;
            if (isBull) {
                // Bullish: fib 0 at lower price, zone at higher price going down
                const fib0Price = Math.min(price1, price2);
                const breakerPrice = Math.max(price1, price2);
                zoneTopFib = fibRange > 0 ? (breakerPrice - fib0Price) / fibRange : 0;
                zoneBottomFib = fibRange > 0 ? (breakerPrice - zoneSize - fib0Price) / fibRange : 0;
            } else {
                // Bearish: fib 0 at higher price, zone at lower price going up
                const fib0Price = Math.max(price1, price2);
                const breakerPrice = Math.min(price1, price2);
                zoneBottomFib = fibRange > 0 ? (fib0Price - breakerPrice) / fibRange : 0;
                zoneTopFib = fibRange > 0 ? (fib0Price - breakerPrice - zoneSize) / fibRange : 0;
            }
            
            const zoneTopY = fibToY(zoneTopFib);
            const zoneBottomY = fibToY(zoneBottomFib);
            const zoneMinY = Math.min(zoneTopY, zoneBottomY);
            const zoneHeight = Math.max(Math.abs(zoneBottomY - zoneTopY), 4); // Ensure minimum 4px height
            const dotColor = isBull ? 'rgba(74, 222, 128, 0.4)' : 'rgba(248, 113, 113, 0.4)';
            const zoneBorderColor = isBull ? 'rgba(74, 222, 128, 0.7)' : 'rgba(248, 113, 113, 0.7)';
            const zoneLabelColor = isBull ? 'rgba(74, 222, 128, 0.9)' : 'rgba(248, 113, 113, 0.9)';
            const patternId = 'detail-zone-' + (breaker.id || 'x').replace(/[^a-zA-Z0-9]/g, '');
            const zoneRect = `
                <defs>
                    <pattern id="${patternId}" width="8" height="8" patternUnits="userSpaceOnUse">
                        <circle cx="2" cy="2" r="1.2" fill="${dotColor}"/>
                    </pattern>
                </defs>
                <rect x="${padding.left}" y="${zoneMinY}" 
                      width="${chartWidth}" height="${zoneHeight}" 
                      fill="url(#${patternId})"/>
                <line x1="${padding.left}" y1="${zoneTopY}" x2="${padding.left + chartWidth}" y2="${zoneTopY}" 
                      stroke="${zoneBorderColor}" stroke-width="1.5"/>
                <line x1="${padding.left}" y1="${zoneBottomY}" x2="${padding.left + chartWidth}" y2="${zoneBottomY}" 
                      stroke="${zoneBorderColor}" stroke-width="1" stroke-dasharray="4,3"/>
                <text x="${padding.left + 4}" y="${zoneMinY + 14}" 
                      fill="${zoneLabelColor}" font-size="10" font-family="Roboto Mono" font-weight="600">ZONE</text>
            `;
            
            // Breaker Fib highlight line (entry level of the zone)
            // For bullish: top of zone (higher price), for bearish: bottom of zone (lower price)
            const breakerFibY = isBull ? zoneTopY : zoneBottomY;
            const breakerFibLabel = (isBull ? zoneTopFib : zoneBottomFib).toFixed(2);
            const breakerFibLine = `
                <line x1="${padding.left}" y1="${breakerFibY}" x2="${padding.left + chartWidth}" y2="${breakerFibY}" 
                      stroke="${dirColor}" stroke-width="2" stroke-dasharray="6,3"/>
                <rect x="${padding.left + chartWidth + 2}" y="${breakerFibY - 8}" width="32" height="16" rx="2" 
                      fill="${isBull ? 'rgba(74, 222, 128, 0.2)' : 'rgba(248, 113, 113, 0.2)'}" stroke="${dirColor}" stroke-width="1"/>
                <text x="${padding.left + chartWidth + 18}" y="${breakerFibY + 4}" text-anchor="middle" 
                      fill="${dirColor}" font-size="10" font-family="Roboto Mono" font-weight="700">${breakerFibLabel}</text>
            `;
            
            // Y-axis grid and labels
            let yGrid = '';
            // Generate grid values: 0, 1, 2, 3, and fibCeil (3.2 for T2 or higher if exceeded)
            const gridVals = [0, 1, 2, 3];
            if (fibCeil > 3) gridVals.push(fibCeil);
            gridVals.forEach(val => {
                const y = fibToY(val);
                const isBreaker = val === 1;
                const isTop = val === fibCeil && val > 3;
                const lineColor = isBreaker ? '#555' : (isTop ? '#7c3aed' : '#1e1e21');
                const lineWidth = isBreaker ? 1 : 0.5;
                const textColor = isBreaker ? '#888' : (isTop ? '#9d7aed' : '#444');
                const fontWeight = isBreaker ? 600 : 400;
                const dashArray = isTop ? ' stroke-dasharray="4,3"' : '';
                yGrid += `<line x1="${padding.left}" y1="${y}" x2="${padding.left + chartWidth}" y2="${y}" stroke="${lineColor}" stroke-width="${lineWidth}"${dashArray}/>`;
                yGrid += `<text x="${padding.left - 4}" y="${y + 4}" text-anchor="end" fill="${textColor}" font-size="10" font-family="Roboto Mono" font-weight="${fontWeight}">${val.toFixed(1)}</text>`;
            });
            
            // Time labels
            const midTime = minTime + Math.floor(timeRange / 2);
            const timeLabels = `
                <text x="${padding.left}" y="${height - 4}" text-anchor="start" fill="#555" font-size="9" font-family="Roboto Mono">${minToTime(minTime)}</text>
                <text x="${padding.left + chartWidth/2}" y="${height - 4}" text-anchor="middle" fill="#555" font-size="9" font-family="Roboto Mono">${minToTime(midTime)}</text>
                <text x="${padding.left + chartWidth}" y="${height - 4}" text-anchor="end" fill="#555" font-size="9" font-family="Roboto Mono">${minToTime(maxTime)}</text>
            `;
            
            // Fib 0 price label (sweep price)
            const sweepPrice = isBull ? Math.min(price1, price2) : Math.max(price1, price2);
            const fib0Y = fibToY(0);
            const fib0PriceLabel = `<text x="${width - 2}" y="${fib0Y + 4}" text-anchor="end" fill="#6b7280" font-size="10" font-family="Roboto Mono" font-weight="500">${Math.round(sweepPrice)}</text>`;
            
            // Price labels
            const breakerPriceLabel = `<text x="${width - 2}" y="${breakerY + 4}" text-anchor="end" fill="#888" font-size="11" font-family="Roboto Mono" font-weight="500">${Math.round(breakerPrice)}</text>`;
            
            // Peak dots on maxFib line
            let dots = '';
            let dotPoints = peakPoints;
            if (peakPoints.length > 15) {
                const step = Math.ceil(peakPoints.length / 12);
                dotPoints = peakPoints.filter((p, i) => i === 0 || i === peakPoints.length - 1 || i % step === 0);
            }
            dotPoints.forEach(p => {
                dots += `<circle cx="${p.x}" cy="${p.y}" r="2.5" fill="${dirColor}"/>`;
            });
            
            // Last point marker with current price
            const lastPoint = fibPoints[fibPoints.length - 1];
            const lastPointY = lastPoint ? lastPoint.y : 0;
            const currentPriceLabel = lastPoint && currentPrice > 0 ? 
                `<text x="${width - 2}" y="${lastPointY + 4}" text-anchor="end" fill="#fb923c" font-size="11" font-family="Roboto Mono" font-weight="600">${Math.round(currentPrice)}</text>` : '';
            
            return `
                <svg class="stack-svg-tall" viewBox="0 0 ${width} ${height}" style="width:100%;height:${height}px;">
                    ${zoneRect}
                    ${breakerFibLine}
                    ${yGrid}
                    <path d="${areaPath}" fill="${dirColor}" fill-opacity="0.15"/>
                    <path d="${peakPath}" fill="none" stroke="${dirColor}" stroke-width="1.5" stroke-dasharray="3,2"/>
                    <path d="${fibPath}" fill="none" stroke="${dirColor}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                    ${dots}
                    <circle cx="${peakX}" cy="${peakY}" r="6" fill="${dirColor}" stroke="#0c0c0f" stroke-width="2"/>
                    <text x="${peakX}" y="${peakY + (isBull ? -10 : 16)}" text-anchor="middle" fill="${dirColor}" font-size="12" font-family="Roboto Mono" font-weight="700">${peakFib.toFixed(2)}</text>
                    ${lastPoint ? `<circle cx="${lastPoint.x}" cy="${lastPoint.y}" r="4" fill="#fb923c"/>` : ''}
                    ${breakerPriceLabel}
                    ${fib0PriceLabel}
                    ${currentPriceLabel}
                    ${timeLabels}
                </svg>
            `;
        }
        
        function generateStackPriceZone(breaker, dirColor) {
            // Kept for compatibility but not used in stacked view
            return '';
        }
        
        function generateStackFibChart(breaker) {
            // Kept for compatibility but not used in stacked view
            return '';
        }
        
        function generateCombinedMiniChart(breaker, cursorMin) {
            return generateStackedBreaker(breaker);
        }
        
        function generateMiniFibChart(breaker) {
            return generateStackedBreaker(breaker);
        }
        
        function showBreakerDetail(breakerId) {
            const b = allData.find(d => d.id === breakerId);
            if (!b) return;
            
            try {
                const duration = minToDuration(b.startMin || 0, b.endMin || 0);
                const parsed = parseStatus(b.status);
                
                // Status
                let statusClass = parsed.cssClass || 'active';
                let statusText = 'ACTIVE';
                let statusIcon = '◉';
                
                if (parsed.isFail) {
                    statusClass = 'fail';
                    statusText = 'FAILED';
                    statusIcon = '✗';
                } else if (parsed.isSuccess) {
                    statusClass = 'success';
                    statusText = parsed.icon === 'T2' ? 'T2 WIN' : 'T1 WIN';
                    statusIcon = '✓';
                }
                
                // Values
                const symbolLower = (b.symbol || 'ES').toLowerCase();
                const symbolUpper = (b.symbol || 'ES').toUpperCase();
                const dirLower = (b.dir || 'bull').toLowerCase();
                const isBull = dirLower === 'bull';
                const tfDisplay = TF_DISPLAY[b.tf] || (b.tf || '1m').toUpperCase();
                
                // Generate combined chart (taller for detail view)
                let combinedChart = '';
                const dirColor = isBull ? '#4ade80' : '#f87171';
                try {
                    combinedChart = generateCombinedFibPriceChart(b, dirColor, 280);
                } catch (chartErr) {
                    combinedChart = '<div style="color:#666;text-align:center;padding:20px;">Chart unavailable</div>';
                }
                
                // Get time range for cursor
                const events = b.events || [];
                const minTimeData = events.length > 0 ? events[0].absMin : 0;
                const maxTimeData = events.length > 0 ? events[events.length - 1].absMin : 0;
                
                const currentFib = (b.currentFib || 0).toFixed(2);
                const maxFib = (b.maxFib || 0).toFixed(2);
                const zoneSize = b.zoneSize || 0;
                const fibRange = b.fibRange || 0;
                
                // Current price from latest event
                const latestEvent = b.events && b.events.length > 0 ? b.events[b.events.length - 1] : null;
                const currentPrice = latestEvent ? latestEvent.price : 0;
                
                // Zone values from data
                const breakerPrice = b.breakerHigh || 0;
                const sweepPrice = b.sweepLow || 0;
                
                // Calculate actual zone high/low and fib values based on direction
                let zoneHigh, zoneLow, l2Price, l2Fib;
                let zoneHighFib, zoneLowFib;
                
                if (isBull) {
                    // Bullish: L2 (sweepLow) is fib 0, zone is at the top
                    l2Price = sweepPrice;
                    l2Fib = 0;
                    zoneHigh = breakerPrice;
                    zoneLow = breakerPrice - zoneSize;
                    zoneHighFib = fibRange > 0 ? ((zoneHigh - l2Price) / fibRange) : 0;
                    zoneLowFib = fibRange > 0 ? ((zoneLow - l2Price) / fibRange) : 0;
                } else {
                    // Bearish: H2 (sweepLow field contains higher price for bear) is fib 0
                    // Zone is at the bottom (breakerPrice field contains lower price)
                    l2Price = sweepPrice; // This is actually the higher price for bearish
                    l2Fib = 0;
                    zoneLow = breakerPrice;
                    zoneHigh = breakerPrice + zoneSize;
                    // For bearish, fib increases as price decreases from l2Price
                    zoneLowFib = fibRange > 0 ? ((l2Price - zoneLow) / fibRange) : 0;
                    zoneHighFib = fibRange > 0 ? ((l2Price - zoneHigh) / fibRange) : 0;
                }
                const zonePct = Math.min(b.zonePct || 0, 100);
                
                // Calculate bar widths for visual
                // Zone portion is zoneSize/fibRange of the total
                const zonePortion = fibRange > 0 ? (zoneSize / fibRange) * 100 : 0;
                const grayPortion = 100 - zonePortion;
                
                // Time window
                const startTime = minToTime(b.startMin || 0);
                const endTime = minToTime(b.endMin || 0);
                
                const pt = document.getElementById('panel-time'); if (pt) pt.textContent = startTime;
                document.getElementById('panel-type').textContent = 'Breaker Detail';
                document.getElementById('panel-type').classList.remove('live');
                
                document.getElementById('panel-content').innerHTML = `
                    <div class="bd-header-new">
                        <div class="bd-top-row">
                            <div class="bd-symbol-group">
                                <span class="bd-symbol ${symbolLower}">${symbolUpper}</span>
                                <span class="bd-dir ${dirLower}">${isBull ? '▲' : '▼'}</span>
                            </div>
                            <div class="bd-outcome ${statusClass}">
                                <span class="bd-outcome-icon">${statusIcon}</span>
                                <span class="bd-outcome-text">${statusText}</span>
                            </div>
                        </div>
                        <div class="bd-info-row">
                            <span class="bd-tf">${tfDisplay}</span>
                            <span class="bd-separator">·</span>
                            <span class="bd-dur">${duration}</span>
                        </div>
                    </div>
                    
                    <div class="bd-metrics-row">
                        <div class="bd-metric">
                            <span class="bd-metric-value">${currentPrice || '—'}</span>
                            <span class="bd-metric-label">Price</span>
                        </div>
                        <div class="bd-metric">
                            <span class="bd-metric-value">${currentFib}</span>
                            <span class="bd-metric-label">Fib</span>
                        </div>
                        <div class="bd-metric">
                            <span class="bd-metric-value ${parseFloat(maxFib) >= 2 ? 'good' : ''}">${maxFib}</span>
                            <span class="bd-metric-label">Peak</span>
                        </div>
                        <div class="bd-metric">
                            <span class="bd-metric-value">${fibRange}r</span>
                            <span class="bd-metric-label">Range</span>
                        </div>
                    </div>
                    
                    <div class="bd-zone-entry">
                        <div class="bd-zone-header">
                            <span class="bd-zone-title">Zone Entry</span>
                            <span class="bd-zone-pct ${zonePct >= 50 ? 'bad' : zonePct > 0 ? 'partial' : 'none'}">${zonePct}%</span>
                        </div>
                        
                        <!-- Visual Bar -->
                        <div class="bd-zone-bar-container">
                            <div class="bd-zone-bar-track">
                                ${isBull ? `
                                <!-- Bullish: Zone fills entire bar -->
                                <div class="bd-zone-bar-segment zone bull" style="width: 100%;">
                                    <div class="bd-zone-bar-fill bull" style="width: ${zonePct}%;"></div>
                                    <span class="bd-zone-size-center">${zoneSize}z</span>
                                </div>
                                ` : `
                                <!-- Bearish: Zone fills entire bar -->
                                <div class="bd-zone-bar-segment zone bear" style="width: 100%;">
                                    <div class="bd-zone-bar-fill bear" style="width: ${zonePct}%;"></div>
                                    <span class="bd-zone-size-center">${zoneSize}z</span>
                                </div>
                                `}
                            </div>
                        </div>
                        
                        <!-- Price Levels - 2 columns -->
                        <div class="bd-zone-levels-grid two-col">
                            ${isBull ? `
                            <!-- Bullish: Breaker | Zone Low -->
                            <div class="bd-zone-level-col left">
                                <span class="bd-zone-level-label">Breaker</span>
                                <span class="bd-zone-level-fib bull">${zoneHighFib.toFixed(2)}</span>
                                <span class="bd-zone-level-price">${zoneHigh}</span>
                            </div>
                            <div class="bd-zone-level-col right">
                                <span class="bd-zone-level-label">Zone Low</span>
                                <span class="bd-zone-level-fib bull">${zoneLowFib.toFixed(2)}</span>
                                <span class="bd-zone-level-price">${zoneLow}</span>
                            </div>
                            ` : `
                            <!-- Bearish: Zone High | Breaker -->
                            <div class="bd-zone-level-col left">
                                <span class="bd-zone-level-label">Zone High</span>
                                <span class="bd-zone-level-fib bear">${zoneHighFib.toFixed(2)}</span>
                                <span class="bd-zone-level-price">${zoneHigh}</span>
                            </div>
                            <div class="bd-zone-level-col right">
                                <span class="bd-zone-level-label">Breaker</span>
                                <span class="bd-zone-level-fib bear">${zoneLowFib.toFixed(2)}</span>
                                <span class="bd-zone-level-price">${zoneLow}</span>
                            </div>
                            `}
                        </div>
                    </div>
                    
                    <div class="bd-chart-section">
                        <div class="bd-chart-title">
                            Fib Journey
                            <span class="bd-chart-legend"><span class="leg-p"></span>Peak <span class="leg-c"></span>Current</span>
                        </div>
                        <div class="stack-charts-wrapper" data-min-time="${minTimeData}" data-max-time="${maxTimeData}">
                            <div class="stack-charts">
                                ${combinedChart}
                            </div>
                        </div>
                    </div>
                    
                    <div class="bd-breaker-id">${b.id}</div>
                    
                    <!-- Analysis button - not ready for production
                    ${(b.tf === '1m' && b.dir === 'bull' && b.symbol === 'NQ') ? `
                    <div class="bd-analysis-btn" onclick="showAnalysisModal('${b.id}')">
                        View Full Analysis →
                    </div>
                    ` : ''}
                    -->
                `;
                
                // Setup price chart hover after DOM update
                setTimeout(() => {
                    const priceChartContainer = document.querySelector('.price-chart-container');
                    if (priceChartContainer) {
                        setupPriceChartHover(priceChartContainer);
                    }
                }, 0);
                
            } catch (e) {
                console.error('Error showing breaker detail:', e);
                document.getElementById('panel-content').innerHTML = `
                    <div style="color:#f87171;padding:20px;">Error loading details</div>
                `;
            }
        }
        
        // Detail panel live cursor
        function startDetailCursor() {
            // Clear any existing interval
            if (detailCursorInterval) {
                clearInterval(detailCursorInterval);
            }
            
            // Update immediately
            updateDetailCursor();
            
            // Update every second
            detailCursorInterval = setInterval(updateDetailCursor, 1000);
        }
        
        function updateDetailCursor() {
            const wrapper = document.querySelector('.stack-charts-wrapper');
            if (!wrapper) return;
            
            const minTime = parseInt(wrapper.dataset.minTime);
            const maxTime = parseInt(wrapper.dataset.maxTime);
            if (!minTime || !maxTime) return;
            
            const cursorLine = wrapper.querySelector('.detail-cursor-line');
            const cursorTime = wrapper.querySelector('.detail-cursor-time');
            if (!cursorLine || !cursorTime) return;
            
            const now = new Date();
            const currentMin = Math.floor(now.getTime() / 60000);
            
            // Calculate position within chart
            // Chart has padding: left: 36, right: 52, total width 420
            const chartLeft = 36;
            const chartWidth = 420 - 36 - 52; // 332px
            const wrapperWidth = wrapper.offsetWidth || 420;
            
            const timeRange = maxTime - minTime || 1;
            const progress = (currentMin - minTime) / timeRange;
            
            // Only show cursor if within time range
            if (progress >= 0 && progress <= 1) {
                const xPos = chartLeft + (progress * chartWidth);
                const xPercent = (xPos / wrapperWidth) * 100;
                
                cursorLine.style.left = xPercent + '%';
                cursorLine.classList.add('visible');
                
                cursorTime.textContent = minToTime(currentMin);
                cursorTime.style.left = xPercent + '%';
                cursorTime.classList.add('visible');
            } else if (progress > 1) {
                // Cursor at end
                const xPos = chartLeft + chartWidth;
                const xPercent = (xPos / wrapperWidth) * 100;
                
                cursorLine.style.left = xPercent + '%';
                cursorLine.classList.add('visible');
                
                cursorTime.textContent = minToTime(currentMin);
                cursorTime.style.left = xPercent + '%';
                cursorTime.classList.add('visible');
            } else {
                cursorLine.classList.remove('visible');
                cursorTime.classList.remove('visible');
            }
        }
        
        function generateFibChart(breaker) {
            const events = breaker.events;
            if (events.length < 2) {
                return '<div style="color:#666;text-align:center;padding:20px;">Not enough data</div>';
            }
            
            const width = 280;
            const height = 120;
            const padding = { top: 20, right: 15, bottom: 25, left: 35 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Find min/max
            const minTime = events[0].absMin;
            const maxTime = events[events.length - 1].absMin;
            const timeRange = maxTime - minTime || 1;
            
            // Use max of both fib values for scale
            const maxFibCurrent = Math.max(...events.map(e => e.fib || 0), 1);
            const maxFibPeak = Math.max(...events.map(e => e.maxFib || e.fib || 0), 1);
            const maxFibVal = Math.max(maxFibCurrent, maxFibPeak);
            // Dynamic Y-axis: 0-3.2 (T2) unless fib exceeds 3.2
            const fibCeil = maxFibVal > 3.2 ? Math.ceil(maxFibVal) : 3.2;
            
            // Find peak point (first occurrence of max fib in maxFib line)
            const peakVal = Math.max(...events.map(e => e.maxFib || e.fib || 0));
            const peakIndex = events.findIndex(e => (e.maxFib || e.fib) === peakVal);
            const peakEvent = events[peakIndex];
            
            // Downsample events if too many (keep first, last, peak, and sampled)
            let sampledEvents = events;
            let sampledPeakIndex = peakIndex;
            if (events.length > 100) {
                const step = Math.ceil(events.length / 80);
                sampledEvents = events.filter((e, i) => 
                    i === 0 || i === events.length - 1 || i === peakIndex || i % step === 0
                );
                sampledPeakIndex = sampledEvents.findIndex(e => e === events[peakIndex]);
            }
            
            // Generate points for currentFib line
            const currentPoints = sampledEvents.map((e, i) => {
                const x = padding.left + ((e.absMin - minTime) / timeRange) * chartWidth;
                const y = padding.top + chartHeight - ((e.fib || 0) / fibCeil) * chartHeight;
                return { x, y, fib: e.fib || 0, time: e.absMin };
            });
            
            // Generate points for maxFib line
            const maxPoints = sampledEvents.map((e, i) => {
                const x = padding.left + ((e.absMin - minTime) / timeRange) * chartWidth;
                const fibVal = e.maxFib || e.fib || 0;
                const y = padding.top + chartHeight - (fibVal / fibCeil) * chartHeight;
                return { x, y, fib: fibVal, time: e.absMin, isPeak: i === sampledPeakIndex };
            });
            
            // Create line paths
            const currentLinePath = currentPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            const maxLinePath = maxPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            
            // Create area path (for gradient fill under max line)
            const areaPath = maxLinePath + ` L ${maxPoints[maxPoints.length-1].x} ${padding.top + chartHeight} L ${maxPoints[0].x} ${padding.top + chartHeight} Z`;
            
            // Generate Y-axis labels
            const yLabels = [];
            const ySteps = 4;
            for (let i = 0; i <= ySteps; i++) {
                const val = (fibCeil / ySteps) * i;
                const y = padding.top + chartHeight - (i / ySteps) * chartHeight;
                yLabels.push(`<text class="fib-chart-value-label" x="${padding.left - 5}" y="${y + 3}" text-anchor="end">${val.toFixed(1)}</text>`);
                if (i > 0 && i < ySteps) {
                    yLabels.push(`<line class="fib-chart-grid" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}"/>`);
                }
            }
            
            // Generate time labels (start, middle, end)
            const midTime = minTime + Math.floor(timeRange / 2);
            const timeLabels = [];
            timeLabels.push(`<text class="fib-chart-label" x="${padding.left}" y="${height - 5}" text-anchor="start">${minToTime(minTime)}</text>`);
            timeLabels.push(`<text class="fib-chart-label" x="${padding.left + chartWidth/2}" y="${height - 5}" text-anchor="middle">${minToTime(midTime)}</text>`);
            timeLabels.push(`<text class="fib-chart-label" x="${width - padding.right}" y="${height - 5}" text-anchor="end">${minToTime(maxTime)}</text>`);
            
            // Find peak point coordinates (on maxFib line)
            const peakPoint = maxPoints.find(p => p.isPeak);
            
            // Generate dots for maxFib line (sample if too many)
            let dotPoints = maxPoints;
            if (maxPoints.length > 20) {
                const step = Math.ceil(maxPoints.length / 15);
                dotPoints = maxPoints.filter((p, i) => i === 0 || i === maxPoints.length - 1 || p.isPeak || i % step === 0);
            }
            
            const dots = dotPoints.map(p => {
                return `<circle class="${p.isPeak ? 'fib-chart-peak' : 'fib-chart-dot'}" cx="${p.x}" cy="${p.y}" r="${p.isPeak ? 4 : 3}"/>`;
            }).join('');
            
            // Peak label (show maxFib value)
            const peakLabel = peakPoint ? `
                <text class="fib-peak-label" x="${peakPoint.x}" y="${peakPoint.y - 8}" text-anchor="middle">${peakPoint.fib.toFixed(2)}</text>
            ` : '';
            
            // Store chart data for cursor interaction
            const chartId = 'fib-chart-' + Date.now();
            
            // Schedule cursor setup after DOM update (pass both point sets)
            setTimeout(() => setupFibChartCursor(chartId, maxPoints, padding, chartWidth, chartHeight, fibCeil, minTime, timeRange, currentPoints), 0);
            
            return `
                <svg id="${chartId}" class="fib-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                    <defs>
                        <linearGradient id="fibGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:0.3"/>
                            <stop offset="100%" style="stop-color:#60a5fa;stop-opacity:0"/>
                        </linearGradient>
                    </defs>
                    
                    <!-- Grid lines -->
                    ${yLabels.join('')}
                    
                    <!-- Axes -->
                    <line class="fib-chart-axis" x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${padding.top + chartHeight}"/>
                    <line class="fib-chart-axis" x1="${padding.left}" y1="${padding.top + chartHeight}" x2="${width - padding.right}" y2="${padding.top + chartHeight}"/>
                    
                    <!-- Area fill (under max line) -->
                    <path class="fib-chart-area" d="${areaPath}"/>
                    
                    <!-- Current Fib line (orange, thinner) -->
                    <path class="fib-chart-line-current" d="${currentLinePath}"/>
                    
                    <!-- Max Fib line (blue, thicker) -->
                    <path class="fib-chart-line" d="${maxLinePath}"/>
                    
                    <!-- Dots on max line -->
                    ${dots}
                    
                    <!-- Peak label -->
                    ${peakLabel}
                    
                    <!-- Time labels -->
                    ${timeLabels.join('')}
                    
                    <!-- Cursor elements -->
                    <line class="fib-cursor-line" id="${chartId}-cursor-line" x1="0" y1="${padding.top}" x2="0" y2="${padding.top + chartHeight}"/>
                    <circle class="fib-cursor-dot" id="${chartId}-cursor-dot" cx="0" cy="0" r="5"/>
                    
                    <!-- Hover area -->
                    <rect x="${padding.left}" y="${padding.top}" width="${chartWidth}" height="${chartHeight}" fill="transparent" style="cursor:crosshair"/>
                </svg>
                <div class="fib-cursor-tooltip" id="${chartId}-tooltip">
                    <span class="fib-val">0.00</span>
                    <span class="time-val">00:00</span>
                </div>
            `;
        }
        
        function generatePriceZone(breaker) {
            const events = breaker.events || [];
            if (events.length < 2) {
                return '<div style="color:#666;text-align:center;padding:20px;">Not enough events</div>';
            }
            if (breaker.breakerHigh === undefined || breaker.sweepLow === undefined || breaker.zoneSize === undefined) {
                return '<div style="color:#666;text-align:center;padding:20px;">Zone data not available</div>';
            }
            if (!breaker.zoneSize || breaker.zoneSize <= 0) {
                return '<div style="color:#666;text-align:center;padding:20px;">Zone size is zero</div>';
            }
            
            // Check if we have price data in events
            const hasPrice = events.some(e => e.price > 0);
            if (!hasPrice) {
                return '<div style="color:#666;text-align:center;padding:20px;">No price data in events</div>';
            }
            
            const width = 300;
            const height = 140;
            const padding = { top: 15, right: 50, bottom: 25, left: 10 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const isBull = (breaker.dir || '').toLowerCase() === 'bull';
            
            // Zone calculation
            const zoneTop = breaker.breakerHigh;
            const zoneBottom = breaker.breakerHigh - breaker.zoneSize;
            
            // Find time range
            const minTime = events[0]?.absMin || 0;
            const maxTime = events[events.length - 1]?.absMin || minTime;
            const timeRange = maxTime - minTime || 1;
            
            // Get actual prices from events
            const priceData = events.filter(e => e.price > 0).map(e => ({
                time: e.absMin,
                price: e.price
            }));
            
            if (priceData.length < 2) {
                return '<div style="color:#666;text-align:center;padding:20px;">Not enough price data</div>';
            }
            
            // Current price (last data point)
            const currentPrice = priceData[priceData.length - 1].price;
            
            // Find price range for scale
            const allPrices = priceData.map(p => p.price);
            allPrices.push(zoneTop, zoneBottom, currentPrice);
            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);
            const priceRange = maxPrice - minPrice || 1;
            const pricePadding = priceRange * 0.15;
            const scaledMinPrice = minPrice - pricePadding;
            const scaledMaxPrice = maxPrice + pricePadding;
            const scaledRange = scaledMaxPrice - scaledMinPrice;
            
            // Convert price to Y coordinate (higher price = lower Y)
            const priceToY = (price) => {
                return padding.top + chartHeight - ((price - scaledMinPrice) / scaledRange) * chartHeight;
            };
            
            // Downsample if too many points
            let sampledData = priceData;
            if (priceData.length > 100) {
                const step = Math.ceil(priceData.length / 80);
                sampledData = priceData.filter((_, i) => i === 0 || i === priceData.length - 1 || i % step === 0);
            }
            
            // Generate price line points
            const pricePoints = sampledData.map(d => {
                const x = padding.left + ((d.time - minTime) / timeRange) * chartWidth;
                const y = priceToY(d.price);
                return { x, y, price: d.price, time: d.time };
            });
            
            // Create price line path
            const pricePath = pricePoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            
            // Zone Y coordinates
            const zoneTopY = priceToY(zoneTop);
            const zoneBottomY = priceToY(zoneBottom);
            const zoneHeight = Math.max(0, zoneBottomY - zoneTopY);
            
            // Current price Y
            const currentPriceY = priceToY(currentPrice);
            const currentPriceX = pricePoints[pricePoints.length - 1].x;
            
            // Time labels
            const midTime = minTime + Math.floor(timeRange / 2);
            
            // Generate unique ID for this chart
            const chartId = 'price-chart-' + breaker.id.replace(/[^a-zA-Z0-9]/g, '');
            
            // Store points data for hover in global map
            if (!window.priceChartData) window.priceChartData = {};
            window.priceChartData[chartId] = pricePoints.map(p => ({x: p.x, y: p.y, price: p.price, time: p.time}));
            
            return `
                <div class="price-chart-container" data-chart-id="${chartId}">
                    <svg id="${chartId}" class="price-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                        <!-- Breaker zone (shaded) -->
                        <rect class="price-chart-breaker-zone" x="${padding.left}" y="${zoneTopY}" width="${chartWidth}" height="${zoneHeight}"/>
                        
                        <!-- Zone top line (H2) -->
                        <line class="price-chart-breaker-line" x1="${padding.left}" y1="${zoneTopY}" x2="${padding.left + chartWidth}" y2="${zoneTopY}"/>
                        
                        <!-- Zone bottom line (dashed) -->
                        <line class="price-chart-level" x1="${padding.left}" y1="${zoneBottomY}" x2="${padding.left + chartWidth}" y2="${zoneBottomY}"/>
                        
                        <!-- Price line (orange) -->
                        <path class="price-chart-price-line" d="${pricePath}"/>
                        
                        <!-- Current price marker -->
                        <circle class="price-chart-current" cx="${currentPriceX}" cy="${currentPriceY}" r="4"/>
                        <line class="price-chart-current-line" x1="${currentPriceX}" y1="${currentPriceY}" x2="${width - padding.right + 5}" y2="${currentPriceY}" stroke-dasharray="2,2"/>
                        
                        <!-- Hover cursor line -->
                        <line id="${chartId}-cursor" class="price-chart-cursor" x1="0" y1="${padding.top}" x2="0" y2="${height - padding.bottom}" style="opacity:0"/>
                        
                        <!-- Hover dot -->
                        <circle id="${chartId}-dot" class="price-chart-hover-dot" cx="0" cy="0" r="4" style="opacity:0"/>
                        
                        <!-- Price labels -->
                        <text class="price-chart-price-label zone-label" x="${width - 3}" y="${zoneTopY + 4}" text-anchor="end">H2 ${Math.round(zoneTop)}</text>
                        <text class="price-chart-price-label" x="${width - 3}" y="${zoneBottomY + 4}" text-anchor="end">${Math.round(zoneBottom)}</text>
                        <text class="price-chart-current-label" x="${width - 3}" y="${currentPriceY + 4}" text-anchor="end">${Math.round(currentPrice)}</text>
                        
                        <!-- Time labels -->
                        <text class="price-chart-time-label" x="${padding.left}" y="${height - 5}" text-anchor="start">${minToTime(minTime)}</text>
                        <text class="price-chart-time-label" x="${padding.left + chartWidth/2}" y="${height - 5}" text-anchor="middle">${minToTime(midTime)}</text>
                        <text class="price-chart-time-label" x="${padding.left + chartWidth}" y="${height - 5}" text-anchor="end">${minToTime(maxTime)}</text>
                    </svg>
                    <div id="${chartId}-hover" class="price-chart-hover-info"></div>
                </div>
            `;
        }
        
        // Setup price chart hover after rendering
        function setupPriceChartHover(container) {
            if (!container) return;
            const chartId = container.dataset.chartId;
            if (!chartId || !window.priceChartData || !window.priceChartData[chartId]) return;
            
            try {
                const points = window.priceChartData[chartId];
                const svg = document.getElementById(chartId);
                const cursor = document.getElementById(chartId + '-cursor');
                const dot = document.getElementById(chartId + '-dot');
                const hoverInfo = document.getElementById(chartId + '-hover');
                
                if (!svg || !cursor || !dot || !hoverInfo) return;
                if (svg.dataset.hoverSetup) return;
                svg.dataset.hoverSetup = 'true';
                
                const width = 300;
                const paddingLeft = 10;
                const chartWidth = 240;
                
                svg.addEventListener('mousemove', (e) => {
                    const rect = svg.getBoundingClientRect();
                    const scaleX = width / rect.width;
                    const mouseX = (e.clientX - rect.left) * scaleX;
                    
                    if (mouseX < paddingLeft || mouseX > paddingLeft + chartWidth) {
                        cursor.style.opacity = '0';
                        dot.style.opacity = '0';
                        hoverInfo.style.opacity = '0';
                        return;
                    }
                    
                    let closest = points[0];
                    let closestDist = Math.abs(points[0].x - mouseX);
                    for (const p of points) {
                        const dist = Math.abs(p.x - mouseX);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closest = p;
                        }
                    }
                    
                    cursor.setAttribute('x1', closest.x);
                    cursor.setAttribute('x2', closest.x);
                    cursor.style.opacity = '1';
                    
                    dot.setAttribute('cx', closest.x);
                    dot.setAttribute('cy', closest.y);
                    dot.style.opacity = '1';
                    
                    hoverInfo.innerHTML = '<span class="hover-price">' + closest.price + '</span> @ <span class="hover-time">' + minToTime(closest.time) + '</span>';
                    hoverInfo.style.opacity = '1';
                });
                
                svg.addEventListener('mouseleave', () => {
                    cursor.style.opacity = '0';
                    dot.style.opacity = '0';
                    hoverInfo.style.opacity = '0';
                });
            } catch (e) {
                console.error('Error setting up price chart hover:', e);
            }
        }
        
        function setupFibChartCursor(chartId, points, padding, chartWidth, chartHeight, fibCeil, minTime, timeRange) {
            const svg = document.getElementById(chartId);
            const cursorLine = document.getElementById(chartId + '-cursor-line');
            const cursorDot = document.getElementById(chartId + '-cursor-dot');
            const tooltip = document.getElementById(chartId + '-tooltip');
            
            // Guard: check if elements exist and listeners not already attached
            if (!svg || !cursorLine || !cursorDot || !tooltip) return;
            if (svg.dataset.listenersAttached) return;
            svg.dataset.listenersAttached = 'true';
            
            const container = svg.closest('.fib-chart-container');
            
            svg.addEventListener('mousemove', (e) => {
                const rect = svg.getBoundingClientRect();
                const scaleX = 280 / rect.width;
                const mouseX = (e.clientX - rect.left) * scaleX;
                
                // Check if within chart area
                if (mouseX < padding.left || mouseX > padding.left + chartWidth) {
                    cursorLine.style.opacity = '0';
                    cursorDot.style.opacity = '0';
                    tooltip.style.opacity = '0';
                    return;
                }
                
                // Find closest point
                let closest = points[0];
                let closestDist = Math.abs(points[0].x - mouseX);
                
                for (const p of points) {
                    const dist = Math.abs(p.x - mouseX);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = p;
                    }
                }
                
                // Update cursor
                cursorLine.setAttribute('x1', closest.x);
                cursorLine.setAttribute('x2', closest.x);
                cursorLine.style.opacity = '1';
                
                cursorDot.setAttribute('cx', closest.x);
                cursorDot.setAttribute('cy', closest.y);
                cursorDot.style.opacity = '1';
                
                // Update tooltip
                tooltip.querySelector('.fib-val').textContent = closest.fib.toFixed(2);
                tooltip.querySelector('.time-val').textContent = minToTime(closest.time);
                tooltip.style.opacity = '1';
                
                // Position tooltip
                const tooltipX = (closest.x / 280) * rect.width;
                const tooltipY = (closest.y / 120) * rect.height;
                
                // Flip tooltip if near right edge
                if (tooltipX > rect.width * 0.6) {
                    tooltip.style.left = (tooltipX - tooltip.offsetWidth - 10) + 'px';
                } else {
                    tooltip.style.left = (tooltipX + 10) + 'px';
                }
                tooltip.style.top = (tooltipY - 10) + 'px';
            });
            
            svg.addEventListener('mouseleave', () => {
                cursorLine.style.opacity = '0';
                cursorDot.style.opacity = '0';
                tooltip.style.opacity = '0';
            });
        }
        
        function showEntryContext(entryMin) {
            // Find all breakers active at this time
            const activeAtEntry = allData.filter(d => 
                d.startMin <= entryMin && d.endMin >= entryMin
            );
            
            // Build context for each TF/Symbol combination
            const contextRows = [];
            let nqBull = 0, nqBear = 0, esBull = 0, esBear = 0;
            
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    const breaker = activeAtEntry.find(d => 
                        d.tf.replace('hr', 'h') === tf && d.symbol === symbol
                    );
                    
                    if (breaker) {
                        // Count for alignment
                        if (symbol === 'NQ') {
                            if (breaker.dir === 'bull') nqBull++; else nqBear++;
                        } else {
                            if (breaker.dir === 'bull') esBull++; else esBear++;
                        }
                        
                        // Get fib at start
                        const startFib = breaker.events[0]?.fib || 1.0;
                        
                        // Get fib at entry time
                        let fibAtEntry = startFib;
                        for (const evt of breaker.events) {
                            if (evt.absMin <= entryMin) {
                                fibAtEntry = evt.fib;
                            }
                        }
                        
                        // Status indicator
                        const parsedStatus = parseStatus(breaker.status);
                        
                        contextRows.push(`
                            <div class="context-row active">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir ${breaker.dir}">${breaker.dir.toUpperCase()}</span>
                                <span class="context-fib">${startFib.toFixed(1)} → ${fibAtEntry.toFixed(1)}</span>
                                <span class="context-status-icon ${parsedStatus.cssClass}">${parsedStatus.icon}</span>
                            </div>
                        `);
                    } else {
                        contextRows.push(`
                            <div class="context-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir none">-</span>
                                <span class="context-fib">-</span>
                                <span class="context-status-icon none">-</span>
                            </div>
                        `);
                    }
                });
            });
            
            const pt = document.getElementById('panel-time'); if (pt) pt.textContent = minToTime(entryMin);
            document.getElementById('panel-type').textContent = 'Entry Confluence';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-section-title">Active Breakers</div>
                    <div class="context-header">
                        <span>TF</span>
                        <span>Sym</span>
                        <span>Dir</span>
                        <span>Fib</span>
                        <span>St</span>
                    </div>
                    <div class="context-grid">
                        ${contextRows.join('')}
                    </div>
                </div>
                
                <div class="context-summary">
                    <div class="context-summary-row">
                        <span class="context-summary-label">NQ</span>
                        <span class="context-summary-value"><span class="arrow-bull">${nqBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${nqBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                    <div class="context-summary-row">
                        <span class="context-summary-label">ES</span>
                        <span class="context-summary-value"><span class="arrow-bull">${esBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${esBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                </div>
            `;
        }
        
        // ===== SELECTION =====
        function selectBreaker(breakerId) {
            // Clear previous selection
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.stack-item.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.smt-marker.selected').forEach(el => {
                el.classList.remove('selected');
            });
            clearEntryHighlight();
            selectedEntryMin = null;
            selectedSmtId = null;
            
            // Hide click cursor line when selecting breaker
            const clickCursorLine = document.getElementById('click-cursor-line');
            if (clickCursorLine) {
                clickCursorLine.classList.remove('visible');
            }
            lockedConfluenceMin = null;
            
            // Toggle selection
            if (selectedBreakerId === breakerId) {
                selectedBreakerId = null;
                // Keep confluence view at locked time or show live
                if (lockedConfluenceMin !== null) {
                    showCursorConfluence(lockedConfluenceMin);
                } else if (isLive) {
                    showLiveConfluence();
                } else {
                    showEmptyPanel();
                }
            } else {
                selectedBreakerId = breakerId;
                
                // Highlight selected bar on chart
                document.querySelectorAll(`.breaker-bar[data-breaker-id="${breakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                
                // Highlight selected item in confluence panel
                document.querySelectorAll(`.stack-item[data-breaker-id="${breakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                
                // Scroll breaker into view
                const bars = document.querySelectorAll(`.breaker-bar[data-breaker-id="${breakerId}"]`);
                if (bars.length > 0) {
                    const bar = bars[0];
                    const container = document.getElementById('scroll-container');
                    const barRect = bar.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    
                    // Check if bar is outside visible area
                    if (barRect.left < containerRect.left || barRect.right > containerRect.right) {
                        const breaker = allData.find(d => d.id === breakerId);
                        if (breaker) {
                            const targetScroll = (breaker.startMin - windowStartMin) * PIXELS_PER_MINUTE - containerRect.width / 3;
                            container.scrollLeft = Math.max(0, targetScroll);
                        }
                    }
                }
                
                // Show breaker detail panel
                showBreakerDetail(breakerId);
            }
            
            // Update entry line and marker styling
            document.querySelectorAll('.entry-line').forEach(el => {
                el.classList.remove('selected');
            });
        }
        
        function selectEntry(entryMin) {
            // Clear previous selection
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.smt-marker.selected').forEach(el => {
                el.classList.remove('selected');
            });
            selectedBreakerId = null;
            selectedSmtId = null;
            
            // Toggle selection - use confluence view
            if (selectedEntryMin === entryMin && lockedConfluenceMin === entryMin) {
                selectedEntryMin = null;
                lockedConfluenceMin = null;
                clearEntryHighlight();
                if (isLive) {
                    showLiveConfluence();
                } else {
                    showEmptyPanel();
                }
            } else {
                selectedEntryMin = entryMin;
                lockedConfluenceMin = entryMin;
                highlightActiveAtEntry(entryMin);
                showCursorConfluence(entryMin);
            }
            
            // Update entry line and marker styling
            document.querySelectorAll('.entry-line').forEach(el => {
                if (parseInt(el.dataset.entryMin) === selectedEntryMin) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });
        }
        
        function selectTimeContext(clickedMin) {
            // Clear previous selections
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.smt-marker.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.entry-line').forEach(el => {
                el.classList.remove('selected');
            });
            selectedBreakerId = null;
            selectedSmtId = null;
            selectedEntryMin = null;
            
            // Get click cursor line
            const clickCursorLine = document.getElementById('click-cursor-line');
            
            // Toggle lock on confluence view
            if (lockedConfluenceMin === clickedMin) {
                // Clicking same time unlocks
                lockedConfluenceMin = null;
                clearEntryHighlight();
                // Hide click cursor line
                if (clickCursorLine) {
                    clickCursorLine.classList.remove('visible');
                }
                if (isLive) {
                    showLiveConfluence();
                } else {
                    showEmptyPanel();
                }
            } else {
                // Lock confluence at clicked time
                lockedConfluenceMin = clickedMin;
                highlightActiveAtEntry(clickedMin);
                showCursorConfluence(clickedMin);
                
                // Show and position click cursor line
                if (clickCursorLine) {
                    const xPos = (clickedMin - windowStartMin) * PIXELS_PER_MINUTE;
                    clickCursorLine.style.left = xPos + 'px';
                    clickCursorLine.classList.add('visible');
                }
            }
        }
        
        function highlightActiveAtEntry(entryMin) {
            clearEntryHighlight();
            
            // Track which TF/symbol combinations have active breakers
            const activeLanes = new Set();
            
            // Use cached bars
            for (const bar of renderedBars) {
                if (bar.startMin <= entryMin && bar.endMin >= entryMin) {
                    bar.el.classList.add('active-at-entry');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('has-confluence');
                }
            }
        }
        
        function clearEntryHighlight() {
            for (const bar of renderedBars) {
                bar.el.classList.remove('active-at-entry');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('has-confluence');
            }
        }
        
        // Cursor highlighting (yellow) - separate from live/selected highlighting
        function highlightCursorActive(cursorMin) {
            clearCursorHighlight();
            clearLiveHighlight(); // Clear live highlight when cursor is active
            
            const activeLanes = new Set();
            
            // Use cached bars instead of querySelectorAll
            for (const bar of renderedBars) {
                if (bar.startMin <= cursorMin && bar.endMin >= cursorMin) {
                    bar.el.classList.add('cursor-active');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('cursor-confluence');
                }
            }
        }
        
        function clearCursorHighlight() {
            // Use cached bars instead of querySelectorAll
            for (const bar of renderedBars) {
                bar.el.classList.remove('cursor-active');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('cursor-confluence');
            }
        }
        
        // Live highlighting (green) - for live mode current time
        function highlightLiveActive() {
            clearLiveHighlight();
            
            // Use actual current time, not last data time
            const now = new Date();
            const currentMin = Math.floor(now.getTime() / 60000);
            
            const activeLanes = new Set();
            
            // Use cached bars
            for (const bar of renderedBars) {
                if (bar.startMin <= currentMin && bar.endMin >= currentMin) {
                    bar.el.classList.add('live-active');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('live-confluence');
                }
            }
        }
        
        function clearLiveHighlight() {
            for (const bar of renderedBars) {
                bar.el.classList.remove('live-active');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('live-confluence');
            }
        }
        
        // ===== VIEWPORT DRAG TO PAN =====
        let vpHandlersSetup = false;
        
        function setupViewportHandlers() {
            if (vpHandlersSetup) return;
            vpHandlersSetup = true;
            
            const track = document.getElementById('timeline-track');
            const viewport = document.getElementById('viewport-indicator');
            
            if (!track || !viewport) return;
            
            let isDragging = false;
            let hasDragged = false;
            let startX = 0;
            let startScrollLeft = 0;
            
            // Drag viewport to scroll chart
            viewport.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                hasDragged = false;
                startX = e.clientX;
                
                const container = document.getElementById('scroll-container');
                startScrollLeft = container ? container.scrollLeft : 0;
                viewport.style.cursor = 'grabbing';
            });
            
            // Click on track to jump
            track.addEventListener('click', (e) => {
                if (e.target !== track || hasDragged) {
                    hasDragged = false;
                    return;
                }
                
                if (dataMinTime === 0 || dataMaxTime === 0) return;
                
                const container = document.getElementById('scroll-container');
                const chartInner = document.getElementById('chart-inner');
                if (!container || !chartInner) return;
                
                const trackRect = track.getBoundingClientRect();
                const clickPct = (e.clientX - trackRect.left) / trackRect.width;
                const totalRange = dataMaxTime - dataMinTime;
                const clickMin = dataMinTime + clickPct * totalRange;
                
                // Calculate scroll position to center on clicked time
                const chartWidth = chartInner.offsetWidth;
                const viewportWidth = container.clientWidth;
                const windowRange = windowEndMin - windowStartMin;
                
                // Map clicked time to scroll position
                const timeInWindow = clickMin - windowStartMin;
                const scrollTarget = (timeInWindow / windowRange) * chartWidth - viewportWidth / 2;
                
                container.scrollLeft = Math.max(0, Math.min(scrollTarget, chartWidth - viewportWidth));
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                if (dataMinTime === 0 || dataMaxTime === 0) return;
                
                hasDragged = true;
                
                const container = document.getElementById('scroll-container');
                const chartInner = document.getElementById('chart-inner');
                const trackEl = document.getElementById('timeline-track');
                if (!container || !chartInner || !trackEl) return;
                
                const trackRect = trackEl.getBoundingClientRect();
                const trackWidth = trackRect.width;
                const chartWidth = chartInner.offsetWidth;
                const viewportWidth = container.clientWidth;
                const maxScroll = chartWidth - viewportWidth;
                
                if (maxScroll <= 0) return;
                
                const totalRange = dataMaxTime - dataMinTime;
                const windowRange = windowEndMin - windowStartMin;
                
                // Map drag distance on track to scroll distance
                const dx = e.clientX - startX;
                const dPctOfTotal = dx / trackWidth;
                const dTime = dPctOfTotal * totalRange;
                const dScroll = (dTime / windowRange) * chartWidth;
                
                container.scrollLeft = Math.max(0, Math.min(startScrollLeft + dScroll, maxScroll));
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    viewport.style.cursor = 'grab';
                }
            });
        }
        
        // ===== SCROLL =====
        let scrollTimeout;
        
        function onScroll() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(updateViewportFromScroll, 30);
            
            const container = document.getElementById('scroll-container');
            const header = document.getElementById('time-header');
            header.style.transform = `translateX(${-container.scrollLeft}px)`;
            
            // Update sticky date indicator
            updateStickyDate(container.scrollLeft);
            
            // Update main cursor position on scroll
            if (isLive) {
                updateMainCursor();
            }
        }
        
        function updateStickyDate(scrollLeft) {
            // Disabled - using date in time labels instead
            const stickyDate = document.getElementById('sticky-date');
            if (stickyDate) stickyDate.classList.remove('visible');
        }
        
        function updateViewportFromScroll() {
            if (dataMinTime === 0 || dataMaxTime === 0) return;
            
            const container = document.getElementById('scroll-container');
            const chartInner = document.getElementById('chart-inner');
            if (!container || !chartInner) return;
            
            const chartWidth = chartInner.offsetWidth;
            const viewportWidth = container.clientWidth;
            const scrollLeft = container.scrollLeft;
            
            if (chartWidth <= 0) return;
            
            const totalDataRange = dataMaxTime - dataMinTime;
            const windowRange = windowEndMin - windowStartMin;
            
            // Calculate visible time range based on scroll
            const scrollPct = chartWidth > viewportWidth ? scrollLeft / (chartWidth - viewportWidth) : 0;
            const visibleTimeWidth = (viewportWidth / chartWidth) * windowRange;
            const visibleStartMin = windowStartMin + scrollPct * (windowRange - visibleTimeWidth);
            const visibleEndMin = visibleStartMin + visibleTimeWidth;
            
            // Map to viewport bar position
            const startPct = Math.max(0, ((visibleStartMin - dataMinTime) / totalDataRange) * 100);
            const endPct = Math.min(100, ((visibleEndMin - dataMinTime) / totalDataRange) * 100);
            const widthPct = Math.max(2, endPct - startPct);
            
            const vpEl = document.getElementById('viewport-indicator');
            if (vpEl) {
                vpEl.style.left = startPct + '%';
                vpEl.style.width = widthPct + '%';
            }
        }
        
        function updateViewportIndicator() {
            // Update time labels
            if (dataMinTime > 0 && dataMaxTime > 0) {
                document.getElementById('data-start').textContent = minToDateTime(dataMinTime);
            }
            
            // Update viewport bar position based on current scroll
            updateViewportFromScroll();
        }
        
        // ===== AUTO REFRESH =====
        function setRefreshInterval() {
            if (refreshTimer) clearInterval(refreshTimer);
            if (countdownTimer) clearInterval(countdownTimer);
            
            const interval = parseInt(document.getElementById('refresh-interval').value);
            const countdownEl = document.getElementById('countdown');
            
            if (interval === 0) {
                countdownEl.textContent = '';
                return;
            }
            
            countdownSecs = interval;
            countdownEl.textContent = interval + 's';
            
            countdownTimer = setInterval(() => {
                countdownSecs--;
                if (countdownSecs <= 0) countdownSecs = interval;
                countdownEl.textContent = countdownSecs + 's';
            }, 1000);
            
            refreshTimer = setInterval(() => {
                loadData();
                countdownSecs = interval;
            }, interval * 1000);
        }
        
        // ===== ANALYSIS MODAL =====
        // New schema: dims.g1, dims.d1, etc. with {name, status, narrative[]}
        const ANALYSIS_DIMENSIONS = {
            gate: [
                { code: 'G1', key: 'g1' },
                { code: 'G2', key: 'g2' },
                { code: 'G3', key: 'g3' },
                { code: 'G4', key: 'g4' },
                { code: 'G5', key: 'g5' },
                { code: 'G6', key: 'g6' },
                { code: 'G7', key: 'g7' }
            ],
            direction: [
                { code: 'D1', key: 'd1' },
                { code: 'D2', key: 'd2' },
                { code: 'D3', key: 'd3' }
            ],
            support: [
                { code: 'S1', key: 's1' },
                { code: 'S2', key: 's2' },
                { code: 'S3', key: 's3' }
            ],
            resistance: [
                { code: 'R1', key: 'r1' },
                { code: 'R2', key: 'r2' }
            ],
            energy: [
                { code: 'E1', key: 'e1' },
                { code: 'E2', key: 'e2' },
                { code: 'E3', key: 'e3' },
                { code: 'E4', key: 'e4' },
                { code: 'E5', key: 'e5' },
                { code: 'E6', key: 'e6' }
            ]
        };
        
        const CATEGORY_LABELS = {
            gate: 'Gate',
            direction: 'Direction',
            support: 'Support',
            resistance: 'Resistance',
            energy: 'Energy'
        };
        
        function showAnalysisModal(breakerId = null) {
            const modal = document.getElementById('analysis-modal');
            const heroId = document.getElementById('analysis-hero-id');
            
            if (!breakerId) {
                heroId.textContent = 'No breaker selected';
                showAnalysisError('Select a 1M Bull NQ breaker to view analysis');
                modal.classList.add('visible');
                document.addEventListener('keydown', handleModalEscape);
                return;
            }
            
            // Find the breaker to get its start time and display_id
            const breaker = allData.find(d => d.id === breakerId);
            if (breaker) {
                heroId.textContent = breaker.displayId || breakerId;
                // Fetch confirmation data from Firebase for this breaker's time
                fetchConfirmationData(breakerId, breaker.startMin);
            } else {
                heroId.textContent = breakerId;
                showAnalysisError('Breaker not found in loaded data');
            }
            
            modal.classList.add('visible');
            document.addEventListener('keydown', handleModalEscape);
        }
        
        function showAnalysisError(message) {
            const contentContainer = document.getElementById('analysis-content');
            const tabsContainer = document.getElementById('analysis-tabs');
            const decisionBadge = document.getElementById('analysis-decision-badge');
            const scoreBig = document.getElementById('analysis-score-big');
            const heroMeta = document.getElementById('analysis-hero-meta');
            
            decisionBadge.textContent = 'ERROR';
            decisionBadge.className = 'analysis-decision-badge fail';
            scoreBig.textContent = '--/21';
            heroMeta.textContent = '';
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = `
                <div style="padding: 40px; text-align: center; color: #f87171;">
                    <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
                    <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">No Confirmation Data</div>
                    <div style="font-size: 13px; color: #888;">${message}</div>
                </div>
            `;
        }
        
        function fetchConfirmationData(breakerId, startMin) {
            // Get display_id for UI
            const breaker = allData.find(d => d.id === breakerId);
            const displayId = breaker?.displayId || breakerId;
            
            // Show loading state
            document.getElementById('analysis-hero-id').textContent = displayId + ' · Loading...';
            
            // Query the confirmations collection directly (not inside snapshots)
            const confirmationsUrl = FIREBASE_URL.replace('snapshots.json', 'confirmations.json');
            
            fetch(confirmationsUrl)
                .then(r => r.json())
                .then(data => {
                    if (!data || Object.keys(data).length === 0) {
                        document.getElementById('analysis-hero-id').textContent = displayId;
                        showAnalysisError(`No confirmations in database`);
                        return;
                    }
                    
                    // Find confirmation matching this breaker_id
                    let confirmationData = null;
                    
                    for (const [confKey, conf] of Object.entries(data)) {
                        if (conf && conf.breaker_id && conf.breaker_id === breakerId) {
                            confirmationData = conf;
                            break;
                        }
                    }
                    
                    if (confirmationData) {
                        document.getElementById('analysis-hero-id').textContent = displayId;
                        renderAnalysisContent(transformConfirmationData(confirmationData, displayId));
                    } else {
                        document.getElementById('analysis-hero-id').textContent = displayId;
                        showAnalysisError(`No confirmation found for this breaker`);
                    }
                })
                .catch(err => {
                    console.error('Error fetching confirmation:', err);
                    document.getElementById('analysis-hero-id').textContent = displayId;
                    showAnalysisError(`Firebase error: ${err.message}`);
                });
        }
        
        function transformConfirmationData(conf, displayId) {
            // New schema passes through directly
            // dims contains: g1-g7, d1-d3, s1-s3, r1-r2, e1-e6
            // Each has: name, status, narrative[]
            return {
                breaker_id: conf.breaker_id,
                display_id: conf.display_id || displayId,
                time: conf.time,
                pattern: conf.pattern,
                zone: conf.zone,
                levels: conf.levels,
                formation: conf.formation,
                confluence: conf.confluence,
                dims: conf.dims,
                summary: conf.summary,
                decision: conf.decision,
                score: conf.score
            };
        }
        
        function closeAnalysisModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('analysis-modal');
            modal.classList.remove('visible');
            document.removeEventListener('keydown', handleModalEscape);
        }
        
        function handleModalEscape(e) {
            if (e.key === 'Escape') {
                closeAnalysisModal();
            }
        }
        
        function toggleDimension(el) {
            el.closest('.analysis-dimension').classList.toggle('expanded');
        }
        
        function toggleCategory(btn, categoryEl) {
            const dimensions = categoryEl.querySelectorAll('.analysis-dimension');
            const allExpanded = Array.from(dimensions).every(d => d.classList.contains('expanded'));
            
            dimensions.forEach(d => {
                if (allExpanded) {
                    d.classList.remove('expanded');
                } else {
                    d.classList.add('expanded');
                }
            });
            
            btn.textContent = allExpanded ? '▼ Expand All' : '▲ Collapse All';
        }
        
        // ===== CONFLUENCE MODAL =====
        const CONFLUENCE_CARD_HEIGHT = 255; // 220px chart + 35px header
        const CONFLUENCE_CARD_GAP = 16;
        const CONFLUENCE_PPM = 35; // pixels per minute
        
        let confluenceModalOpen = false;
        let confluenceScrollHandler = null;
        let confluenceMoveHandler = null;
        let confluenceLiveCursorInterval = null;
        
        function openConfluenceModal() {
            const modal = document.getElementById('confluence-modal');
            modal.classList.add('visible');
            confluenceModalOpen = true;
            
            // Show/hide LIVE badge
            const liveBadge = document.getElementById('confluence-live-badge');
            if (liveBadge) {
                if (isLive) {
                    liveBadge.classList.add('visible');
                } else {
                    liveBadge.classList.remove('visible');
                }
            }
            
            renderConfluenceModal();
            setupConfluenceHandlers();
            
            // Scroll to show latest content (rightmost)
            setTimeout(() => {
                const scroll = document.getElementById('confluence-scroll');
                scroll.scrollLeft = scroll.scrollWidth - scroll.clientWidth;
            }, 50);
            
            // ESC to close
            document.addEventListener('keydown', handleConfluenceEscape);
        }
        
        function closeConfluenceModal() {
            const modal = document.getElementById('confluence-modal');
            modal.classList.remove('visible');
            confluenceModalOpen = false;
            
            // Clean up cursor labels
            const labelsContainer = document.getElementById('confluence-labels-container');
            if (labelsContainer) labelsContainer.innerHTML = '';
            
            // Clean up live cursor interval
            if (confluenceLiveCursorInterval) {
                clearInterval(confluenceLiveCursorInterval);
                confluenceLiveCursorInterval = null;
            }
            
            // Remove handlers
            document.removeEventListener('keydown', handleConfluenceEscape);
            
            const scroll = document.getElementById('confluence-scroll');
            if (confluenceScrollHandler) scroll.removeEventListener('scroll', confluenceScrollHandler);
            if (confluenceMoveHandler) scroll.removeEventListener('mousemove', confluenceMoveHandler);
        }
        
        function handleConfluenceEscape(e) {
            if (e.key === 'Escape') {
                closeConfluenceModal();
            }
        }
        
        // ===== SMT MODAL FUNCTIONS =====
        function openSmtModal() {
            const modal = document.getElementById('smt-modal-overlay');
            modal.classList.add('visible');
            renderSmtTable();
            document.addEventListener('keydown', handleSmtEscape);
        }
        
        function closeSmtModal(e) {
            if (e && e.target !== e.currentTarget) return;
            const modal = document.getElementById('smt-modal-overlay');
            modal.classList.remove('visible');
            document.removeEventListener('keydown', handleSmtEscape);
        }
        
        function handleSmtEscape(e) {
            if (e.key === 'Escape') {
                closeSmtModal();
            }
        }
        
        // SMT Modal Filter State
        const smtFilters = {
            nq: true,
            es: true,
            bull: true,
            bear: true,
            '1m': true,
            '5m': true,
            '15m': true,
            '1h': true,
            active: true,
            t1: true,
            t2: true,
            fail: true
        };
        
        function toggleSmtFilter(key) {
            smtFilters[key] = !smtFilters[key];
            const btn = document.getElementById('smt-filter-' + key);
            if (btn) {
                btn.classList.toggle('active', smtFilters[key]);
            }
            renderSmtTable();
        }
        
        function renderSmtTable() {
            const content = document.getElementById('smt-modal-content');
            
            if (!allData || allData.length === 0) {
                content.innerHTML = '<div style="color:#64748b;text-align:center;padding:40px;">No breaker data loaded. Load data first.</div>';
                return;
            }
            
            // Filter breakers with linked SMT and apply filters
            const breakersWithSmt = allData.filter(b => {
                if (!b.linkedSmtId) return false;
                
                // Apply symbol filter
                const sym = (b.symbol || '').toUpperCase();
                if (sym === 'NQ' && !smtFilters.nq) return false;
                if (sym === 'ES' && !smtFilters.es) return false;
                
                // Apply direction filter
                const dir = (b.dir || '').toLowerCase();
                if (dir === 'bull' && !smtFilters.bull) return false;
                if (dir === 'bear' && !smtFilters.bear) return false;
                
                // Apply timeframe filter
                const tf = (b.tf || '').toLowerCase();
                if (tf === '1m' && !smtFilters['1m']) return false;
                if (tf === '5m' && !smtFilters['5m']) return false;
                if (tf === '15m' && !smtFilters['15m']) return false;
                if (tf === '1h' && !smtFilters['1h']) return false;
                
                // Apply status filter
                const status = (b.status || 'ACTIVE').toUpperCase();
                if (status === 'ACTIVE' && !smtFilters.active) return false;
                if (status.includes('SUCCESS_T2') && !smtFilters.t2) return false;
                if (status.includes('SUCCESS_T1') && !status.includes('SUCCESS_T2') && !smtFilters.t1) return false;
                if (status.includes('FAILURE') && !smtFilters.fail) return false;
                
                return true;
            });
            
            // Group by SMT ID
            const smtGroups = {};
            breakersWithSmt.forEach(b => {
                const smtId = b.linkedSmtId;
                if (!smtGroups[smtId]) {
                    smtGroups[smtId] = [];
                }
                smtGroups[smtId].push(b);
            });
            
            // Sort groups by most recent breaker time
            const sortedSmtIds = Object.keys(smtGroups).sort((a, b) => {
                const maxA = Math.max(...smtGroups[a].map(br => br.startMin));
                const maxB = Math.max(...smtGroups[b].map(br => br.startMin));
                return maxB - maxA;
            });
            
            // Sort breakers within each group by time
            sortedSmtIds.forEach(smtId => {
                smtGroups[smtId].sort((a, b) => b.startMin - a.startMin);
            });
            
            // Summary counts
            const totalBreakers = allData.length;
            const totalWithSmt = allData.filter(b => b.linkedSmtId).length;
            const filteredBreakers = breakersWithSmt.length;
            const uniqueSmtCount = sortedSmtIds.length;
            
            // Status breakdown counts
            let activeCount = 0, t1Count = 0, t2Count = 0, failCount = 0;
            let nqCount = 0, esCount = 0;
            let bullCount = 0, bearCount = 0;
            let tf1mCount = 0, tf5mCount = 0, tf15mCount = 0, tf1hCount = 0;
            
            breakersWithSmt.forEach(b => {
                const status = (b.status || 'ACTIVE').toUpperCase();
                if (status.includes('SUCCESS_T2')) t2Count++;
                else if (status.includes('SUCCESS_T1')) t1Count++;
                else if (status.includes('FAILURE')) failCount++;
                else activeCount++;
                
                // Symbol counts
                const sym = (b.symbol || '').toUpperCase();
                if (sym === 'NQ') nqCount++;
                else if (sym === 'ES') esCount++;
                
                // Direction counts
                const dir = (b.dir || '').toLowerCase();
                if (dir === 'bull') bullCount++;
                else if (dir === 'bear') bearCount++;
                
                // Timeframe counts
                const tf = (b.tf || '').toLowerCase();
                if (tf === '1m') tf1mCount++;
                else if (tf === '5m') tf5mCount++;
                else if (tf === '15m') tf15mCount++;
                else if (tf === '1h') tf1hCount++;
            });
            
            // Calculate win rate (T1 + T2) / (T1 + T2 + Fail)
            const completedCount = t1Count + t2Count + failCount;
            const winRate = completedCount > 0 ? ((t1Count + t2Count) / completedCount * 100).toFixed(1) : '—';
            
            // Calculate percentages for each status
            const total = filteredBreakers || 1; // avoid division by zero
            const activePct = (activeCount / total * 100).toFixed(0);
            const t1Pct = (t1Count / total * 100).toFixed(0);
            const t2Pct = (t2Count / total * 100).toFixed(0);
            const failPct = (failCount / total * 100).toFixed(0);
            
            // Calculate time window from filtered breakers
            let windowStart = '—', windowEnd = '—';
            if (breakersWithSmt.length > 0) {
                const times = breakersWithSmt.map(b => b.startMin).filter(t => t > 0);
                if (times.length > 0) {
                    const minTime = Math.min(...times);
                    const maxTime = Math.max(...times);
                    const startDate = new Date(minTime * 60000);
                    const endDate = new Date(maxTime * 60000);
                    windowStart = startDate.toLocaleString('en-US', { 
                        month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: false 
                    });
                    windowEnd = endDate.toLocaleString('en-US', { 
                        month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: false 
                    });
                }
            }
            
            let html = `
                <div style="padding:12px 16px;background:#1e1e24;border-bottom:1px solid #333;">
                    <!-- Time Window -->
                    <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;margin-bottom:12px;padding-bottom:10px;border-bottom:1px solid #2a2a35;">
                        <div style="font-size:13px;color:#888;">
                            <span style="color:#22c55e;font-weight:600;">${uniqueSmtCount}</span> unique SMT signals
                            <span style="color:#555;margin:0 8px;">•</span>
                            <span style="color:#60a5fa;font-weight:600;">${filteredBreakers}</span> breakers
                            <span style="color:#555;margin-left:8px;">(${totalWithSmt} total with SMT)</span>
                        </div>
                        <div style="font-size:11px;color:#666;font-family:'Roboto Mono',monospace;">
                            <span style="color:#888;">Window:</span>
                            <span style="color:#fbbf24;">${windowStart}</span>
                            <span style="color:#555;margin:0 4px;">→</span>
                            <span style="color:#fbbf24;">${windowEnd}</span>
                        </div>
                    </div>
                    
                    <!-- Active Filters Summary -->
                    <div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:12px;padding-bottom:10px;border-bottom:1px solid #2a2a35;">
                        <span style="font-size:10px;color:#555;margin-right:4px;">FILTERS:</span>
                        ${smtFilters.nq ? '<span class="smt-filter-tag nq">NQ</span>' : ''}
                        ${smtFilters.es ? '<span class="smt-filter-tag es">ES</span>' : ''}
                        ${smtFilters.bull ? '<span class="smt-filter-tag bull">Bull</span>' : ''}
                        ${smtFilters.bear ? '<span class="smt-filter-tag bear">Bear</span>' : ''}
                        ${smtFilters['1m'] ? '<span class="smt-filter-tag tf">1m</span>' : ''}
                        ${smtFilters['5m'] ? '<span class="smt-filter-tag tf">5m</span>' : ''}
                        ${smtFilters['15m'] ? '<span class="smt-filter-tag tf">15m</span>' : ''}
                        ${smtFilters['1h'] ? '<span class="smt-filter-tag tf">1h</span>' : ''}
                        ${smtFilters.active ? '<span class="smt-filter-tag status-active">Active</span>' : ''}
                        ${smtFilters.t1 ? '<span class="smt-filter-tag status-t1">T1</span>' : ''}
                        ${smtFilters.t2 ? '<span class="smt-filter-tag status-t2">T2</span>' : ''}
                        ${smtFilters.fail ? '<span class="smt-filter-tag status-fail">Fail</span>' : ''}
                    </div>
                    
                    <!-- Status Row -->
                    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;">
                        <div class="smt-stat-box active">
                            <span class="smt-stat-count">${activeCount}</span>
                            <span class="smt-stat-pct">${activePct}%</span>
                            <span class="smt-stat-label">Active</span>
                        </div>
                        <div class="smt-stat-box t1">
                            <span class="smt-stat-count">${t1Count}</span>
                            <span class="smt-stat-pct">${t1Pct}%</span>
                            <span class="smt-stat-label">T1</span>
                        </div>
                        <div class="smt-stat-box t2">
                            <span class="smt-stat-count">${t2Count}</span>
                            <span class="smt-stat-pct">${t2Pct}%</span>
                            <span class="smt-stat-label">T2</span>
                        </div>
                        <div class="smt-stat-box fail">
                            <span class="smt-stat-count">${failCount}</span>
                            <span class="smt-stat-pct">${failPct}%</span>
                            <span class="smt-stat-label">Fail</span>
                        </div>
                        <div class="smt-stat-box winrate">
                            <span class="smt-stat-count">${winRate}${winRate !== '—' ? '%' : ''}</span>
                            <span class="smt-stat-label">Win Rate</span>
                        </div>
                        
                        <div style="width:1px;background:#333;margin:0 8px;"></div>
                        
                        <!-- Symbol -->
                        <div class="smt-stat-box nq">
                            <span class="smt-stat-count">${nqCount}</span>
                            <span class="smt-stat-label">NQ</span>
                        </div>
                        <div class="smt-stat-box es">
                            <span class="smt-stat-count">${esCount}</span>
                            <span class="smt-stat-label">ES</span>
                        </div>
                        
                        <div style="width:1px;background:#333;margin:0 8px;"></div>
                        
                        <!-- Direction -->
                        <div class="smt-stat-box bull">
                            <span class="smt-stat-count">${bullCount}</span>
                            <span class="smt-stat-label">Bull</span>
                        </div>
                        <div class="smt-stat-box bear">
                            <span class="smt-stat-count">${bearCount}</span>
                            <span class="smt-stat-label">Bear</span>
                        </div>
                        
                        <div style="width:1px;background:#333;margin:0 8px;"></div>
                        
                        <!-- Timeframes -->
                        <div class="smt-stat-box tf">
                            <span class="smt-stat-count">${tf1mCount}</span>
                            <span class="smt-stat-label">1m</span>
                        </div>
                        <div class="smt-stat-box tf">
                            <span class="smt-stat-count">${tf5mCount}</span>
                            <span class="smt-stat-label">5m</span>
                        </div>
                        <div class="smt-stat-box tf">
                            <span class="smt-stat-count">${tf15mCount}</span>
                            <span class="smt-stat-label">15m</span>
                        </div>
                        <div class="smt-stat-box tf">
                            <span class="smt-stat-count">${tf1hCount}</span>
                            <span class="smt-stat-label">1h</span>
                        </div>
                    </div>
                </div>
                <div style="padding:16px;">
            `;
            
            if (sortedSmtIds.length === 0) {
                html += '<div style="text-align:center;color:#555;padding:40px;">No breakers match current filters</div>';
            } else {
                for (const smtId of sortedSmtIds) {
                    const breakers = smtGroups[smtId];
                    
                    html += `
                        <div class="smt-group-card">
                            <div class="smt-group-header">
                                <div class="smt-group-id">${smtId}</div>
                                <div class="smt-group-count">${breakers.length} breaker${breakers.length > 1 ? 's' : ''}</div>
                            </div>
                            <div class="smt-group-breakers">
                    `;
                    
                    for (const breaker of breakers) {
                        const time = new Date(breaker.startMin * 60000);
                        const timeStr = time.toLocaleString('en-US', { 
                            month: 'numeric', day: 'numeric',
                            hour: '2-digit', minute: '2-digit', hour12: false 
                        });
                        
                        const symClass = (breaker.symbol || '').toLowerCase();
                        const dirClass = (breaker.dir || '').toLowerCase();
                        
                        // Parse status for display
                        const status = (breaker.status || 'ACTIVE').toUpperCase();
                        let statusLabel, statusClass;
                        if (status.includes('SUCCESS_T2')) {
                            statusLabel = 'T2';
                            statusClass = 'success-t2';
                        } else if (status.includes('SUCCESS_T1')) {
                            statusLabel = 'T1';
                            statusClass = 'success-t1';
                        } else if (status.includes('FAILURE')) {
                            statusLabel = 'FAIL';
                            statusClass = 'failure';
                        } else {
                            statusLabel = 'ACTIVE';
                            statusClass = 'active';
                        }
                        
                        html += `
                            <div class="smt-breaker-row">
                                <div class="smt-breaker-time">${timeStr}</div>
                                <div class="smt-breaker-id">${breaker.id || '—'}</div>
                                <div class="smt-breaker-badges">
                                    <span class="smt-badge ${symClass}">${breaker.symbol || '—'}</span>
                                    <span class="smt-badge tf">${breaker.tf || '—'}</span>
                                    <span class="smt-badge ${dirClass}">${(breaker.dir || '').toUpperCase()}</span>
                                    <span class="smt-badge status-${statusClass}">${statusLabel}</span>
                                </div>
                            </div>
                        `;
                    }
                    
                    html += `
                            </div>
                        </div>
                    `;
                }
            }
            
            html += '</div>';
            content.innerHTML = html;
        }
        
        function findScoringRule(rules, partialKey) {
            // Find a scoring rule by partial key match (e.g., '1M_SMT' matches 'S02_1M_SMT')
            for (const [key, value] of Object.entries(rules)) {
                if (key.includes(partialKey)) {
                    return value;
                }
            }
            return null;
        }
        
        function renderScoreCell(rule) {
            if (!rule) {
                return '<span style="color:#64748b;">—</span>';
            }
            
            const score = rule.score ?? 0;
            let cls = 'none';
            if (score > 0) cls = 'sync';
            else if (score < 0) cls = 'div';
            
            const reason = rule.reason || '';
            // Truncate reason for display
            const shortReason = reason.length > 20 ? reason.substring(0, 20) + '...' : reason;
            
            return `<span class="smt-badge ${cls}" title="${reason}">${score > 0 ? '+' : ''}${score}</span>`;
        }
        
        function renderConfluenceModal() {
            if (allData.length === 0) {
                document.getElementById('confluence-chart-inner').innerHTML = 
                    '<div class="confluence-no-data">No breaker data</div>';
                return;
            }
            
            // Calculate time range
            const minTime = Math.min(...allData.map(d => d.startMin));
            let maxTime = Math.max(...allData.map(d => d.endMin));
            
            // In live mode, extend to current time
            if (isLive) {
                const now = new Date();
                const currentMin = Math.floor(now.getTime() / 60000);
                maxTime = Math.max(maxTime, currentMin);
            }
            
            const chartWidth = (maxTime - minTime + 1) * CONFLUENCE_PPM; // +1 min padding
            
            // Render time header
            renderConfluenceTimeHeader(minTime, maxTime, chartWidth);
            
            // Sort breakers by priority (1m→4h, NQ→ES, bull→bear), then by start time
            // Higher priority breakers get first chance at top rows
            const tfOrder = { '1m': 1, '5m': 2, '15m': 3, '1h': 4, '1hr': 4, '4h': 5, '4hr': 5 };
            const symOrder = { 'NQ': 1, 'ES': 2 };
            
            const sortedBreakers = [...allData].sort((a, b) => {
                const tfA = tfOrder[a.tf.replace('hr', 'h')] || 99;
                const tfB = tfOrder[b.tf.replace('hr', 'h')] || 99;
                if (tfA !== tfB) return tfA - tfB;
                const symA = symOrder[a.symbol] || 99;
                const symB = symOrder[b.symbol] || 99;
                if (symA !== symB) return symA - symB;
                if (a.dir !== b.dir) return a.dir === 'bull' ? -1 : 1;
                return a.startMin - b.startMin;
            });
            
            // Position cards - greedy assignment by priority
            // Higher priority breakers are processed first and get top rows
            const cardHeight = CONFLUENCE_CARD_HEIGHT + CONFLUENCE_CARD_GAP;
            const rowRanges = []; // Track occupied time ranges per row: [{start, end}, ...]
            
            const chartInner = document.getElementById('confluence-chart-inner');
            chartInner.style.width = (chartWidth + 20) + 'px';
            
            let html = '';
            let maxY = 0;
            
            sortedBreakers.forEach(breaker => {
                const startX = (breaker.startMin - minTime) * CONFLUENCE_PPM + 12;
                const width = Math.max((breaker.endMin - breaker.startMin) * CONFLUENCE_PPM, 100);
                const endX = startX + width;
                
                // Find first row where this breaker fits (no overlap)
                let row = 0;
                let foundRow = false;
                
                while (!foundRow) {
                    if (!rowRanges[row]) {
                        rowRanges[row] = [];
                        foundRow = true;
                    } else {
                        // Check if any existing range in this row overlaps
                        let overlaps = false;
                        for (const range of rowRanges[row]) {
                            if (!(endX <= range.start || startX >= range.end)) {
                                overlaps = true;
                                break;
                            }
                        }
                        if (!overlaps) {
                            foundRow = true;
                        } else {
                            row++;
                        }
                    }
                }
                
                // Add this breaker's range to the row
                rowRanges[row].push({ start: startX - 5, end: endX + 15 }); // padding on both sides
                
                const y = row * cardHeight;
                maxY = Math.max(maxY, y + cardHeight);
                
                html += generateConfluenceCard(breaker, startX, y, width, minTime);
            });
            
            chartInner.innerHTML = html;
            chartInner.style.minHeight = (maxY + 40) + 'px';
        }
        
        function renderConfluenceTimeHeader(minTime, maxTime, chartWidth) {
            const timeInner = document.getElementById('confluence-time-inner');
            timeInner.style.width = (chartWidth + 20) + 'px';
            
            let html = '';
            // Tick every 5 minutes
            for (let t = Math.ceil(minTime / 5) * 5; t <= maxTime; t += 5) {
                const x = (t - minTime) * CONFLUENCE_PPM + 12; // +12 to align with cards
                const timeStr = minToTime(t);
                html += `<span class="confluence-time-tick" style="left:${x}px">${timeStr}</span>`;
            }
            
            timeInner.innerHTML = html;
        }
        
        function generateConfluenceCard(breaker, x, y, width, globalMinTime) {
            const tf = breaker.tf.replace('hr', 'h');
            const tfDisplay = TF_DISPLAY[tf] || breaker.tf;
            const tfColor = TF_COLORS[breaker.tf] || '#888';
            const isBull = breaker.dir === 'bull';
            const dirColor = isBull ? '#4ade80' : '#f87171';
            const dirArrow = isBull ? '▲' : '▼';
            const events = breaker.events;
            
            // Parse status for display
            const parsed = parseStatus(breaker.status);
            let statusBadge = '';
            if (parsed.isSuccess) {
                const statusText = parsed.icon === 'T2' ? 'T2 WIN' : 'T1 WIN';
                statusBadge = `<span class="ccard-status success">${statusText}</span>`;
            } else if (parsed.isFail) {
                statusBadge = `<span class="ccard-status fail">FAIL</span>`;
            }
            
            // Zone info
            const zonePct = Math.min(breaker.zonePct || 0, 100);
            const zoneSize = breaker.zoneSize || 0;
            const breakerHigh = breaker.breakerHigh || breaker.price || 0;
            const sweepLow = breaker.sweepLow || 0;
            const zonePctClass = zonePct >= 50 ? 'bad' : (zonePct > 0 ? 'partial' : '');
            
            // Zone display
            const zoneHtml = `
                <span class="ccard-zone-info">
                    <span title="H2 (Breaker High)">${Math.round(breakerHigh)}</span>
                    <span style="color:#444">|</span>
                    <span class="ccard-zone-pct ${zonePctClass}" title="Zone penetration">${zonePct}%</span>
                    <span style="color:#444">|</span>
                    <span title="Zone size">${zoneSize}z</span>
                </span>
            `;
            
            if (!events || events.length < 2) {
                return `
                    <div class="confluence-card" data-breaker-id="${breaker.id}" style="left:${x}px; top:${y}px; width:${width}px;">
                        <div class="ccard-header" style="border-left-color:${tfColor}">
                            <span class="ccard-tf" style="color:${tfColor}">${tfDisplay}</span>
                            <span class="ccard-sym">${breaker.symbol}</span>
                            <span class="ccard-dir" style="color:${dirColor}">${dirArrow}</span>
                            <span class="ccard-spacer"></span>
                            ${zoneHtml}
                            ${statusBadge}
                        </div>
                        <div class="confluence-card-body">
                            <div style="display:flex; align-items:center; justify-content:center; height:100%; color:#333;">No data</div>
                        </div>
                    </div>
                `;
            }
            
            const chart = generateConfluenceChart(breaker, dirColor, width, tfDisplay, tfColor);
            
            return `
                <div class="confluence-card" data-breaker-id="${breaker.id}" style="left:${x}px; top:${y}px; width:${width}px;">
                    <div class="ccard-header" style="border-left-color:${tfColor}">
                        <span class="ccard-tf" style="color:${tfColor}">${tfDisplay}</span>
                        <span class="ccard-sym">${breaker.symbol}</span>
                        <span class="ccard-dir" style="color:${dirColor}">${dirArrow}</span>
                        <span class="ccard-spacer"></span>
                        ${zoneHtml}
                        ${statusBadge}
                    </div>
                    <div class="confluence-card-body">
                        ${chart}
                    </div>
                </div>
            `;
        }
        
        function generateConfluenceChart(breaker, dirColor, cardWidth, tfDisplay, tfColor) {
            const events = breaker.events;
            const width = cardWidth;
            const height = 220;
            // Adjust padding for narrow cards - no bottom padding needed without time labels
            const padRight = Math.min(50, cardWidth * 0.13);
            const padLeft = Math.min(32, cardWidth * 0.09);
            const padding = { top: 12, right: padRight, bottom: 8, left: padLeft };
            const chartWidth = Math.max(width - padding.left - padding.right, 20);
            const chartHeight = height - padding.top - padding.bottom;
            
            const minTime = events[0].absMin;
            const maxTime = events[events.length - 1].absMin;
            const timeRange = maxTime - minTime || 1;
            
            const breakerPrice = breaker.price || 0;
            const isBull = breaker.dir === 'bull';
            
            const lastEvent = events[events.length - 1];
            const currentPrice = lastEvent.price || 0;
            
            // Dynamic Y-axis: 0-3.2 (T2) unless fib exceeds 3.2
            const maxFibInData = Math.max(...events.map(e => Math.max(e.fib || 0, e.maxFib || 0)));
            const fibCeil = maxFibInData > 3.2 ? Math.ceil(maxFibInData) : 3.2;
            
            const fibToY = (fib) => {
                if (isBull) {
                    return padding.top + chartHeight - (fib / fibCeil) * chartHeight;
                } else {
                    return padding.top + (fib / fibCeil) * chartHeight;
                }
            };
            
            let sampledEvents = events;
            if (events.length > 100) {
                const step = Math.ceil(events.length / 80);
                sampledEvents = events.filter((e, i) => i === 0 || i === events.length - 1 || i % step === 0);
            }
            
            const fibPoints = sampledEvents.map(e => ({
                x: padding.left + ((e.absMin - minTime) / timeRange) * chartWidth,
                y: fibToY(e.fib || 0),
                fib: e.fib || 0
            }));
            
            const peakPoints = sampledEvents.map(e => ({
                x: padding.left + ((e.absMin - minTime) / timeRange) * chartWidth,
                y: fibToY(e.maxFib || e.fib || 0),
                fib: e.maxFib || e.fib || 0
            }));
            
            let peakX = fibPoints[0].x, peakY = fibPoints[0].y, peakFib = 0;
            fibPoints.forEach(p => {
                if (p.fib > peakFib) { peakFib = p.fib; peakX = p.x; peakY = p.y; }
            });
            
            const fibPath = fibPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            const peakPath = peakPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            const zeroY = fibToY(0);
            const areaPath = fibPath + ` L ${fibPoints[fibPoints.length-1].x} ${zeroY} L ${fibPoints[0].x} ${zeroY} Z`;
            const breakerY = fibToY(1.0);
            
            // Breaker Zone - calculated from actual zone data
            // The ID has two price fields that need to be interpreted based on direction
            const fibRange = breaker.fibRange || 1;
            const zoneSize = breaker.zoneSize || 0;
            const price1 = breaker.sweepLow || 0;
            const price2 = breaker.breakerHigh || breaker.price || 0;
            
            // Calculate zone fib values based on direction
            // Use min/max to ensure correct price interpretation regardless of ID field order
            let zoneTopFib, zoneBottomFib;
            if (isBull) {
                // Bullish: fib 0 at lower price, zone at higher price going down
                const fib0Price = Math.min(price1, price2);
                const breakerPrice = Math.max(price1, price2);
                zoneTopFib = fibRange > 0 ? (breakerPrice - fib0Price) / fibRange : 0;
                zoneBottomFib = fibRange > 0 ? (breakerPrice - zoneSize - fib0Price) / fibRange : 0;
            } else {
                // Bearish: fib 0 at higher price, zone at lower price going up
                const fib0Price = Math.max(price1, price2);
                const breakerPrice = Math.min(price1, price2);
                zoneBottomFib = fibRange > 0 ? (fib0Price - breakerPrice) / fibRange : 0;
                zoneTopFib = fibRange > 0 ? (fib0Price - breakerPrice - zoneSize) / fibRange : 0;
            }
            
            const zoneTopY = fibToY(zoneTopFib);
            const zoneBottomY = fibToY(zoneBottomFib);
            const zoneMinY = Math.min(zoneTopY, zoneBottomY);
            const zoneHeight = Math.max(Math.abs(zoneBottomY - zoneTopY), 4); // Ensure minimum 4px height
            const dotColor = isBull ? 'rgba(74, 222, 128, 0.4)' : 'rgba(248, 113, 113, 0.4)';
            const zoneBorderColor = isBull ? 'rgba(74, 222, 128, 0.7)' : 'rgba(248, 113, 113, 0.7)';
            const zoneLabelColor = isBull ? 'rgba(74, 222, 128, 0.9)' : 'rgba(248, 113, 113, 0.9)';
            const patternId = 'zone-dots-' + breaker.id.replace(/[^a-zA-Z0-9]/g, '');
            const zoneRect = `
                <defs>
                    <pattern id="${patternId}" width="8" height="8" patternUnits="userSpaceOnUse">
                        <circle cx="2" cy="2" r="1" fill="${dotColor}"/>
                    </pattern>
                </defs>
                <rect x="${padding.left}" y="${zoneMinY}" 
                      width="${chartWidth}" height="${zoneHeight}" 
                      fill="url(#${patternId})"/>
                <line x1="${padding.left}" y1="${zoneTopY}" x2="${padding.left + chartWidth}" y2="${zoneTopY}" 
                      stroke="${zoneBorderColor}" stroke-width="1.5"/>
                <line x1="${padding.left}" y1="${zoneBottomY}" x2="${padding.left + chartWidth}" y2="${zoneBottomY}" 
                      stroke="${zoneBorderColor}" stroke-width="1" stroke-dasharray="4,3"/>
                <text x="${padding.left + 4}" y="${zoneMinY + 14}" 
                      fill="${zoneLabelColor}" font-size="10" font-family="Roboto Mono" font-weight="600">ZONE</text>
            `;
            
            // Breaker Fib highlight line (entry level of the zone)
            // For bullish: top of zone (higher price), for bearish: bottom of zone (lower price)
            const breakerFibY = isBull ? zoneTopY : zoneBottomY;
            const breakerFibLabel = (isBull ? zoneTopFib : zoneBottomFib).toFixed(2);
            const breakerFibLine = `
                <line x1="${padding.left}" y1="${breakerFibY}" x2="${padding.left + chartWidth}" y2="${breakerFibY}" 
                      stroke="${dirColor}" stroke-width="2" stroke-dasharray="6,3"/>
                <rect x="${padding.left + chartWidth + 2}" y="${breakerFibY - 8}" width="32" height="16" rx="2" 
                      fill="${isBull ? 'rgba(74, 222, 128, 0.2)' : 'rgba(248, 113, 113, 0.2)'}" stroke="${dirColor}" stroke-width="1"/>
                <text x="${padding.left + chartWidth + 18}" y="${breakerFibY + 4}" text-anchor="middle" 
                      fill="${dirColor}" font-size="10" font-family="Roboto Mono" font-weight="700">${breakerFibLabel}</text>
            `;
            
            let yGrid = '';
            // Generate grid values: 0, 1, 2, 3, and fibCeil (3.2 for T2 or higher if exceeded)
            const gridVals = [0, 1, 2, 3];
            if (fibCeil > 3) gridVals.push(fibCeil);
            gridVals.forEach(val => {
                const y = fibToY(val);
                const isBreaker = val === 1;
                const isTop = val === fibCeil && val > 3;
                // Top fib uses purple dotted line to match T2
                const lineColor = isBreaker ? '#444' : (isTop ? '#7c3aed' : '#1e1e21');
                const lineWidth = 0.5;
                const textColor = isBreaker ? '#666' : (isTop ? '#9d7aed' : '#3a3a3e');
                const fontWeight = isBreaker ? 500 : 400;
                const dashArray = isTop ? ' stroke-dasharray="4,3"' : '';
                yGrid += `<line x1="${padding.left}" y1="${y}" x2="${padding.left + chartWidth}" y2="${y}" stroke="${lineColor}" stroke-width="${lineWidth}"${dashArray}/>`;
                yGrid += `<text x="${padding.left - 3}" y="${y + 3}" text-anchor="end" fill="${textColor}" font-size="9" font-family="Roboto Mono" font-weight="${fontWeight}">${val.toFixed(1)}</text>`;
            });
            
            const breakerPriceLabel = `<text x="${width - 2}" y="${breakerY + 3}" text-anchor="end" fill="#666" font-size="10" font-family="Roboto Mono">${Math.round(breakerPrice)}</text>`;
            
            let dots = '';
            let dotPoints = peakPoints;
            if (peakPoints.length > 12) {
                const step = Math.ceil(peakPoints.length / 10);
                dotPoints = peakPoints.filter((p, i) => i === 0 || i === peakPoints.length - 1 || i % step === 0);
            }
            dotPoints.forEach(p => { dots += `<circle cx="${p.x}" cy="${p.y}" r="2" fill="${dirColor}"/>`; });
            
            const lastPoint = fibPoints[fibPoints.length - 1];
            const lastPointY = lastPoint ? lastPoint.y : 0;
            const currentPriceLabel = lastPoint && currentPrice > 0 ? 
                `<text x="${width - 2}" y="${lastPointY + 3}" text-anchor="end" fill="#fb923c" font-size="10" font-family="Roboto Mono" font-weight="500">${Math.round(currentPrice)}</text>` : '';
            
            return `
                <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="display:block; width:100%; height:220px;">
                    ${zoneRect}
                    ${breakerFibLine}
                    ${yGrid}
                    <path d="${areaPath}" fill="${dirColor}" fill-opacity="0.15"/>
                    <path d="${peakPath}" fill="none" stroke="${dirColor}" stroke-width="1.5" stroke-dasharray="3,2"/>
                    <path d="${fibPath}" fill="none" stroke="${dirColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    ${dots}
                    <circle cx="${peakX}" cy="${peakY}" r="5" fill="${dirColor}" stroke="#0c0c0f" stroke-width="1.5"/>
                    <text x="${peakX}" y="${peakY + (isBull ? -7 : 14)}" text-anchor="middle" fill="${dirColor}" font-size="11" font-family="Roboto Mono" font-weight="600">${peakFib.toFixed(2)}</text>
                    ${lastPoint ? `<circle cx="${lastPoint.x}" cy="${lastPoint.y}" r="3" fill="#fb923c"/>` : ''}
                    ${breakerPriceLabel}
                    ${currentPriceLabel}
                </svg>
            `;
        }
        
        function setupConfluenceHandlers() {
            const scroll = document.getElementById('confluence-scroll');
            const timeHeader = document.getElementById('confluence-time-header');
            const cursorLine = document.getElementById('confluence-cursor-line');
            const cursorTime = document.getElementById('confluence-cursor-time');
            const labelsContainer = document.getElementById('confluence-labels-container');
            
            let lastMouseX = null;
            let lastMouseY = null;
            let isLiveCursor = true; // Start with live cursor
            
            // Function to update cursor labels at a specific X position and time
            function updateCursorLabelsAtTime(xPos, cursorMin, isLiveMode) {
                const rect = scroll.getBoundingClientRect();
                const timeHeaderRect = timeHeader.getBoundingClientRect();
                
                // Clear all existing cursor labels
                labelsContainer.innerHTML = '';
                
                // Position cursor line
                cursorLine.style.left = xPos + 'px';
                cursorLine.classList.add('visible');
                if (isLiveMode) {
                    cursorLine.classList.add('live');
                    cursorTime.classList.add('live');
                } else {
                    cursorLine.classList.remove('live');
                    cursorTime.classList.remove('live');
                }
                
                // Show time badge
                cursorTime.textContent = minToTime(cursorMin);
                cursorTime.style.left = xPos + 'px';
                cursorTime.style.top = (timeHeaderRect.top + timeHeaderRect.height / 2 - 10) + 'px';
                cursorTime.style.display = 'block';
                
                // Find all cards and highlight those that cursor passes through
                const cards = document.querySelectorAll('.confluence-card');
                const highlightClass = isLiveMode ? 'cursor-highlight-live' : 'cursor-highlight';
                
                cards.forEach(card => {
                    const cardRect = card.getBoundingClientRect();
                    
                    // Remove previous highlights
                    card.classList.remove('cursor-highlight', 'cursor-highlight-live');
                    
                    // Check if cursor X is within this card's horizontal bounds
                    if (xPos >= cardRect.left && xPos <= cardRect.right) {
                        // Add highlight glow to card
                        card.classList.add(highlightClass);
                        
                        // Create info label for this card
                        const breakerId = card.dataset.breakerId;
                        const breaker = allData.find(b => b.id === breakerId);
                        
                        if (breaker && breaker.events && breaker.events.length > 0) {
                            const tf = breaker.tf.replace('hr', 'h').toUpperCase();
                            const tfColor = TF_COLORS[breaker.tf] || '#888';
                            const dirColor = breaker.dir === 'bull' ? '#4ade80' : '#f87171';
                            const dirArrow = breaker.dir === 'bull' ? '▲' : '▼';
                            
                            // Find fib value at cursor time
                            const events = breaker.events;
                            let fibAtCursor = 0;
                            let peakAtCursor = 0;
                            let priceAtCursor = 0;
                            
                            for (let i = 0; i < events.length; i++) {
                                if (events[i].absMin <= cursorMin) {
                                    fibAtCursor = events[i].fib || 0;
                                    peakAtCursor = events[i].maxFib || events[i].fib || 0;
                                    priceAtCursor = events[i].price || 0;
                                }
                            }
                            
                            // Zone info
                            const breakerHigh = breaker.breakerHigh || breaker.price || 0;
                            const sweepLow = breaker.sweepLow || 0;
                            const zonePct = Math.min(breaker.zonePct || 0, 100);
                            const zoneSize = breaker.zoneSize || 0;
                            
                            // Status indicator
                            const parsed = parseStatus(breaker.status);
                            let statusHtml = '';
                            if (parsed.isSuccess) {
                                const statusText = parsed.icon === 'T2' ? 'T2' : 'T1';
                                statusHtml = `<span style="color:#16a34a;font-weight:700">${statusText}✓</span>`;
                            } else if (parsed.isFail) {
                                statusHtml = `<span style="color:#dc2626;font-weight:700">✗</span>`;
                            } else {
                                statusHtml = '';
                            }
                            
                            // Create lean label
                            const label = document.createElement('div');
                            label.className = 'confluence-cursor-label' + (isLiveMode ? ' live' : '');
                            
                            // Compact single-line format - dark colors for light background
                            const fibColor = breaker.dir === 'bull' ? '#16a34a' : '#dc2626';
                            const zonePctColor = zonePct >= 50 ? '#dc2626' : (zonePct > 0 ? '#ca8a04' : '#6b7280');
                            label.innerHTML = `
                                <span style="color:${tfColor};font-weight:700">${tf}</span>
                                <span style="color:#555">${breaker.symbol}</span>
                                <span style="color:${fibColor};font-weight:700">${dirArrow}</span>
                                ${statusHtml}
                                <span style="color:#aaa">│</span>
                                <span style="color:${fibColor};font-weight:600">${fibAtCursor.toFixed(2)}</span><span style="color:#888">/</span><span style="color:#333">${peakAtCursor.toFixed(2)}</span>
                                <span style="color:#aaa">│</span>
                                <span style="color:${zonePctColor};font-weight:600">${zonePct}%</span>
                                <span style="color:#aaa">│</span>
                                <span style="color:#c2410c;font-weight:600">${Math.round(priceAtCursor)}</span>
                            `;
                            
                            // Position label to the LEFT of cursor
                            label.style.top = (cardRect.top + 38) + 'px';
                            
                            // Temporarily add to measure width
                            label.style.visibility = 'hidden';
                            labelsContainer.appendChild(label);
                            const labelWidth = label.offsetWidth;
                            label.style.visibility = 'visible';
                            
                            // Position to LEFT of cursor line
                            label.style.left = (xPos - labelWidth - 8) + 'px';
                        }
                    }
                });
            }
            
            // Function to update cursor labels (for mouse movement)
            function updateCursorLabels(x, y) {
                const rect = scroll.getBoundingClientRect();
                
                if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                    // Calculate time from mouse position (24px padding)
                    const scrollX = scroll.scrollLeft + (x - rect.left) - 24;
                    const minTime = allData.length > 0 ? Math.min(...allData.map(d => d.startMin)) : 0;
                    const cursorMin = Math.round(minTime + Math.max(0, scrollX) / CONFLUENCE_PPM);
                    
                    updateCursorLabelsAtTime(x, cursorMin, false);
                } else {
                    cursorLine.classList.remove('visible');
                    cursorTime.style.display = 'none';
                    labelsContainer.innerHTML = '';
                    // Clear card highlights
                    document.querySelectorAll('.confluence-card').forEach(card => {
                        card.classList.remove('cursor-highlight', 'cursor-highlight-live');
                    });
                }
            }
            
            // Function to show live cursor at current time
            function showLiveCursor() {
                if (!isLiveCursor || !isLive) return;
                
                const rect = scroll.getBoundingClientRect();
                const minTime = allData.length > 0 ? Math.min(...allData.map(d => d.startMin)) : 0;
                const now = new Date();
                const currentMin = Math.floor(now.getTime() / 60000);
                
                // Calculate X position for current time (24px padding matches CSS)
                const xOffset = (currentMin - minTime) * CONFLUENCE_PPM + 12 - scroll.scrollLeft;
                const xPos = rect.left + xOffset;
                
                // Only show if cursor is within view
                if (xPos >= rect.left && xPos <= rect.right) {
                    updateCursorLabelsAtTime(xPos, currentMin, true);
                }
            }
            
            // Start live cursor update interval
            if (isLive) {
                // Initial show
                setTimeout(showLiveCursor, 100);
                
                // Update every second
                confluenceLiveCursorInterval = setInterval(showLiveCursor, 1000);
            }
            
            // Sync time header scroll AND update cursor labels
            confluenceScrollHandler = () => {
                timeHeader.scrollLeft = scroll.scrollLeft;
                // Update labels on scroll
                if (isLiveCursor && isLive) {
                    requestAnimationFrame(showLiveCursor);
                } else if (lastMouseX !== null && lastMouseY !== null) {
                    requestAnimationFrame(() => {
                        updateCursorLabels(lastMouseX, lastMouseY);
                    });
                }
            };
            scroll.addEventListener('scroll', confluenceScrollHandler);
            
            // Cursor line and on-card labels
            confluenceMoveHandler = (e) => {
                // Switch from live to user-controlled cursor
                if (isLiveCursor) {
                    isLiveCursor = false;
                    if (confluenceLiveCursorInterval) {
                        clearInterval(confluenceLiveCursorInterval);
                        confluenceLiveCursorInterval = null;
                    }
                }
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                updateCursorLabels(e.clientX, e.clientY);
            };
            scroll.addEventListener('mousemove', confluenceMoveHandler);
            
            scroll.addEventListener('mouseleave', () => {
                lastMouseX = null;
                lastMouseY = null;
                
                // Return to live cursor when mouse leaves
                if (isLive) {
                    isLiveCursor = true;
                    if (!confluenceLiveCursorInterval) {
                        confluenceLiveCursorInterval = setInterval(showLiveCursor, 1000);
                    }
                    showLiveCursor();
                } else {
                    cursorLine.classList.remove('visible');
                    cursorTime.style.display = 'none';
                    labelsContainer.innerHTML = '';
                    // Clear card highlights
                    document.querySelectorAll('.confluence-card').forEach(card => {
                        card.classList.remove('cursor-highlight', 'cursor-highlight-live');
                    });
                }
            });
            
            // Also update on wheel for Mac trackpad
            scroll.addEventListener('wheel', () => {
                if (lastMouseX !== null && lastMouseY !== null) {
                    // Double requestAnimationFrame for Mac compatibility
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            updateCursorLabels(lastMouseX, lastMouseY);
                        });
                    });
                }
            }, { passive: true });
        }
        
        function renderZoneChart(dimData, isSupport) {
            if (!dimData.zones || dimData.zones.length === 0) {
                if (dimData.target) {
                    // Resistance with no obstacles - show clear path
                    return `
                        <div class="analysis-zone-chart">
                            <div class="analysis-zone-chart-title">Visual: Entry to Target</div>
                            <div style="height: 100px; position: relative; display: flex; align-items: center; justify-content: center;">
                                <svg width="100%" height="100" viewBox="0 0 400 100">
                                    <defs>
                                        <linearGradient id="clearPath" x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:0.8" />
                                            <stop offset="100%" style="stop-color:#4ade80;stop-opacity:0.8" />
                                        </linearGradient>
                                    </defs>
                                    <line x1="50" y1="50" x2="350" y2="50" stroke="url(#clearPath)" stroke-width="3" stroke-dasharray="8,4"/>
                                    <circle cx="50" cy="50" r="8" fill="#60a5fa"/>
                                    <text x="50" y="75" text-anchor="middle" fill="#60a5fa" font-size="10" font-family="Roboto Mono">Entry</text>
                                    <polygon points="350,50 340,44 340,56" fill="#4ade80"/>
                                    <circle cx="350" cy="50" r="8" fill="#4ade80"/>
                                    <text x="350" y="75" text-anchor="middle" fill="#4ade80" font-size="10" font-family="Roboto Mono">Target</text>
                                    <text x="200" y="30" text-anchor="middle" fill="#4ade80" font-size="11" font-family="Roboto Mono">✓ Clear Path</text>
                                </svg>
                            </div>
                        </div>
                    `;
                }
                return '';
            }
            
            // Calculate price range for chart
            const entry = dimData.entry;
            const target = dimData.target;
            const stop = dimData.stop || (isSupport ? entry - 20 : null);
            
            let allPrices = [entry];
            if (target) allPrices.push(target);
            if (stop) allPrices.push(stop);
            dimData.zones.forEach(z => {
                allPrices.push(z.high, z.low);
            });
            
            const minPrice = Math.min(...allPrices) - 5;
            const maxPrice = Math.max(...allPrices) + 5;
            const priceRange = maxPrice - minPrice;
            const chartHeight = 250;
            
            const priceToY = (price) => {
                return chartHeight - ((price - minPrice) / priceRange * chartHeight);
            };
            
            let zonesHtml = '';
            dimData.zones.forEach(zone => {
                const topY = priceToY(zone.high);
                const bottomY = priceToY(zone.low);
                const height = Math.max(bottomY - topY, 8);
                const isBull = zone.type.toLowerCase().includes('bull');
                const tfClass = 'tf-' + zone.tf.toLowerCase();
                
                zonesHtml += `
                    <div class="analysis-zone-chart-zone ${isBull ? 'bull' : 'bear'} ${tfClass}" 
                         style="top: ${topY}px; height: ${height}px;">
                        <span class="analysis-zone-chart-zone-tf">${zone.tf.toUpperCase()}</span>
                        <span style="margin-left: 8px; opacity: 0.7;">${zone.low.toLocaleString()}-${zone.high.toLocaleString()}</span>
                    </div>
                `;
            });
            
            // Entry line
            const entryY = priceToY(entry);
            zonesHtml += `
                <div class="analysis-zone-chart-line entry" style="top: ${entryY}px;"></div>
                <div class="analysis-zone-chart-current" style="top: ${entryY}px;"></div>
                <div class="analysis-zone-chart-label entry" style="top: ${entryY}px;">► Entry ${entry.toLocaleString()}</div>
            `;
            
            // Target line
            if (target) {
                const targetY = priceToY(target);
                zonesHtml += `
                    <div class="analysis-zone-chart-line target" style="top: ${targetY}px;"></div>
                    <div class="analysis-zone-chart-label target" style="top: ${targetY}px;">◆ Target ${target.toLocaleString()}</div>
                `;
            }
            
            // Stop line (for support)
            if (stop && isSupport) {
                const stopY = priceToY(stop);
                zonesHtml += `
                    <div class="analysis-zone-chart-line stop" style="top: ${stopY}px;"></div>
                    <div class="analysis-zone-chart-label stop" style="top: ${stopY}px;">■ Stop ${stop.toLocaleString()}</div>
                `;
            }
            
            // Price axis labels
            const priceSteps = 5;
            let axisHtml = '';
            for (let i = 0; i <= priceSteps; i++) {
                const price = maxPrice - (priceRange * i / priceSteps);
                const isEntry = Math.abs(price - entry) < priceRange * 0.05;
                const isTarget = target && Math.abs(price - target) < priceRange * 0.05;
                let priceClass = '';
                if (isEntry) priceClass = 'entry';
                else if (isTarget) priceClass = 'target';
                axisHtml += `<div class="analysis-zone-chart-price ${priceClass}">${price.toFixed(0)}</div>`;
            }
            
            return `
                <div class="analysis-zone-chart">
                    <div class="analysis-zone-chart-title">Visual: ${isSupport ? 'Support Zones Below Entry' : 'Resistance Zones to Target'}</div>
                    <div class="analysis-zone-chart-inner">
                        <div class="analysis-zone-chart-axis">
                            ${axisHtml}
                        </div>
                        <div class="analysis-zone-chart-body" style="height: ${chartHeight}px;">
                            ${zonesHtml}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function getExampleData() {
            // Complete Firebase schema from QuantConnect
            return {
                breaker_id: "NQ_1m_20250115_1205",
                confirmation_time: "2025-01-15T12:05",
                decision: "EXECUTE",
                decision_score: 18,
                dimensions: {
                    gate: {
                        g1_trading_hours: {
                            status: "PASS",
                            current_time: "12:05 PM ET",
                            session: "NY_LUNCH",
                            is_tradeable: true,
                            in_no_trade_window: false,
                            no_trade_window_name: null,
                            reason: "Within trading hours"
                        },
                        g2_news_blackout: {
                            status: "PASS",
                            is_clear: true,
                            next_event: null,
                            minutes_until: null,
                            reason: "No scheduled events"
                        },
                        g3_price_volatility: {
                            status: "PASS",
                            nq: { atr_ratio: 1.2, status: "NORMAL" },
                            es: { atr_ratio: 1.1, status: "NORMAL" },
                            combined_status: "NORMAL",
                            reason: "ATR within normal range"
                        },
                        g4_market_volatility: {
                            status: "PASS",
                            current_vix: 15.2,
                            vix_sma: 16.0,
                            vix_ratio: 0.95,
                            vix_status: "STABLE",
                            reason: "VIX stable at 0.95x SMA"
                        },
                        g5_risk_reward: {
                            status: "PASS",
                            entry_price: 21500.0,
                            stop_price: 21480.0,
                            target_price: 21550.0,
                            risk_points: 20.0,
                            reward_points: 50.0,
                            rr_ratio: 2.5,
                            reason: "R:R 2.50 exceeds minimum 2.0"
                        },
                        g6_consecutive_losses: {
                            status: "PASS",
                            losses_1m: 0,
                            losses_5m: 1,
                            max_allowed: 3,
                            reason: "1M: 0 losses, 5M: 1 loss (max 3)"
                        },
                        g7_spy_trend: {
                            status: "PASS",
                            spy_price: 598.50,
                            spy_sma: 595.20,
                            is_above_sma: true,
                            is_near_sma: false,
                            recent_touch: true,
                            bounce_up: false,
                            trend_status: "BULLISH",
                            reason: "SPY bullish: above SMA"
                        }
                    },
                    direction: {
                        d1_nq_alignment: {
                            value: "ALIGNED",
                            bias_4h: "BULLISH",
                            bias_1h: "BULLISH",
                            bias_15m: "BULLISH",
                            high_tf_bias: "BULLISH",
                            confirms_entry: true,
                            reason: "4H BULLISH, 1H BULLISH, 15M BULLISH = ALIGNED"
                        },
                        d2_es_alignment: {
                            value: "CONVERGED",
                            es_bias_4h: "BULLISH",
                            es_bias_1h: "BULLISH",
                            es_bias_15m: "BULLISH",
                            nq_high_tf_bias: "BULLISH",
                            converges_with_nq: true,
                            reason: "ES BULLISH converges with NQ BULLISH"
                        },
                        d3_bearish_inversion: {
                            value: "STRONG",
                            failed_breakers: {
                                nq_1m_bear: true,
                                nq_5m_bear: false,
                                nq_15m_bear: true,
                                es_bear: false
                            },
                            total_failures: 2,
                            highest_tf_failed: "15m",
                            reason: "NQ 15m+NQ 1m bears failed = STRONG inversion"
                        }
                    },
                    support: {
                        s1_premium_discount: {
                            value: "DISCOUNT",
                            zone: "DISCOUNT",
                            current_price: 21500.0,
                            ranges: {
                                weekly: { high: 21800.0, low: 21200.0, position_pct: 50.0 },
                                daily: { high: 21600.0, low: 21400.0, position_pct: 50.0 },
                                session: { high: 21550.0, low: 21450.0, position_pct: 50.0 }
                            },
                            weighted_composite: 25.0,
                            reason: "At 25% = DISCOUNT"
                        },
                        s2_stacked_breakers: {
                            value: "STRONG",
                            strength: "STRONG",
                            total_layers: 3,
                            by_timeframe: { "4h": 1, "1h": 1, "15m": 1, "5m": 0 },
                            highest_tf: "1h",
                            breakers: [
                                { tf: "4h", high: 21480.0, low: 21450.0, age_bars: 120, energy: 0.8 },
                                { tf: "1h", high: 21470.0, low: 21445.0, age_bars: 45, energy: 0.9 },
                                { tf: "15m", high: 21465.0, low: 21440.0, age_bars: 12, energy: 1.0 }
                            ],
                            reason: "4H+1H+15M breakers below = STRONG support"
                        },
                        s3_stacked_fvgs: {
                            value: "MODERATE",
                            strength: "MODERATE",
                            total_layers: 2,
                            by_timeframe: { "4h": 0, "1h": 0, "15m": 1, "5m": 1 },
                            highest_tf: "15m",
                            fvgs: [
                                { tf: "15m", high: 21490.0, low: 21480.0, fill_pct: 20.0 },
                                { tf: "5m", high: 21485.0, low: 21478.0, fill_pct: 0.0 }
                            ],
                            reason: "15M+5M FVGs below = MODERATE support"
                        }
                    },
                    resistance: {
                        r1_blocking_breakers: {
                            value: "FRICTION",
                            strength: "LOW_TF",
                            total_in_path: 1,
                            by_timeframe: { "4h": 0, "1h": 0, "15m": 0, "5m": 1 },
                            highest_blocking_tf: "5m",
                            breakers: [
                                { tf: "5m", high: 21535.0, low: 21525.0, age_bars: 5, energy: 0.6 }
                            ],
                            reason: "5M bear in path = FRICTION"
                        },
                        r2_blocking_fvgs: {
                            value: "CLEAR",
                            strength: "NONE",
                            total_in_path: 0,
                            by_timeframe: { "4h": 0, "1h": 0, "15m": 0, "5m": 0 },
                            highest_blocking_tf: null,
                            fvgs: [],
                            reason: "No bearish FVGs in path = Clear"
                        }
                    },
                    energy: {
                        e1_formation_fvg: {
                            value: "HIGH",
                            strength: "HIGH",
                            has_fvg: true,
                            fvg_details: {
                                size_pct: 45.0,
                                high: 21510.0,
                                low: 21500.0
                            },
                            reason: "FVG 45% of breaker = HIGH energy"
                        },
                        e2_formation_sweep: {
                            value: "MODERATE",
                            strength: "MODERATE",
                            has_sweep: true,
                            sweep_depth_pct: 30.0,
                            sweep_low: 21475.0,
                            impulse_high: 21520.0,
                            impulse_low: 21480.0,
                            reason: "Sweep 30% of impulse = MODERATE"
                        },
                        e3_formation_smt: {
                            value: "MODERATE",
                            strength: "MODERATE",
                            has_divergence: false,
                            divergence_type: null,
                            nq_swing_price: null,
                            es_swing_price: null,
                            reason: "No divergence detected"
                        },
                        e4_bullish_attraction: {
                            value: "HIGH",
                            level: "HIGH",
                            zone_sd: 1.5,
                            sd_phase: "FRESH",
                            zone_high: 21470.0,
                            zone_low: 21450.0,
                            zone_timeframe: "1h",
                            reason: "Support zone at 1.5 SD (FRESH) = HIGH"
                        },
                        e5_bearish_attraction: {
                            value: "HIGH",
                            level: "HIGH",
                            zone_sd: 3.5,
                            sd_phase: "EXHAUSTED",
                            zone_high: 21600.0,
                            zone_low: 21580.0,
                            zone_timeframe: "4h",
                            reason: "Resistance zone at 3.5 SD (EXHAUSTED) = HIGH"
                        },
                        e6_daily_burn: {
                            value: "AVAILABLE",
                            level: "AVAILABLE",
                            burn_pct: 45.0,
                            nq: { daily_range: 180.0, adr_20: 400.0, burn_pct: 45.0 },
                            es: { daily_range: 20.0, adr_20: 50.0, burn_pct: 40.0 },
                            limiting_symbol: "NQ",
                            reason: "NQ at 45% burn = AVAILABLE"
                        }
                    }
                }
            };
        }
        
        function renderAnalysisContent(data) {
            const tabsContainer = document.getElementById('analysis-tabs');
            const contentContainer = document.getElementById('analysis-content');
            const decisionBadge = document.getElementById('analysis-decision-badge');
            const heroId = document.getElementById('analysis-hero-id');
            const heroMeta = document.getElementById('analysis-hero-meta');
            const scoreBig = document.getElementById('analysis-score-big');
            
            // New schema: data.dims contains g1-g7, d1-d3, s1-s3, r1-r2, e1-e6
            const dims = data.dims || {};
            
            // Update hero section
            const decision = data.decision || 'PENDING';
            decisionBadge.textContent = decision;
            decisionBadge.className = 'analysis-decision-badge ' + decision.toLowerCase();
            
            heroId.textContent = data.display_id || data.breaker_id || 'Unknown';
            
            // Extract time
            if (data.time) {
                const timePart = data.time.split('T')[1] || '';
                heroMeta.textContent = timePart.substring(0, 5) + ' ET';
            }
            
            // Score is -4 to +4, display appropriately
            const score = data.score !== undefined ? data.score : 0;
            scoreBig.textContent = (score >= 0 ? '+' : '') + score + '/4';
            
            // Build tabs and content - start with Overview tab
            let tabsHtml = `
                <div class="analysis-tab active" onclick="switchTab('overview')">
                    Overview
                </div>
            `;
            
            // Overview panel content
            let contentHtml = `
                <div class="analysis-panel active" id="panel-overview">
                    ${renderOverviewPanel(data)}
                </div>
            `;
            
            // Status value mappings for pass/warn/fail classification
            const statusClasses = {
                // Gate
                'PASS': 'pass', 'FAIL': 'fail',
                // Direction
                'WITH': 'pass', 'NEUTRAL': 'warn', 'AGAINST': 'fail',
                // Support
                'SUPPORTED': 'pass', 'PARTIAL': 'warn', 'NAKED': 'fail',
                // Resistance
                'CLEAR': 'pass', 'FRICTION': 'warn', 'BLOCKED': 'fail',
                // Energy
                'POWERED': 'pass', 'MODERATE': 'warn', 'EXHAUSTED': 'fail'
            };
            
            // Add dimension category tabs
            Object.entries(ANALYSIS_DIMENSIONS).forEach(([category, dimensions]) => {
                // Count pass/warn/fail for tab indicator
                let passCount = 0, warnCount = 0, failCount = 0;
                dimensions.forEach(dim => {
                    const dimData = dims[dim.key];
                    if (dimData && dimData.status) {
                        const cls = statusClasses[dimData.status.toUpperCase()] || 'warn';
                        if (cls === 'pass') passCount++;
                        else if (cls === 'warn') warnCount++;
                        else if (cls === 'fail') failCount++;
                    }
                });
                
                const countClass = failCount > 0 ? 'has-fail' : warnCount > 0 ? 'has-warn' : 'all-pass';
                const countText = `${passCount}/${dimensions.length}`;
                
                // Tab
                tabsHtml += `
                    <div class="analysis-tab" onclick="switchTab('${category}')">
                        ${CATEGORY_LABELS[category]}
                        <span class="analysis-tab-count ${countClass}">${countText}</span>
                    </div>
                `;
                
                // Content panel with dimension cards
                contentHtml += `
                    <div class="analysis-panel" id="panel-${category}">
                        <div class="analysis-cards">
                            ${dimensions.map(dim => {
                                const dimData = dims[dim.key];
                                if (!dimData) {
                                    return `
                                        <div class="analysis-card error-card">
                                            <div class="analysis-card-header">
                                                <div class="analysis-card-title">
                                                    <span class="analysis-card-code">${dim.code}</span>
                                                    <span class="analysis-card-name">Missing</span>
                                                </div>
                                                <span class="analysis-card-value error">—</span>
                                            </div>
                                        </div>
                                    `;
                                }
                                
                                const status = dimData.status || '—';
                                const statusClass = statusClasses[status.toUpperCase()] || 'warn';
                                const name = dimData.name || dim.code;
                                const narrative = dimData.narrative || [];
                                
                                return `
                                    <div class="analysis-card">
                                        <div class="analysis-card-header">
                                            <div class="analysis-card-title">
                                                <span class="analysis-card-code">${dim.code}</span>
                                                <span class="analysis-card-name">${name}</span>
                                            </div>
                                            <span class="analysis-card-value ${statusClass}">${status}</span>
                                        </div>
                                        <div class="analysis-card-narrative">
                                            ${narrative.map(line => `<div class="narrative-line">${line}</div>`).join('')}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });
            
            tabsContainer.innerHTML = tabsHtml;
            contentContainer.innerHTML = contentHtml;
        }
        
        function renderOverviewPanel(data) {
            const pattern = data.pattern || {};
            const zone = data.zone || {};
            const levels = data.levels || {};
            const formation = data.formation || {};
            const confluence = data.confluence || {};
            const summary = data.summary || [];
            
            return `
                <!-- Pattern Structure -->
                <div class="overview-section">
                    <div class="overview-section-title">Pattern Structure</div>
                    <div class="pattern-flow">
                        ${renderPatternPoint('H1', pattern.h1, 'start')}
                        <span class="pattern-connector">→</span>
                        ${renderPatternPoint('L1', pattern.l1, 'low')}
                        <span class="pattern-connector">→</span>
                        ${renderPatternPoint('BR', pattern.br, 'breaker')}
                        <span class="pattern-connector">→</span>
                        ${renderPatternPoint('L2', pattern.l2, 'sweep')}
                        <span class="pattern-connector">→</span>
                        ${renderPatternPoint('MSS', pattern.mss, 'confirm')}
                    </div>
                </div>
                
                <!-- Trade Setup - Decision Tree -->
                <div class="overview-section">
                    <div class="overview-section-title">Trade Setup</div>
                    <div class="trade-decision-tree">
                        ${renderTradeDecisionTree(zone, levels)}
                    </div>
                </div>
                
                <!-- Formation Quality -->
                <div class="overview-section">
                    <div class="overview-section-title">Formation Quality</div>
                    <div class="formation-metrics">
                        <div class="formation-metric">
                            <div class="formation-metric-label">FVG Size</div>
                            <div class="formation-metric-bar">
                                <div class="formation-bar-fill" style="width: ${formation.fvg?.size_pct || 0}%"></div>
                            </div>
                            <div class="formation-metric-value">${formation.fvg?.size_pct?.toFixed(0) || 0}%</div>
                        </div>
                        <div class="formation-metric">
                            <div class="formation-metric-label">Sweep Depth</div>
                            <div class="formation-metric-bar">
                                <div class="formation-bar-fill sweep" style="width: ${formation.sweep?.depth_pct || 0}%"></div>
                            </div>
                            <div class="formation-metric-value">${formation.sweep?.depth_pct?.toFixed(0) || 0}%</div>
                        </div>
                        <div class="formation-metric smt">
                            <div class="formation-metric-label">SMT Divergence</div>
                            <div class="formation-smt-status ${formation.smt_id ? 'active' : ''}">
                                ${formation.smt_id ? '✓ ' + formatSmtIdShort(formation.smt_id) : '— None'}
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Confluence -->
                <div class="overview-section">
                    <div class="overview-section-title">Confluence <span class="confluence-count">${Object.keys(confluence).length} active</span></div>
                    <div class="confluence-list">
                        ${Object.entries(confluence).length > 0 ? 
                            Object.entries(confluence).slice(0, 5).map(([id, c]) => {
                                const parts = id.split('-');
                                const symbol = parts[0] || '';
                                const tf = parts[1] || '';
                                const dir = parts[parts.length - 1] === 'L' ? 'bull' : 'bear';
                                return `
                                    <div class="confluence-item ${dir}">
                                        <span class="confluence-id">${symbol}-${tf}</span>
                                        <span class="confluence-fib">Fib ${c.fib?.toFixed(1) || '—'}</span>
                                        <span class="confluence-energy">${((c.energy || 0) * 100).toFixed(0)}%</span>
                                    </div>
                                `;
                            }).join('') : 
                            '<div class="confluence-empty">No other active breakers</div>'
                        }
                    </div>
                </div>
                
                <!-- Verdict Summary -->
                <div class="overview-section verdict">
                    <div class="overview-section-title">Verdict</div>
                    <div class="verdict-lines">
                        ${summary.map((line, i) => `
                            <div class="verdict-line ${i === 0 ? 'primary' : ''}">${line}</div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        function renderPatternPoint(label, point, type) {
            if (!point) {
                return `
                    <div class="pattern-point ${type}">
                        <span class="pattern-point-label">${label}</span>
                        <span class="pattern-point-price">—</span>
                        <span class="pattern-point-time">—</span>
                    </div>
                `;
            }
            return `
                <div class="pattern-point ${type}">
                    <span class="pattern-point-label">${label}</span>
                    <span class="pattern-point-price">${point.price?.toFixed(2) || '—'}</span>
                    <span class="pattern-point-time">${point.time || '—'}</span>
                </div>
            `;
        }
        
        function renderPriceLadderRow(label, price, type) {
            return `
                <div class="price-ladder-row ${type}">
                    <span class="ladder-label">${label}</span>
                    <span class="ladder-line"></span>
                    <span class="ladder-price">${price?.toFixed(2) || '—'}</span>
                </div>
            `;
        }
        
        function renderTradeDecisionTree(zone, levels) {
            if (!levels?.entry) {
                return '<div class="decision-tree-empty">No trade levels available</div>';
            }
            
            const entry = levels.entry;
            const stop = levels.stop;
            const target = levels.target || levels.f3;
            
            // Calculate risk (entry to stop)
            const risk = stop ? Math.abs(entry - stop) : 0;
            
            // Calculate RR for each fib level
            const calcRR = (price) => {
                if (!risk || !price) return null;
                const reward = Math.abs(price - entry);
                return (reward / risk).toFixed(1);
            };
            
            // Standard fib extension ratios
            const fibRatios = {
                f0: '0.0',
                f1: '-0.5',
                f2: '-1.0', 
                f3: '-1.618',
                f4: '-2.0'
            };
            
            return `
                <div class="decision-tree">
                    <!-- Entry Node -->
                    <div class="tree-entry-row">
                        <div class="tree-node entry-node">
                            <div class="node-label">ENTRY</div>
                            <div class="node-price">${entry.toFixed(2)}</div>
                            <div class="node-meta">
                                ${zone?.high && zone?.low ? `Zone: ${zone.high.toFixed(0)} — ${zone.low.toFixed(0)}` : ''}
                            </div>
                        </div>
                    </div>
                    
                    <!-- Connector SVG -->
                    <div class="tree-connector-svg">
                        <svg width="100%" height="40" viewBox="0 0 400 40" preserveAspectRatio="xMidYMid meet">
                            <path d="M 200 0 L 200 15 L 60 15 L 60 40" stroke="#444" stroke-width="2" fill="none"/>
                            <path d="M 200 0 L 200 15 L 340 15 L 340 40" stroke="#444" stroke-width="2" fill="none"/>
                        </svg>
                    </div>
                    
                    <!-- Stop and Targets Row -->
                    <div class="tree-branches">
                        <!-- Stop Loss -->
                        <div class="tree-node stop-node">
                            <div class="node-label">STOP</div>
                            <div class="node-price">${stop?.toFixed(2) || '—'}</div>
                            <div class="node-fib">Fib ${fibRatios.f0}</div>
                            <div class="node-rr stop">−1.0 R</div>
                        </div>
                        
                        <!-- Targets -->
                        <div class="targets-container">
                            ${levels.f1 ? `
                                <div class="tree-node target-node f1">
                                    <div class="node-label">F1</div>
                                    <div class="node-price">${levels.f1.toFixed(2)}</div>
                                    <div class="node-fib">Fib ${fibRatios.f1}</div>
                                    <div class="node-rr target">+${calcRR(levels.f1) || '?'} R</div>
                                </div>
                            ` : ''}
                            
                            ${levels.f2 ? `
                                <div class="target-arrow">→</div>
                                <div class="tree-node target-node f2">
                                    <div class="node-label">F2</div>
                                    <div class="node-price">${levels.f2.toFixed(2)}</div>
                                    <div class="node-fib">Fib ${fibRatios.f2}</div>
                                    <div class="node-rr target">+${calcRR(levels.f2) || '?'} R</div>
                                </div>
                            ` : ''}
                            
                            <div class="target-arrow">→</div>
                            <div class="tree-node target-node primary">
                                <div class="node-label">TARGET</div>
                                <div class="node-price">${target?.toFixed(2) || '—'}</div>
                                <div class="node-fib">Fib ${fibRatios.f3}</div>
                                <div class="node-rr target">+${calcRR(target) || '?'} R</div>
                            </div>
                            
                            ${levels.f4 ? `
                                <div class="target-arrow">→</div>
                                <div class="tree-node target-node f4">
                                    <div class="node-label">F4</div>
                                    <div class="node-price">${levels.f4.toFixed(2)}</div>
                                    <div class="node-fib">Fib ${fibRatios.f4}</div>
                                    <div class="node-rr target">+${calcRR(levels.f4) || '?'} R</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                    
                    <!-- Risk/Reward Summary -->
                    <div class="tree-summary">
                        <div class="summary-item risk">
                            <span class="summary-label">Risk</span>
                            <span class="summary-value">${risk.toFixed(2)} pts</span>
                        </div>
                        <div class="summary-item reward">
                            <span class="summary-label">Reward (F3)</span>
                            <span class="summary-value">${target ? Math.abs(target - entry).toFixed(2) : '—'} pts</span>
                        </div>
                        <div class="summary-item rr">
                            <span class="summary-label">R:R</span>
                            <span class="summary-value">${calcRR(target) ? '1:' + calcRR(target) : '—'}</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Helper function to render price ladder for support/resistance zones
        function renderPriceLadder(data, zoneType) {
            const zones = data.breakers || data.fvgs || [];
            const isSupport = zoneType.includes('support');
            const isBreaker = zoneType.includes('breaker');
            
            if (zones.length === 0) {
                const statusText = isSupport ? 
                    (isBreaker ? 'No support breakers below' : 'No support FVGs below') :
                    (isBreaker ? 'No blocking breakers' : 'No blocking FVGs');
                const statusClass = isSupport ? 'warn' : 'pass';
                
                return `
                    <div style="text-align: center; padding: 20px; color: ${isSupport ? '#fbbf24' : '#4ade80'};">
                        <div style="font-size: 24px; margin-bottom: 8px;">${isSupport ? '—' : '✓'}</div>
                        <div style="font-size: 12px;">${statusText}</div>
                    </div>
                    <div class="analysis-metric-row">
                        <div class="analysis-metric">
                            <div class="analysis-metric-label">Total</div>
                            <div class="analysis-metric-value">${isSupport ? data.total_layers || 0 : data.total_in_path || 0}</div>
                        </div>
                        <div class="analysis-metric">
                            <div class="analysis-metric-label">${isSupport ? 'Highest TF' : 'Blocking TF'}</div>
                            <div class="analysis-metric-value">${(isSupport ? data.highest_tf : data.highest_blocking_tf)?.toUpperCase() || 'None'}</div>
                        </div>
                        <div class="analysis-metric">
                            <div class="analysis-metric-label">Strength</div>
                            <div class="analysis-metric-value ${getStrengthClass(data.strength || data.value)}">${data.strength || data.value || '—'}</div>
                        </div>
                    </div>
                `;
            }
            
            // Build zone list
            let zonesHtml = zones.map((z, i) => {
                const tfClass = 'tf-' + (z.tf || '').toLowerCase();
                const extraInfo = isBreaker ? 
                    `${z.age_bars || 0} bars · ${((z.energy || 0) * 100).toFixed(0)}% energy` :
                    `${(z.fill_pct || 0).toFixed(0)}% filled`;
                    
                return `
                    <div class="price-ladder-zone ${zoneType} ${tfClass}" style="position: relative; margin-bottom: 6px;">
                        <span class="zone-tf">${(z.tf || '').toUpperCase()}</span>
                        <span>${z.high?.toLocaleString()} - ${z.low?.toLocaleString()}</span>
                        <span class="zone-info">${extraInfo}</span>
                    </div>
                `;
            }).join('');
            
            return `
                <div style="max-height: 150px; overflow-y: auto; margin-bottom: 12px;">
                    ${zonesHtml}
                </div>
                <div class="analysis-metric-row">
                    <div class="analysis-metric">
                        <div class="analysis-metric-label">Total</div>
                        <div class="analysis-metric-value">${isSupport ? data.total_layers || 0 : data.total_in_path || 0}</div>
                    </div>
                    <div class="analysis-metric">
                        <div class="analysis-metric-label">${isSupport ? 'Highest TF' : 'Blocking TF'}</div>
                        <div class="analysis-metric-value ${(isSupport ? data.highest_tf : data.highest_blocking_tf) ? (isSupport ? 'pass' : 'fail') : ''}">${(isSupport ? data.highest_tf : data.highest_blocking_tf)?.toUpperCase() || 'None'}</div>
                    </div>
                    <div class="analysis-metric">
                        <div class="analysis-metric-label">Strength</div>
                        <div class="analysis-metric-value ${getStrengthClass(data.strength || data.value)}">${data.strength || data.value || '—'}</div>
                    </div>
                </div>
            `;
        }
        
        function renderDimensionVisual(key, data) {
            switch(key) {
                // Direction - Flow chart with arrows
                case 'd1_nq_alignment':
                    const nqAligned = data.bias_4h === 'BULLISH' && data.bias_1h === 'BULLISH' && data.bias_15m === 'BULLISH';
                    const nqArrow = nqAligned ? 'aligned' : 'mixed';
                    return `
                        <div class="direction-flow">
                            <div class="direction-flow-row">
                                <div class="direction-flow-symbol">NQ</div>
                                <div class="direction-flow-tfs">
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">4H</div>
                                        <div class="direction-flow-tf-box ${(data.bias_4h || '').toLowerCase()}">${data.bias_4h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${nqArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">1H</div>
                                        <div class="direction-flow-tf-box ${(data.bias_1h || '').toLowerCase()}">${data.bias_1h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${nqArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">15M</div>
                                        <div class="direction-flow-tf-box ${(data.bias_15m || '').toLowerCase()}">${data.bias_15m === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                </div>
                                <div class="direction-flow-result ${data.value?.toLowerCase() || ''}">${data.value || 'ALIGNED'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'd2_es_alignment':
                    const esAligned = data.es_bias_4h === 'BULLISH' && data.es_bias_1h === 'BULLISH' && data.es_bias_15m === 'BULLISH';
                    const esArrow = esAligned ? 'aligned' : 'mixed';
                    return `
                        <div class="direction-flow">
                            <div class="direction-flow-row">
                                <div class="direction-flow-symbol">ES</div>
                                <div class="direction-flow-tfs">
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">4H</div>
                                        <div class="direction-flow-tf-box ${(data.es_bias_4h || '').toLowerCase()}">${data.es_bias_4h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${esArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">1H</div>
                                        <div class="direction-flow-tf-box ${(data.es_bias_1h || '').toLowerCase()}">${data.es_bias_1h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${esArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">15M</div>
                                        <div class="direction-flow-tf-box ${(data.es_bias_15m || '').toLowerCase()}">${data.es_bias_15m === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                </div>
                                <div class="direction-flow-result ${data.converges_with_nq ? 'aligned' : 'diverged'}">${data.value || 'CONVERGED'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'd3_bearish_inversion':
                    const fb = data.failed_breakers || {};
                    return `
                        <div class="inversion-grid">
                            <div class="inversion-cell ${fb.nq_1m_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">NQ 1M Bear</div>
                                <div class="inversion-cell-icon">${fb.nq_1m_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.nq_1m_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                            <div class="inversion-cell ${fb.nq_5m_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">NQ 5M Bear</div>
                                <div class="inversion-cell-icon">${fb.nq_5m_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.nq_5m_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                            <div class="inversion-cell ${fb.nq_15m_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">NQ 15M Bear</div>
                                <div class="inversion-cell-icon">${fb.nq_15m_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.nq_15m_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                            <div class="inversion-cell ${fb.es_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">ES Bear</div>
                                <div class="inversion-cell-icon">${fb.es_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.es_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                        </div>
                        <div class="analysis-metric-row" style="margin-top: 10px;">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Bears Failed</div>
                                <div class="analysis-metric-value ${data.total_failures > 0 ? 'pass' : ''}">${data.total_failures || 0}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Highest TF</div>
                                <div class="analysis-metric-value">${data.highest_tf_failed?.toUpperCase() || 'None'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.value)}">${data.value || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                // Support - Premium/Discount gauge
                case 's1_premium_discount':
                    const composite = data.weighted_composite || 50;
                    const ranges = data.ranges || {};
                    const pdZone = composite < 35 ? 'DISCOUNT' : composite > 65 ? 'PREMIUM' : 'EQUILIBRIUM';
                    
                    return `
                        <div class="pd-gauge">
                            <div class="pd-gauge-bar">
                                <div class="pd-gauge-marker" style="left: ${composite}%;"></div>
                            </div>
                            <div class="pd-gauge-labels">
                                <span>Discount (0%)</span>
                                <span>Equilibrium</span>
                                <span>Premium (100%)</span>
                            </div>
                        </div>
                        <div class="analysis-metric-row" style="margin-top: 16px;">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Weekly</div>
                                <div class="analysis-metric-value">${ranges.weekly?.position_pct?.toFixed(0) || '—'}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Daily</div>
                                <div class="analysis-metric-value">${ranges.daily?.position_pct?.toFixed(0) || '—'}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Session</div>
                                <div class="analysis-metric-value">${ranges.session?.position_pct?.toFixed(0) || '—'}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Composite</div>
                                <div class="analysis-metric-value ${composite < 40 ? 'pass' : composite > 65 ? 'fail' : 'warn'}">${composite.toFixed(0)}%</div>
                            </div>
                        </div>
                    `;
                    
                // Support - Price ladder with actual zones
                case 's2_stacked_breakers':
                    return renderPriceLadder(data, 'support-breaker');
                    
                case 's3_stacked_fvgs':
                    return renderPriceLadder(data, 'support-fvg');
                    
                case 'r1_blocking_breakers':
                    return renderPriceLadder(data, 'resist-breaker');
                    
                case 'r2_blocking_fvgs':
                    return renderPriceLadder(data, 'resist-fvg');
                    
                // Energy dimensions
                case 'e1_formation_fvg':
                    const fvgPct = data.fvg_details?.size_pct || 0;
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Has FVG</div>
                                <div class="analysis-metric-value ${data.has_fvg ? 'pass' : 'fail'}">${data.has_fvg ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">FVG Size</div>
                                <div class="analysis-metric-value">${fvgPct.toFixed(0)}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.strength)}">${data.strength || '—'}</div>
                            </div>
                        </div>
                        <div class="analysis-progress">
                            <div class="analysis-progress-fill ${fvgPct > 30 ? 'good' : fvgPct > 15 ? 'warn' : 'bad'}" style="width: ${Math.min(fvgPct, 100)}%;"></div>
                        </div>
                    `;
                    
                case 'e2_formation_sweep':
                    const sweepPct = data.sweep_depth_pct || 0;
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Has Sweep</div>
                                <div class="analysis-metric-value ${data.has_sweep ? 'pass' : ''}">${data.has_sweep ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Sweep Depth</div>
                                <div class="analysis-metric-value">${sweepPct.toFixed(0)}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.strength)}">${data.strength || '—'}</div>
                            </div>
                        </div>
                        <div class="analysis-progress">
                            <div class="analysis-progress-fill ${sweepPct > 40 ? 'good' : sweepPct > 20 ? 'warn' : 'bad'}" style="width: ${Math.min(sweepPct, 100)}%;"></div>
                        </div>
                    `;
                    
                case 'e3_formation_smt':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Divergence</div>
                                <div class="analysis-metric-value ${data.has_divergence ? 'pass' : ''}">${data.has_divergence ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Type</div>
                                <div class="analysis-metric-value">${data.divergence_type || 'None'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.strength)}">${data.strength || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'e4_bullish_attraction':
                    const bullPhase = (data.sd_phase || 'FRESH').toLowerCase();
                    const bullLevel = Math.min(100, (4 - (data.zone_sd || 0)) / 4 * 100);
                    return `
                        <div class="attraction-visual">
                            <div class="attraction-visual-header">
                                <div class="attraction-visual-tf bullish">${data.zone_timeframe?.toUpperCase() || '—'} Support Zone</div>
                                <div class="attraction-visual-phase ${bullPhase}">${data.sd_phase || '—'}</div>
                            </div>
                            <div class="attraction-visual-sd">
                                <div class="attraction-visual-sd-value" style="color: #4ade80;">${data.zone_sd?.toFixed(1) || '—'}</div>
                                <div class="attraction-visual-sd-label">SD from Mean</div>
                            </div>
                            <div class="attraction-visual-bar">
                                <div class="attraction-visual-bar-fill bullish" style="width: ${bullLevel}%;"></div>
                            </div>
                            <div class="analysis-metric-row" style="margin-top: 10px;">
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone High</div>
                                    <div class="analysis-metric-value">${data.zone_high?.toLocaleString() || '—'}</div>
                                </div>
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone Low</div>
                                    <div class="analysis-metric-value">${data.zone_low?.toLocaleString() || '—'}</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                case 'e5_bearish_attraction':
                    const bearPhase = (data.sd_phase || 'EXHAUSTED').toLowerCase();
                    const bearLevel = Math.min(100, (data.zone_sd || 0) / 4 * 100);
                    return `
                        <div class="attraction-visual">
                            <div class="attraction-visual-header">
                                <div class="attraction-visual-tf bearish">${data.zone_timeframe?.toUpperCase() || '—'} Resistance Zone</div>
                                <div class="attraction-visual-phase ${bearPhase}">${data.sd_phase || '—'}</div>
                            </div>
                            <div class="attraction-visual-sd">
                                <div class="attraction-visual-sd-value" style="color: #f87171;">${data.zone_sd?.toFixed(1) || '—'}</div>
                                <div class="attraction-visual-sd-label">SD from Mean</div>
                            </div>
                            <div class="attraction-visual-bar">
                                <div class="attraction-visual-bar-fill bearish" style="width: ${bearLevel}%;"></div>
                            </div>
                            <div class="analysis-metric-row" style="margin-top: 10px;">
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone High</div>
                                    <div class="analysis-metric-value">${data.zone_high?.toLocaleString() || '—'}</div>
                                </div>
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone Low</div>
                                    <div class="analysis-metric-value">${data.zone_low?.toLocaleString() || '—'}</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                case 'e6_daily_burn':
                    const nqBurn = data.nq?.burn_pct || 0;
                    const esBurn = data.es?.burn_pct || 0;
                    const nqClass = nqBurn < 70 ? 'available' : nqBurn < 100 ? 'limited' : 'exhausted';
                    const esClass = esBurn < 70 ? 'available' : esBurn < 100 ? 'limited' : 'exhausted';
                    const circumf = 188; // 2 * PI * 30
                    const nqOff = circumf - (circumf * Math.min(nqBurn, 100) / 100);
                    const esOff = circumf - (circumf * Math.min(esBurn, 100) / 100);
                    
                    return `
                        <div class="burn-gauges">
                            <div class="burn-gauge">
                                <div class="burn-gauge-label">NQ</div>
                                <div class="burn-gauge-ring">
                                    <svg width="80" height="80" viewBox="0 0 80 80">
                                        <circle class="burn-gauge-bg" cx="40" cy="40" r="30"/>
                                        <circle class="burn-gauge-fill ${nqClass}" cx="40" cy="40" r="30" 
                                                stroke-dasharray="${circumf}" stroke-dashoffset="${nqOff}"/>
                                    </svg>
                                    <div class="burn-gauge-value ${nqClass}">${nqBurn.toFixed(0)}%</div>
                                </div>
                                <div class="burn-gauge-status ${nqClass}">${nqBurn < 70 ? 'Available' : nqBurn < 100 ? 'Limited' : 'Exhausted'}</div>
                            </div>
                            <div class="burn-gauge">
                                <div class="burn-gauge-label">ES</div>
                                <div class="burn-gauge-ring">
                                    <svg width="80" height="80" viewBox="0 0 80 80">
                                        <circle class="burn-gauge-bg" cx="40" cy="40" r="30"/>
                                        <circle class="burn-gauge-fill ${esClass}" cx="40" cy="40" r="30" 
                                                stroke-dasharray="${circumf}" stroke-dashoffset="${esOff}"/>
                                    </svg>
                                    <div class="burn-gauge-value ${esClass}">${esBurn.toFixed(0)}%</div>
                                </div>
                                <div class="burn-gauge-status ${esClass}">${esBurn < 70 ? 'Available' : esBurn < 100 ? 'Limited' : 'Exhausted'}</div>
                            </div>
                        </div>
                        <div class="analysis-metric-row" style="margin-top: 12px;">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">NQ Range</div>
                                <div class="analysis-metric-value">${data.nq?.daily_range?.toFixed(0) || '—'} pts</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">NQ ADR</div>
                                <div class="analysis-metric-value">${data.nq?.adr_20?.toFixed(0) || '—'} pts</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Limiting</div>
                                <div class="analysis-metric-value">${data.limiting_symbol || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                // Gate dimensions
                case 'g1_trading_hours':
                    return `
                        <div class="session-visual">
                            <div class="session-visual-time">${data.current_time || '—'}</div>
                            <div class="session-visual-badge ${data.is_tradeable ? 'active' : 'inactive'}">${data.session?.replace('_', ' ') || 'OFF HOURS'}</div>
                            ${data.in_no_trade_window ? `<div class="session-visual-badge inactive">${data.no_trade_window_name || 'No Trade'}</div>` : ''}
                        </div>
                    `;
                    
                case 'g2_news_blackout':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Clear</div>
                                <div class="analysis-metric-value ${data.is_clear ? 'pass' : 'fail'}">${data.is_clear ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Next Event</div>
                                <div class="analysis-metric-value">${data.next_event || 'None'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Minutes Until</div>
                                <div class="analysis-metric-value">${data.minutes_until || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'g3_price_volatility':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">NQ ATR Ratio</div>
                                <div class="analysis-metric-value ${getVolatilityClass(data.nq?.status)}">${data.nq?.atr_ratio?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">ES ATR Ratio</div>
                                <div class="analysis-metric-value ${getVolatilityClass(data.es?.status)}">${data.es?.atr_ratio?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Combined</div>
                                <div class="analysis-metric-value ${getVolatilityClass(data.combined_status)}">${data.combined_status || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'g4_market_volatility':
                    const vixStatus = data.vix_status || 'STABLE';
                    const vixClass = vixStatus === 'STABLE' ? 'stable' : vixStatus === 'ELEVATED' ? 'elevated' : 'high';
                    // Map VIX ratio to position (0.7 = 0%, 1.3 = 100%)
                    const vixPos = Math.min(100, Math.max(0, ((data.vix_ratio || 1) - 0.7) / 0.6 * 100));
                    
                    return `
                        <div class="vix-gauge">
                            <div class="vix-gauge-header">
                                <div class="vix-gauge-value ${vixClass}">${data.current_vix?.toFixed(1) || '—'}</div>
                                <div class="vix-gauge-ratio ${vixClass}">${data.vix_ratio?.toFixed(2) || '—'}x SMA</div>
                            </div>
                            <div class="vix-gauge-bar">
                                <div class="vix-gauge-marker" style="left: ${vixPos}%;"></div>
                            </div>
                            <div class="analysis-metric-row" style="margin-top: 12px;">
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">VIX SMA</div>
                                    <div class="analysis-metric-value">${data.vix_sma?.toFixed(1) || '—'}</div>
                                </div>
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Status</div>
                                    <div class="analysis-metric-value ${vixClass}">${vixStatus}</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                case 'g5_risk_reward':
                    const entry = data.entry_price || 0;
                    const stop = data.stop_price || 0;
                    const target = data.target_price || 0;
                    const risk = data.risk_points || 1;
                    const reward = data.reward_points || 1;
                    const total = risk + reward;
                    const riskPct = (risk / total) * 100;
                    const rewardPct = (reward / total) * 100;
                    
                    return `
                        <div class="rr-visual">
                            <div class="rr-visual-prices">
                                <div class="rr-visual-price stop">
                                    <div class="rr-visual-price-label">Stop</div>
                                    <div class="rr-visual-price-value">${stop.toLocaleString()}</div>
                                </div>
                                <div class="rr-visual-price entry">
                                    <div class="rr-visual-price-label">Entry</div>
                                    <div class="rr-visual-price-value">${entry.toLocaleString()}</div>
                                </div>
                                <div class="rr-visual-price target">
                                    <div class="rr-visual-price-label">Target</div>
                                    <div class="rr-visual-price-value">${target.toLocaleString()}</div>
                                </div>
                            </div>
                            <div class="rr-visual-bar">
                                <div class="rr-visual-bar-risk" style="width: ${riskPct}%;">${risk.toFixed(0)} pts</div>
                                <div class="rr-visual-bar-entry" style="left: ${riskPct}%;"></div>
                                <div class="rr-visual-bar-reward" style="width: ${rewardPct}%;">${reward.toFixed(0)} pts</div>
                            </div>
                            <div class="rr-visual-ratio ${data.rr_ratio >= 2 ? 'pass' : 'fail'}">${data.rr_ratio?.toFixed(2) || '—'}:1 R:R</div>
                        </div>
                    `;
                    
                case 'g6_consecutive_losses':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">1M Losses</div>
                                <div class="analysis-metric-value ${data.losses_1m < 3 ? 'pass' : 'fail'}">${data.losses_1m || 0}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">5M Losses</div>
                                <div class="analysis-metric-value ${data.losses_5m < 3 ? 'pass' : 'fail'}">${data.losses_5m || 0}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Max Allowed</div>
                                <div class="analysis-metric-value">${data.max_allowed || 3}</div>
                            </div>
                        </div>
                    `;
                    
                case 'g7_spy_trend':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">SPY Price</div>
                                <div class="analysis-metric-value">${data.spy_price?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">SPY SMA</div>
                                <div class="analysis-metric-value">${data.spy_sma?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Above SMA</div>
                                <div class="analysis-metric-value ${data.is_above_sma ? 'pass' : 'fail'}">${data.is_above_sma ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Trend</div>
                                <div class="analysis-metric-value ${data.trend_status === 'BULLISH' ? 'pass' : 'fail'}">${data.trend_status || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                default:
                    return `<div class="analysis-calc-text">Visual not available for this dimension</div>`;
            }
        }
        
        function getValueClass(value) {
            const v = (value || '').toString().toUpperCase();
            // Positive values
            if (['PASS', 'ALIGNED', 'CONVERGED', 'STRONG', 'HIGH', 'DISCOUNT', 'CLEAR', 'AVAILABLE'].includes(v)) {
                return 'pass';
            }
            // Neutral/moderate values
            if (['PARTIAL', 'MODERATE', 'FRICTION', 'EQUILIBRIUM', 'LIMITED'].includes(v)) {
                return 'warn';
            }
            // Negative values
            if (['FAIL', 'OPPOSED', 'DIVERGED', 'WEAK', 'NONE', 'LOW', 'PREMIUM', 'BLOCKED', 'EXHAUSTED'].includes(v)) {
                return 'fail';
            }
            return '';
        }
        
        function switchTab(category) {
            // Update tabs
            document.querySelectorAll('.analysis-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Find and activate the correct tab
            document.querySelectorAll('.analysis-tab').forEach(tab => {
                const label = category === 'overview' ? 'Overview' : (CATEGORY_LABELS[category] || category);
                if (tab.textContent.trim().startsWith(label)) {
                    tab.classList.add('active');
                }
            });
            
            // Update panels
            document.querySelectorAll('.analysis-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            const targetPanel = document.getElementById('panel-' + category);
            if (targetPanel) {
                targetPanel.classList.add('active');
            }
        }
        
        function getBiasClass(bias) {
            if (bias === 'BULLISH') return 'pass';
            if (bias === 'BEARISH') return 'fail';
            return 'warn';
        }
        
        function getStrengthClass(strength) {
            const s = (strength || '').toUpperCase();
            if (['STRONG', 'HIGH'].includes(s)) return 'pass';
            if (['MODERATE'].includes(s)) return 'warn';
            if (['WEAK', 'LOW', 'NONE'].includes(s)) return 'fail';
            return '';
        }
        
        function getVolatilityClass(status) {
            if (status === 'NORMAL') return 'pass';
            if (status === 'HOT' || status === 'DEAD') return 'fail';
            return 'warn';
        }
        
        function getSDPhaseClass(phase) {
            if (phase === 'FRESH') return 'pass';
            if (phase === 'TESTED') return 'warn';
            if (phase === 'EXHAUSTED') return 'fail';
            return '';
        }
        
        // ===== TRADES DATA =====
        function loadTradesData() {
            return fetch(TRADES_FIREBASE_URL)
                .then(r => r.json())
                .then(data => {
                    if (!data) {
                        tradesData = {};
                        return;
                    }
                    
                    // Index trades by breaker_id for fast lookup
                    // Note: breaker_id is the Firebase document key, not a field in the document
                    tradesData = {};
                    Object.entries(data).forEach(([key, trade]) => {
                        if (trade) {
                            trade.breaker_id = key;  // Add breaker_id from document key
                            tradesData[key] = trade;
                        }
                    });
                    
                    console.log(`Loaded ${Object.keys(tradesData).length} trades`);
                })
                .catch(err => {
                    console.warn('Failed to load trades:', err);
                    tradesData = {};
                });
        }
        
        function getTradeForBreaker(breakerId) {
            return tradesData[breakerId] || null;
        }
        
        function getTradeStatusClass(trade) {
            if (!trade) return null;
            
            // NEW SCHEMA ONLY
            const decision = trade.status?.decision || '';
            const phase = trade.status?.phase || '';
            const closeReason = trade.outcomes?.close_reason || '';
            const pnlPoints = trade.outcomes?.close_details?.pnl_points;
            
            if (decision === 'FILTERED') return 'entry-denied';
            
            if (phase === 'PENDING') return 'pending';
            if (phase === 'FILLED') return 'filled';
            
            if (phase === 'CLOSED') {
                // Derive WIN/LOSS from pnl_points (more reliable for exit rules)
                if (pnlPoints !== undefined) {
                    return pnlPoints >= 0 ? 'success' : 'failure';
                }
                // Fallback to close_reason for bracket orders
                if (closeReason === 'TARGET' || closeReason === 'T2') return 'success';
                if (closeReason === 'STOP') return 'failure';
                // Calculate from events if no pnl_points
                const pnl = calculateTradePnL(trade);
                if (pnl !== null) {
                    return pnl >= 0 ? 'success' : 'failure';
                }
                return 'cancelled';
            }
            return 'cancelled';
        }
        
        function getTradeStatusIcon(statusClass) {
            const icons = {
                'pending': '⚡',
                'filled': '●',
                'success': '✓',
                'failure': '✗',
                'cancelled': '○',
                'entry-denied': '⊘',
                'daily-win': '◐',
                'daily-loss': '◐'
            };
            return icons[statusClass] || '?';
        }
        
        function getTradeStatusLabel(trade, statusClass) {
            // NEW SCHEMA ONLY
            const phase = trade.status?.phase || '';
            
            if (phase === 'PENDING') return 'Pending';
            if (phase === 'FILLED') return 'Filled';
            if (statusClass === 'entry-denied') return 'Entry Denied';
            if (statusClass === 'daily-win') return 'EOD Win';
            if (statusClass === 'daily-loss') return 'EOD Loss';
            if (statusClass === 'success') return 'Success';
            if (statusClass === 'failure') return 'Failure';
            if (statusClass === 'cancelled') return 'Cancelled';
            return getDisplayCloseReason(trade) || 'Closed';
        }
        
        function calculateTradePnL(trade) {
            // NEW SCHEMA: outcomes.close_details.pnl_points
            if (trade.outcomes?.close_details?.pnl_points !== undefined) {
                return trade.outcomes.close_details.pnl_points;
            }
            
            // Fallback to events
            if (!trade.events || trade.events.length === 0) return null;
            
            const fillEvent = trade.events.find(e => e.event === 'FILLED');
            const closeEvent = trade.events.find(e => e.event === 'EXITED' || e.event === 'CLOSED');
            
            if (fillEvent && closeEvent && closeEvent.price && fillEvent.price) {
                return closeEvent.price - fillEvent.price;
            }
            return null;
        }
        
        // ===== TRADE MODAL (v6.9.0) =====
        let currentTradeModalTrade = null;
        let currentTradeModalBreaker = null;
        
        // Gate rule definitions for display
        const GATE_DEFINITIONS = {
            'G01_TRADING_HOURS': { name: 'Trading Hours', desc: 'Blocked time windows' },
            'G02_NEWS_BLACKOUT': { name: 'News Blackout', desc: 'News event periods' },
            'G03_PRICE_VOLATILITY': { name: 'Price Volatility', desc: 'ATR check' },
            'G04_MARKET_VOLATILITY': { name: 'Market Volatility', desc: 'VIX check' },
            'G05_RISK_REWARD': { name: 'Risk:Reward', desc: 'R:R ratio' },
            'G06_SPY_TREND': { name: 'SPY Trend', desc: 'Trend check' }
        };
        
        const CANCEL_DEFINITIONS = {
            'C01_T1_CROSSED': { name: 'T1 Crossed', desc: 'Price crossed T1 before entry' },
            'C02_STOP_CROSSED': { name: 'Stop Crossed', desc: 'Price crossed stop level' },
            'C03_FIB_EXCEEDED': { name: 'Fib Exceeded', desc: 'Fib level too high' },
            'C04_TIMEOUT': { name: 'Timeout', desc: 'Order timed out' },
            'C05_MANUAL': { name: 'Manual Cancel', desc: 'Manually cancelled' },
            'C06_BOS': { name: 'Break of Structure', desc: 'Market structure broken' }
        };
        
        const EXIT_DEFINITIONS = {
            'X01_SMT_FLIP': { name: 'SMT Flip', desc: 'SMT divergence flipped' },
            'X02_TARGET_HIT': { name: 'Target Hit', desc: 'Price hit target' },
            'X03_STOP_HIT': { name: 'Stop Hit', desc: 'Price hit stop loss' },
            'X04_TRAILING_STOP': { name: 'Trailing Stop', desc: 'Trailing stop triggered' },
            'X05_TIME_EXIT': { name: 'Time Exit', desc: 'Time-based exit' },
            'X06_BOS': { name: 'Break of Structure', desc: 'Market structure broken' },
            'X07_REVERSAL': { name: 'Reversal Signal', desc: 'Reversal detected' }
        };
        
        const SCORE_DEFINITIONS = {
            'S01_ZONE_ENTRY_DEPTH': { name: 'Zone Entry Depth', desc: 'Depth into breaker zone' },
            'S02_1M_ALIGNMENT': { name: '1M Alignment', desc: 'NQ/ES 1-minute alignment' },
            'S02_1M_EXHAUSTION': { name: '1M Exhaustion', desc: 'Exhaustion signal on 1M' },
            'S03_1M_SMT': { name: '1M SMT', desc: 'SMT divergence on 1M' },
            'S03_HTF_SMT': { name: 'HTF SMT', desc: 'Higher timeframe SMT' },
            'S04_FORMATIVE_FVG': { name: 'Formative FVG', desc: 'Fair value gap at formation' }
        };
        
        // Helper to get rule name from definitions
        function getRuleName(ruleKey, definitions) {
            if (definitions && definitions[ruleKey]) {
                return definitions[ruleKey].name;
            }
            // Fallback: convert G01_TRADING_HOURS to "Trading Hours"
            const parts = ruleKey.split('_');
            if (parts.length > 1) {
                return parts.slice(1).map(w => w.charAt(0) + w.slice(1).toLowerCase()).join(' ');
            }
            return ruleKey;
        }
        
        function showTradeModal(trade, breaker = null) {
            currentTradeModalTrade = trade;
            currentTradeModalBreaker = breaker;
            
            const backdrop = document.getElementById('trade-modal-backdrop');
            const statusClass = getTradeStatusClass(trade);
            const pnl = calculateTradePnL(trade);
            
            // Parse breaker ID for symbol, tf, direction
            const breakerId = trade.breaker_id || '';
            const parts = breakerId.split('-');
            const symbol = parts[0] || 'NQ';
            const tf = parts[1] || '1m';
            const direction = breakerId.toLowerCase().includes('bull') || breakerId.endsWith('-L') ? 'BULL' : 'BEAR';
            
            // Update tab 1 with symbol info
            document.getElementById('tm-tab-symbol').textContent = symbol;
            document.getElementById('tm-tab-tf').textContent = tf.toUpperCase();
            const tabDir = document.getElementById('tm-tab-dir');
            tabDir.textContent = direction;
            tabDir.className = `tm-tab-dir ${direction.toLowerCase()}`;
            
            // Update tab 2 with breaker name
            document.getElementById('tm-tab-breaker').textContent = breakerId || 'Breaker Details';
            
            // Update tab 1 status and P&L
            const tabStatus = document.getElementById('tm-tab-status');
            const tabPnl = document.getElementById('tm-tab-pnl');
            const displayCloseReason = getDisplayCloseReason(trade);
            
            if (statusClass === 'success') {
                tabStatus.className = 'tm-tab-status win';
                // Show close reason (TARGET, T2, X01_SMT_FLIP, etc.)
                tabStatus.textContent = displayCloseReason || 'WIN';
            } else if (statusClass === 'failure') {
                tabStatus.className = 'tm-tab-status loss';
                // Show close reason (STOP, BOS, X01_SMT_FLIP, etc.)
                tabStatus.textContent = displayCloseReason || 'LOSS';
            } else if (statusClass === 'entry-denied') {
                tabStatus.className = 'tm-tab-status filtered';
                tabStatus.textContent = 'FILTERED';
            } else if (statusClass === 'filled') {
                tabStatus.className = 'tm-tab-status pending';
                tabStatus.textContent = 'FILLED';
            } else if (statusClass === 'pending') {
                tabStatus.className = 'tm-tab-status pending';
                tabStatus.textContent = 'PENDING';
            } else {
                tabStatus.className = 'tm-tab-status cancelled';
                tabStatus.textContent = displayCloseReason || 'CANCELLED';
            }
            
            // Update tab P&L
            const tradePhase = trade.status?.phase || '';
            if (pnl !== null && tradePhase === 'CLOSED' && statusClass !== 'entry-denied') {
                tabPnl.className = `tm-tab-pnl ${pnl >= 0 ? 'win' : 'loss'}`;
                tabPnl.textContent = `${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}`;
            } else {
                tabPnl.className = 'tm-tab-pnl neutral';
                tabPnl.textContent = '';
            }
            
            // Render trade tab content (initially without breaker data)
            renderTradeTabContent(trade, statusClass, pnl, null);
            
            // Render breaker tab content - show loading first, then fetch
            renderBreakerTabContent(null, trade, true); // loading state
            
            // Fetch breaker details if we have an ID
            if (breakerId) {
                fetchBreakerDetails(breakerId).then(breakerData => {
                    currentTradeModalBreaker = breakerData;
                    // Re-render trade tab with breaker data (for entry thresholds)
                    renderTradeTabContent(trade, statusClass, pnl, breakerData);
                    renderBreakerTabContent(breakerData, trade, false);
                }).catch(err => {
                    console.warn('Failed to fetch breaker details:', err);
                    renderBreakerTabContent(null, trade, false);
                });
            }
            
            // Reset to first tab
            switchTradeModalTab(0);
            
            backdrop.classList.add('active');
            document.addEventListener('keydown', handleTradeModalEsc);
        }
        
        // Fetch breaker details from Firebase
        async function fetchBreakerDetails(breakerId) {
            // Check cache first
            if (breakerDetailsCache[breakerId]) {
                return breakerDetailsCache[breakerId];
            }
            
            // Fetch from API
            const url = `${BREAKERS_FIREBASE_URL}/${encodeURIComponent(breakerId)}.json`;
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const data = await response.json();
            
            if (data) {
                breakerDetailsCache[breakerId] = data;
            }
            return data;
        }
        
        function formatTimeShort(isoTime) {
            if (!isoTime) return '—';
            const d = new Date(isoTime);
            return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
        }
        
        // Format SMT ID for short display
        // Old format: SMT-NQ-15m-260202T1600-25832-L
        // New format: SMT-15m-260202-1615e6998-1600n25832-L
        function formatSmtIdShort(smtId) {
            if (!smtId) return '—';
            const parts = smtId.split('-');
            
            // Extract direction from last part
            const lastPart = parts[parts.length - 1];
            const dir = lastPart === 'L' ? '↑' : lastPart === 'S' ? '↓' : '';
            
            // Find timeframe (1m, 5m, 15m, 1h, etc.)
            let tf = '';
            for (const part of parts) {
                if (/^\d+[mh]$/i.test(part)) {
                    tf = part.toUpperCase();
                    break;
                }
            }
            
            return tf ? `${tf} ${dir}` : smtId.substring(0, 12);
        }
        
        // Get the triggered rule name from rules object
        function getTriggeredRule(rules, ruleType) {
            // ruleType: 'exit' or 'cancel'
            const ruleSet = rules?.[ruleType] || {};
            for (const [ruleName, ruleData] of Object.entries(ruleSet)) {
                if (ruleData?.[ruleType] === true) {
                    return ruleName;  // e.g., "X01_SMT_FLIP" or "C01_T1_CROSSED"
                }
            }
            return null;
        }
        
        // Get display-friendly close reason
        function getDisplayCloseReason(trade) {
            const closeReason = trade.outcomes?.close_reason || '';
            
            // If EXIT, lookup which exit rule triggered
            if (closeReason === 'EXIT') {
                const triggeredRule = getTriggeredRule(trade.rules, 'exit');
                return triggeredRule || 'EXIT';
            }
            
            // If CANCEL, lookup which cancel rule triggered
            if (closeReason === 'CANCEL') {
                const triggeredRule = getTriggeredRule(trade.rules, 'cancel');
                return triggeredRule || 'CANCEL';
            }
            
            return closeReason;
        }
        
        function renderTradeTabContent(trade, statusClass, pnl, breaker = null) {
            const content = document.getElementById('tm-trade-content');
            const isFiltered = statusClass === 'entry-denied';
            
            // === EXTRACT ALL DATA ===
            const phase = trade.status?.phase || '';
            const score = trade.scoring?.score ?? 0;
            const scoringRules = trade.scoring?.rules || {};
            
            // Outcomes - use directly from data
            const outcomes = trade.outcomes || {};
            const closeType = outcomes.close_type || '';
            const closeReason = outcomes.close_reason || '';
            const tradeOutcome = outcomes.trade_outcome || '';
            const breakerOutcome = outcomes.breaker_outcome || '';
            const closeDetails = outcomes.close_details || {};
            const pnlPoints = closeDetails.pnl_points;
            const pnlR = closeDetails.pnl_r;
            
            const entry = trade.trade_setup?.entry || 0;
            const stop = trade.trade_setup?.stop || 0;
            const target = trade.trade_setup?.target || 0;
            const risk = Math.abs(entry - stop);
            const reward = Math.abs(target - entry);
            const rr = risk > 0 ? (reward / risk).toFixed(2) : '0';
            const gateRules = trade.rules?.gate || {};
            const cancelRules = trade.rules?.cancel || {};
            const exitRules = trade.rules?.exit || {};
            const events = trade.events || [];
            const createdEvt = events.find(e => e.event === 'PENDING') || events[0];
            const filledEvt = events.find(e => e.event === 'FILLED');
            const closedEvt = events.find(e => e.event === 'EXITED' || e.event === 'CLOSED');
            
            // Derive status from trade_outcome
            const isWin = tradeOutcome === 'WIN';
            const isLoss = tradeOutcome === 'LOSS';
            const noTrade = closeType === 'FILTERED' || closeType === 'REJECTED' || closeType === 'CANCELLED' || closeType === 'EXPIRED';
            const finalStatus = isWin ? 'win' : (isLoss ? 'loss' : (noTrade ? 'filtered' : 'pending'));
            
            // Entry thresholds
            const weakEntry = breaker?.entry?.weak_entry_threshold;
            const moderateEntry = breaker?.entry?.moderate_entry_threshold;
            const strongEntry = breaker?.entry?.strong_entry_threshold;
            
            let html = `<div class="tm-report">`;
            
            // ═══════════════════════════════════════════════════════════════
            // 1. RESULT CARD - Hero with outcome + close type/reason + score
            // ═══════════════════════════════════════════════════════════════
            html += `<div class="tm-card-result ${finalStatus}">`;
            
            // Left: Outcome + P&L + all close details
            html += `<div class="tm-result-left">`;
            if (tradeOutcome) {
                html += `<div class="tm-result-outcome ${finalStatus}">${tradeOutcome}${closeType ? ` <span class="tm-result-closetype">(${closeType})</span>` : ''}</div>`;
                // Show all close_details
                if (pnlPoints !== undefined) {
                    html += `<div class="tm-result-pnl ${finalStatus}">${pnlPoints >= 0 ? '+' : ''}${pnlPoints.toFixed(2)} pts</div>`;
                }
                if (pnlR !== undefined) {
                    html += `<div class="tm-result-r ${finalStatus}">${pnlR >= 0 ? '+' : ''}${pnlR.toFixed(2)}R</div>`;
                }
                if (closeDetails.close_price !== undefined) {
                    html += `<div class="tm-result-detail">Close: ${closeDetails.close_price.toLocaleString()}</div>`;
                }
                if (closeDetails.exit_fib !== undefined) {
                    html += `<div class="tm-result-detail">Exit Fib: ${closeDetails.exit_fib.toFixed(2)}</div>`;
                }
            } else if (noTrade) {
                html += `<div class="tm-result-outcome filtered">${closeType}</div>`;
                if (closeDetails.exit_fib !== undefined) {
                    html += `<div class="tm-result-detail">Exit Fib: ${closeDetails.exit_fib.toFixed(2)}</div>`;
                }
            } else {
                html += `<div class="tm-result-outcome pending">${phase || 'WATCHING'}</div>`;
            }
            html += `</div>`;
            
            // Hypothetical section (if exists) - show market/limit boxes OR t2 box
            const hypothetical = outcomes.hypothetical;
            if (hypothetical) {
                html += `<div class="tm-result-hypothetical-section">`;
                
                // Check if this is a T2 hypothetical (for successful T1 trades)
                if (hypothetical.t2) {
                    html += `<div class="tm-hypo-header">IF T2 TARGET</div>`;
                    html += `<div class="tm-hypo-boxes">`;
                    
                    const t2 = hypothetical.t2;
                    const t2Status = t2.outcome === 'WIN' ? 'win' : (t2.outcome === 'LOSS' ? 'loss' : '');
                    html += `<div class="tm-hypo-box t2-box">`;
                    html += `<div class="tm-hypo-label">T2 POTENTIAL</div>`;
                    html += `<div class="tm-hypo-outcome ${t2Status}">${t2.outcome || '—'}</div>`;
                    if (t2.pnl_points !== undefined) html += `<div class="tm-hypo-pnl ${t2Status}">${t2.pnl_points >= 0 ? '+' : ''}${t2.pnl_points.toFixed(2)} pts</div>`;
                    if (t2.pnl_r !== undefined) html += `<div class="tm-hypo-r ${t2Status}">${t2.pnl_r >= 0 ? '+' : ''}${t2.pnl_r.toFixed(2)}R</div>`;
                    if (t2.fill_price !== undefined) html += `<div class="tm-hypo-detail">Fill: ${t2.fill_price.toLocaleString()}</div>`;
                    if (t2.exit_price !== undefined) html += `<div class="tm-hypo-detail">Exit: ${t2.exit_price.toLocaleString()}</div>`;
                    html += `</div>`;
                    
                    html += `</div>`;
                } else {
                    // Cancelled/filtered trade hypothetical (market/limit)
                    html += `<div class="tm-hypo-header">IF TRADED → Exit: ${hypothetical.exit_reason || '—'}</div>`;
                    html += `<div class="tm-hypo-boxes">`;
                    
                    // Market box
                    if (hypothetical.market) {
                        const m = hypothetical.market;
                        const mStatus = m.outcome === 'WIN' ? 'win' : (m.outcome === 'LOSS' ? 'loss' : '');
                        html += `<div class="tm-hypo-box">`;
                        html += `<div class="tm-hypo-label">MARKET</div>`;
                        html += `<div class="tm-hypo-outcome ${mStatus}">${m.outcome || '—'}</div>`;
                        if (m.pnl_points !== undefined) html += `<div class="tm-hypo-pnl ${mStatus}">${m.pnl_points >= 0 ? '+' : ''}${m.pnl_points.toFixed(2)} pts</div>`;
                        if (m.pnl_r !== undefined) html += `<div class="tm-hypo-r ${mStatus}">${m.pnl_r >= 0 ? '+' : ''}${m.pnl_r.toFixed(2)}R</div>`;
                        if (m.fill_price !== undefined) html += `<div class="tm-hypo-detail">Fill: ${m.fill_price.toLocaleString()}</div>`;
                        if (m.exit_price !== undefined) html += `<div class="tm-hypo-detail">Exit: ${m.exit_price.toLocaleString()}</div>`;
                        html += `</div>`;
                    }
                    
                    // Limit box
                    if (hypothetical.limit) {
                        const l = hypothetical.limit;
                        const lStatus = l.outcome === 'WIN' ? 'win' : (l.outcome === 'LOSS' ? 'loss' : '');
                        html += `<div class="tm-hypo-box">`;
                        html += `<div class="tm-hypo-label">LIMIT</div>`;
                        html += `<div class="tm-hypo-outcome ${lStatus}">${l.outcome || '—'}</div>`;
                        if (l.pnl_points !== undefined) html += `<div class="tm-hypo-pnl ${lStatus}">${l.pnl_points >= 0 ? '+' : ''}${l.pnl_points.toFixed(2)} pts</div>`;
                        if (l.pnl_r !== undefined) html += `<div class="tm-hypo-r ${lStatus}">${l.pnl_r >= 0 ? '+' : ''}${l.pnl_r.toFixed(2)}R</div>`;
                        if (l.fill_price !== undefined) html += `<div class="tm-hypo-detail">Fill: ${l.fill_price.toLocaleString()}</div>`;
                        if (l.exit_price !== undefined) html += `<div class="tm-hypo-detail">Exit: ${l.exit_price.toLocaleString()}</div>`;
                        html += `</div>`;
                    }
                    
                    html += `</div>`;
                }
                
                html += `</div>`;
            }
            
            // Center: Close type + reason from outcomes
            html += `<div class="tm-result-center">`;
            if (closeType) {
                html += `<div class="tm-result-close-label">${closeType}</div>`;
                html += `<div class="tm-result-close-value">${closeReason}</div>`;
                if (breakerOutcome) {
                    html += `<div class="tm-result-close-detail">${breakerOutcome.replace(/_/g, ' ')}</div>`;
                }
            }
            html += `</div>`;
            
            // Right: Score
            html += `<div class="tm-result-right">`;
            html += `<div class="tm-result-score">${score.toFixed(1)}</div>`;
            html += `<div class="tm-result-badge ${noTrade ? 'filtered' : ''}">${noTrade ? 'NO TRADE' : '✓ TRADED'}</div>`;
            html += `</div>`;
            
            html += `</div>`; // close result card
            
            // ═══════════════════════════════════════════════════════════════
            // 2. SCORING CARD - Primary focus, 2-column grid
            // ═══════════════════════════════════════════════════════════════
            html += `<div class="tm-card-scoring">`;
            html += `<div class="tm-card-title">Confluence Scoring</div>`;
            html += `<div class="tm-scoring-grid">`;
            
            const scoringEntries = Object.entries(scoringRules);
            scoringEntries.forEach(([ruleName, rule]) => {
                const s = rule.score ?? 0;
                const cls = s > 0 ? 'pos' : (s < 0 ? 'neg' : 'zero');
                const name = getRuleName(ruleName, SCORE_DEFINITIONS);
                const details = rule.details || '';
                html += `
                    <div class="tm-scoring-item ${s !== 0 ? 'has-score' : ''}">
                        <div class="tm-scoring-badge ${cls}">${s > 0 ? '+' : ''}${s}</div>
                        <div class="tm-scoring-info">
                            <div class="tm-scoring-name">${name}</div>
                            <div class="tm-scoring-reason">${rule.reason || '—'}</div>
                            ${details ? `<div class="tm-scoring-details">${details}</div>` : ''}
                        </div>
                    </div>
                `;
            });
            
            html += `</div></div>`; // close scoring card
            
            // ═══════════════════════════════════════════════════════════════
            // 3. GATES + RULES - Side by side
            // ═══════════════════════════════════════════════════════════════
            html += `<div class="tm-row-gates-rules">`;
            
            // Gates Card
            const gateEntries = Object.entries(gateRules);
            html += `<div class="tm-card tm-card-gates">`;
            html += `<div class="tm-card-title">Gate Filters</div>`;
            html += `<div class="tm-gates-list">`;
            gateEntries.forEach(([gateKey, gateData]) => {
                const passed = gateData?.gate === true;
                const gateName = getRuleName(gateKey, GATE_DEFINITIONS);
                const reason = gateData?.reason || '';
                html += `
                    <div class="tm-gate-item ${passed ? '' : 'fail'}">
                        <span class="tm-gate-icon">${passed ? '✓' : '✗'}</span>
                        <span class="tm-gate-code">${gateName}</span>
                        <span class="tm-gate-reason">${reason || '—'}</span>
                    </div>
                `;
            });
            html += `</div></div>`;
            
            // Rules Card
            const cancelEntries = Object.entries(cancelRules);
            const exitEntries = Object.entries(exitRules);
            html += `<div class="tm-card tm-card-rules">`;
            html += `<div class="tm-card-title">Trade Rules</div>`;
            html += `<div class="tm-rules-list">`;
            
            cancelEntries.forEach(([ruleKey, ruleData]) => {
                const triggered = ruleData?.cancel === true;
                const ruleName = getRuleName(ruleKey, CANCEL_DEFINITIONS);
                html += `
                    <div class="tm-rule-item ${triggered ? 'triggered' : ''}">
                        <span class="tm-rule-icon">${triggered ? '⚠' : '○'}</span>
                        <span class="tm-rule-code">${ruleName}</span>
                        <span class="tm-rule-reason">${ruleData?.reason || ''}</span>
                        ${triggered ? '<span class="tm-rule-tag">TRIGGERED</span>' : ''}
                    </div>
                `;
            });
            
            exitEntries.forEach(([ruleKey, ruleData]) => {
                const triggered = ruleData?.exit === true;
                const ruleName = getRuleName(ruleKey, EXIT_DEFINITIONS);
                html += `
                    <div class="tm-rule-item ${triggered ? 'triggered' : ''}">
                        <span class="tm-rule-icon">${triggered ? '⚠' : '○'}</span>
                        <span class="tm-rule-code">${ruleName}</span>
                        <span class="tm-rule-reason">${ruleData?.reason || ''}</span>
                        ${triggered ? '<span class="tm-rule-tag">TRIGGERED</span>' : ''}
                    </div>
                `;
            });
            
            html += `</div>`; // close rules-list
            
            // Timeline - just display events in order from data with icons
            html += `<div class="tm-timeline-inline">`;
            const eventIcons = {
                'PENDING': '⏳',
                'FILLED': '✓',
                'EXITED': '↗',
                'CLOSED': '●',
                'CANCELLED': '✗',
                'REJECTED': '⊘',
                'EXPIRED': '⏱'
            };
            events.forEach((evt, idx) => {
                if (idx > 0) html += `<span class="tm-tl-arrow">→</span>`;
                const evtClass = (evt.event || '').toLowerCase().replace(/[^a-z]/g, '');
                const icon = eventIcons[evt.event] || '○';
                html += `<span class="tm-tl-item">`;
                html += `<span class="tm-tl-dot-sm ${evtClass}">${icon}</span>`;
                html += `<span class="tm-tl-text">`;
                html += `<span class="tm-tl-lbl">${evt.event || '—'}</span>`;
                html += `<span class="tm-tl-time">${formatTimeShort(evt.time)}</span>`;
                if (evt.price) html += `<span class="tm-tl-price">@${evt.price.toLocaleString()}</span>`;
                html += `</span></span>`;
            });
            html += `</div>`;
            
            html += `</div>`; // close rules card
            html += `</div>`; // close gates-rules row
            
            // ═══════════════════════════════════════════════════════════════
            // 4. SETUP BAR - Compact, secondary
            // ═══════════════════════════════════════════════════════════════
            html += `<div class="tm-setup-bar">`;
            html += `<span class="tm-setup-item"><span class="lbl">Entry</span> <span class="val">${entry.toLocaleString()}</span></span>`;
            html += `<span class="tm-setup-divider"></span>`;
            html += `<span class="tm-setup-item"><span class="lbl">Stop</span> <span class="val">${stop.toLocaleString()}</span> <span class="pts neg">(-${risk.toFixed(1)})</span></span>`;
            html += `<span class="tm-setup-divider"></span>`;
            html += `<span class="tm-setup-item"><span class="lbl">Target</span> <span class="val">${target.toLocaleString()}</span> <span class="pts pos">(+${reward.toFixed(1)})</span></span>`;
            html += `<span class="tm-setup-divider"></span>`;
            html += `<span class="tm-setup-item"><span class="lbl">R:R</span> <span class="rr">${rr}:1</span></span>`;
            
            if (weakEntry || moderateEntry || strongEntry) {
                html += `<div class="tm-setup-zones">`;
                html += `<span class="tm-zone-tag weak">30% ${weakEntry?.toLocaleString() || '—'}</span>`;
                html += `<span class="tm-zone-tag mod">50% ${moderateEntry?.toLocaleString() || '—'}</span>`;
                html += `<span class="tm-zone-tag strong">75% ${strongEntry?.toLocaleString() || '—'}</span>`;
                html += `</div>`;
            }
            
            html += `</div>`; // close setup bar
            
            html += `</div>`; // close tm-report
            content.innerHTML = html;
        }
        
        function renderBreakerTabContent(breaker, trade, isLoading = false) {
            const content = document.getElementById('tm-breaker-content');
            
            // Loading state
            if (isLoading) {
                content.innerHTML = `
                    <div style="text-align: center; padding: 60px; color: #555;">
                        <div style="font-size: 20px; margin-bottom: 10px;">⏳</div>
                        <div>Loading breaker details...</div>
                    </div>
                `;
                return;
            }
            
            // No data state
            if (!breaker) {
                content.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #555;">
                        <div style="font-size: 24px; margin-bottom: 10px;">📐</div>
                        <div>Breaker details not available</div>
                        <div style="font-size: 11px; margin-top: 5px;">Pattern data from /breakers endpoint</div>
                    </div>
                `;
                return;
            }
            
            // Extract data using schema field names
            const pattern = breaker.pattern || {};
            const fib = breaker.fib || {};
            const zone = breaker.zone || {};
            const mss = breaker.mss || {};
            const entry = breaker.entry || {};
            const metrics = breaker.metrics || {};
            const timing = breaker.timing || {};
            const fakeout = breaker.fakeout || {};
            
            // Format helpers
            const fmtTime = (t) => {
                if (!t) return '—';
                try {
                    const d = new Date(t);
                    if (!isNaN(d)) {
                        return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                    }
                } catch (e) {}
                return String(t);
            };
            
            const fmtPrice = (p) => {
                if (p === null || p === undefined) return '—';
                if (typeof p === 'number') return p.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                return String(p);
            };
            
            // Pattern events from schema
            const h1 = { 
                price: pattern.phase1_high_price, 
                time: pattern.phase1_high_time,
                bar: pattern.phase1_high_bar_index
            };
            const l1 = { 
                price: pattern.phase1_low_price, 
                time: pattern.phase1_low_time,
                bar: pattern.phase1_low_bar_index 
            };
            const h2 = { 
                price: pattern.breaker_high_price, 
                time: pattern.breaker_high_time,
                bar: pattern.breaker_high_bar_index 
            };
            const l2 = { 
                price: pattern.sweep_low_price, 
                time: pattern.sweep_low_time,
                bar: pattern.sweep_low_bar_index 
            };
            const mssData = { 
                price: mss.mss_price, 
                time: mss.mss_time,
                bar: mss.mss_bar_index 
            };
            
            // Fib levels from schema
            const fibBase = fib.fib_base_range || 0;
            const fib0 = fib.fib_level_0;  // Base level (L2/sweep_low)
            const fib1 = fib.fib_level_1;  // 100% extension
            const fibT1 = fib.fib_t1;      // T1 target (2.2x)
            const fibT2 = fib.fib_t2;      // T2 target (3.2x)
            const fibBreaker = fib.fib_breaker || 1.0;
            
            // Calculate additional fib levels (F-2, F-3, F-4 = 2x, 3x, 4x base range from L2)
            const fib2 = fib0 ? fib0 + (2 * fibBase) : null;
            const fib3 = fib0 ? fib0 + (3 * fibBase) : null;
            const fib4 = fib0 ? fib0 + (4 * fibBase) : null;
            
            // Zone data
            const zoneHigh = zone.breaker_block_high;
            const zoneLow = zone.breaker_block_low;
            const zoneRange = zone.breaker_block_range;
            
            // Status from trade/snapshot context
            const status = breaker.status || trade?.status || 'DETECTED';
            const detection = breaker.l1_detection || 'swing';
            
            // Peak fib - would come from snapshot data, use fibBreaker as fallback
            const rawPeakFib = breaker.max_fib || breaker.peak_fib || fibBreaker;
            const peakFib = typeof rawPeakFib === 'number' ? rawPeakFib.toFixed(2) : rawPeakFib;
            
            // Build pattern flow HTML - Bullish: H1 → L1 → H2 → L2 → MSS
            let patternHtml = '<div class="tm-pattern-flow">';
            
            // H1 - Impulse peak
            patternHtml += `
                <div class="tm-pattern-node">
                    <div class="tm-pattern-dot high">H1</div>
                    <div class="tm-pattern-info">
                        <div class="tm-pattern-time">${fmtTime(h1.time)}</div>
                        <div class="tm-pattern-price">${fmtPrice(h1.price)}</div>
                    </div>
                </div>
                <div class="tm-pattern-connector"></div>
            `;
            
            // L1 - Swing low
            patternHtml += `
                <div class="tm-pattern-node">
                    <div class="tm-pattern-dot low">L1</div>
                    <div class="tm-pattern-info">
                        <div class="tm-pattern-time">${fmtTime(l1.time)}</div>
                        <div class="tm-pattern-price">${fmtPrice(l1.price)}</div>
                        <div class="tm-pattern-note swing">(${detection})</div>
                    </div>
                </div>
                <div class="tm-pattern-connector"></div>
            `;
            
            // H2 - Breaker high (retracement)
            patternHtml += `
                <div class="tm-pattern-node">
                    <div class="tm-pattern-dot high">H2</div>
                    <div class="tm-pattern-info">
                        <div class="tm-pattern-time">${fmtTime(h2.time)}</div>
                        <div class="tm-pattern-price">${fmtPrice(h2.price)}</div>
                        <div class="tm-pattern-note fvg">(breaker)</div>
                    </div>
                </div>
                <div class="tm-pattern-connector"></div>
            `;
            
            // L2 - Sweep low
            patternHtml += `
                <div class="tm-pattern-node">
                    <div class="tm-pattern-dot low">L2</div>
                    <div class="tm-pattern-info">
                        <div class="tm-pattern-time">${fmtTime(l2.time)}</div>
                        <div class="tm-pattern-price">${fmtPrice(l2.price)}</div>
                        <div class="tm-pattern-note fvg">(sweep)</div>
                    </div>
                </div>
                <div class="tm-pattern-connector"></div>
            `;
            
            // MSS - Market Structure Shift
            patternHtml += `
                <div class="tm-pattern-node">
                    <div class="tm-pattern-dot br">MSS</div>
                    <div class="tm-pattern-info">
                        <div class="tm-pattern-time">${fmtTime(mssData.time)}</div>
                        <div class="tm-pattern-price">${fmtPrice(mssData.price)}</div>
                    </div>
                </div>
            `;
            
            patternHtml += '</div>';
            
            // Metrics display
            const impulseSize = metrics.impulse_size || '—';
            const raidSize = metrics.raid_size || '—';
            const sweepDepth = metrics.sweep_depth || '—';
            const totalBars = timing.pattern_total_bars || '—';
            
            content.innerHTML = `
                <div class="tm-breaker-grid">
                    <div class="tm-panel tm-full tm-pattern-panel">
                        ${patternHtml}
                    </div>
                    <div class="tm-panel tm-metrics-panel">
                        <div class="tm-metrics-content">
                            <div class="tm-metrics-grid">
                                <div class="tm-metric">
                                    <span class="tm-metric-val ${status === 'ACTIVE' ? 'good' : ''}">${status}</span>
                                    <span class="tm-metric-lbl">Status</span>
                                </div>
                                <div class="tm-metric">
                                    <span class="tm-metric-val">${totalBars}</span>
                                    <span class="tm-metric-lbl">Bars</span>
                                </div>
                                <div class="tm-metric">
                                    <span class="tm-metric-val">${fmtPrice(zoneRange)}</span>
                                    <span class="tm-metric-lbl">Zone Range</span>
                                </div>
                                <div class="tm-metric">
                                    <span class="tm-metric-val">${fmtPrice(fibBase)}</span>
                                    <span class="tm-metric-lbl">Fib Base</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="tm-panel tm-fib-panel">
                        <div class="tm-fib-content">
                            <div class="tm-fib-values">
                                <div class="tm-fib-val-item">
                                    <span class="tm-fib-val-lbl">max_fib</span>
                                    <span class="tm-fib-val-num peak">${peakFib}</span>
                                </div>
                                <div class="tm-fib-val-item">
                                    <span class="tm-fib-val-lbl">fib_breaker</span>
                                    <span class="tm-fib-val-num fb">${fibBreaker.toFixed(2)}</span>
                                </div>
                            </div>
                            <div class="tm-fib-levels">
                                <div class="tm-fib-row f4"><span class="tm-fib-lbl">fib_t2</span><span class="tm-fib-price">${fmtPrice(fibT2)}</span></div>
                                <div class="tm-fib-row f3"><span class="tm-fib-lbl">fib_t1</span><span class="tm-fib-price">${fmtPrice(fibT1)}</span></div>
                                <div class="tm-fib-row f1"><span class="tm-fib-lbl">fib_level_1</span><span class="tm-fib-price">${fmtPrice(fib1)}</span></div>
                                <div class="tm-fib-row f0"><span class="tm-fib-lbl">fib_level_0</span><span class="tm-fib-price">${fmtPrice(fib0)}</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function switchTradeModalTab(index) {
            const tabs = document.querySelectorAll('.tm-tab');
            const contents = document.querySelectorAll('.tm-content');
            tabs.forEach((t, i) => t.classList.toggle('active', i === index));
            contents.forEach((c, i) => c.classList.toggle('active', i === index));
        }
        
        function closeTradeModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const backdrop = document.getElementById('trade-modal-backdrop');
            backdrop.classList.remove('active');
            document.removeEventListener('keydown', handleTradeModalEsc);
            currentTradeModalTrade = null;
            currentTradeModalBreaker = null;
        }
        
        function handleTradeModalEsc(e) {
            if (e.key === 'Escape') {
                closeTradeModal();
            }
        }
        
        // ===== INIT =====
        window.onload = function() {
            // Start in Live mode (buttons already set in HTML)
            isLive = true;
            
            // Load all data sources
            Promise.all([
                loadSmtData(),
                loadTradesData()
            ]).then(() => {
                loadData();
            }).catch(err => {
                console.error('Error loading data sources:', err);
                // Still try to load main data even if SMT/trades fail
                loadData();
            });
            
            setRefreshInterval();
            
            // Update viewport indicator on resize
            window.addEventListener('resize', () => {
                updateViewportIndicator();
                if (isLive) updateMainCursor();
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (lockedConfluenceMin !== null) {
                        lockedConfluenceMin = null;
                        clearEntryHighlight();
                        // Restore appropriate view based on what's selected
                        if (selectedBreakerId) {
                            showBreakerDetail(selectedBreakerId);
                        } else if (selectedSmtId) {
                            showSmtDetail(selectedSmtId);
                        } else if (isLive) {
                            showLiveConfluence();
                        } else {
                            showEmptyPanel();
                        }
                    } else if (selectedEntryMin !== null) {
                        selectEntry(selectedEntryMin);
                    } else if (selectedBreakerId !== null) {
                        selectBreaker(selectedBreakerId);
                    } else if (selectedSmtId !== null) {
                        selectSmt(selectedSmtId);
                    }
                }
            });
        };
    </script>
</body>
</html>
