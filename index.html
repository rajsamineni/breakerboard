<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SigXFlow</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f10;
            color: #e0e0e0;
            font-size: 13px;
        }
        
        /* ===== HEADER ===== */
        .header {
            background: linear-gradient(180deg, #1e1e20 0%, #1a1a1c 100%);
            border-bottom: 1px solid #2a2a2e;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .logo {
            font-size: 16px;
            font-weight: 600;
            color: #60a5fa;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .logo-icon {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            padding: 5px 7px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .logo-icon::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 7px solid #4ade80;
        }
        
        .logo-icon::after {
            content: '';
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 7px solid #f87171;
        }
        
        /* Stats */
        .stats-row {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        .stat-compact {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            padding: 6px 10px;
            background: linear-gradient(135deg, #1a1a1c 0%, #1e1e20 100%);
            border: 1px solid #2a2a2e;
            border-radius: 6px;
        }
        
        .stat-compact span {
            margin-right: 3px;
            font-size: 14px;
        }
        
        .stat-compact.success { 
            color: #4ade80; 
            border-color: rgba(74, 222, 128, 0.2);
        }
        .stat-compact.success span {
            text-shadow: 0 0 8px rgba(74, 222, 128, 0.4);
        }
        .stat-compact.fail { 
            color: #f87171; 
            border-color: rgba(248, 113, 113, 0.2);
        }
        .stat-compact.fail span {
            text-shadow: 0 0 8px rgba(248, 113, 113, 0.4);
        }
        .stat-compact.win { 
            color: #fbbf24; 
            border-color: rgba(251, 191, 36, 0.2);
        }
        .stat-compact.win span {
            text-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
        }
        
        .stat {
            padding: 8px 16px;
            background: #1f1f22;
            border: 1px solid #2a2a2e;
            border-radius: 6px;
            text-align: center;
            min-width: 70px;
        }
        
        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 600;
        }
        
        .stat-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .stat.active .stat-value { color: #60a5fa; }
        .stat.success .stat-value { color: #22c55e; }
        .stat.fail .stat-value { color: #ef4444; }
        .stat.win .stat-value { color: #fbbf24; }
        
        /* Navigation */
        .nav-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .btn {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 500;
            padding: 8px 14px;
            border-radius: 6px;
            border: 1px solid #3a3a3e;
            background: #252528;
            color: #bbb;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .btn:hover {
            background: #303035;
            border-color: #4a4a4e;
        }
        
        /* Primary action - subtle gold theme */
        .btn.primary {
            background: linear-gradient(135deg, #252528 0%, #2a2a2e 100%);
            border: 1px solid rgba(251, 191, 36, 0.4);
            color: #fbbf24;
            font-weight: 600;
        }
        
        .btn.primary:hover {
            background: linear-gradient(135deg, #2a2a2e 0%, #333 100%);
            border-color: rgba(251, 191, 36, 0.7);
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.2);
        }
        
        /* Secondary action - muted style */
        .btn.secondary {
            background: linear-gradient(135deg, #1e1e20 0%, #252528 100%);
            border: 1px solid #333;
            color: #888;
            font-weight: 500;
        }
        
        .btn.secondary:hover {
            border-color: #444;
            color: #aaa;
            background: linear-gradient(135deg, #252528 0%, #2a2a2e 100%);
        }
        
        .btn.live {
            background: #dc2626;
            border-color: #dc2626;
            color: #fff;
        }
        
        .btn.inactive {
            background: #1a1a1c;
            border-color: #2a2a2e;
            color: #555;
        }
        
        .btn.explore-active {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #888;
            color: #fff;
        }
        
        /* Styled selects - cohesive dark theme */
        .select-styled {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #333;
            background: linear-gradient(135deg, #1a1a1c 0%, #222 100%);
            color: #888;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .select-styled:hover {
            border-color: #444;
            color: #aaa;
        }
        
        .select-styled:focus {
            outline: none;
            border-color: rgba(251, 191, 36, 0.5);
        }
        
        .divider {
            width: 1px;
            height: 24px;
            background: linear-gradient(180deg, transparent 0%, #3a3a3e 50%, transparent 100%);
            margin: 0 4px;
        }
        
        /* Settings group - load, refresh, latest */
        .settings-group {
            display: flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, #1a1a1c 0%, #1e1e20 100%);
            padding: 4px 6px;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
        }
        
        .settings-group .select-styled {
            border: none;
            background: transparent;
            padding: 6px 8px;
        }
        
        .settings-group .btn {
            padding: 6px 12px;
        }
        
        .settings-group .countdown {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #555;
            min-width: 24px;
            text-align: center;
        }
        
        /* ===== TOOLBAR ===== */
        .toolbar {
            background: linear-gradient(180deg, #1a1a1c 0%, #161618 100%);
            border-bottom: 1px solid #252528;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .filter-group {
            display: flex;
            gap: 4px;
            background: linear-gradient(135deg, #1e1e20 0%, #222 100%);
            padding: 3px;
            border-radius: 6px;
            border: 1px solid #2a2a2e;
        }
        
        .filter-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            padding: 5px 10px;
            border-radius: 4px;
            border: none;
            background: transparent;
            color: #666;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .filter-btn:hover {
            color: #999;
        }
        
        .filter-btn.active {
            background: #333;
            color: #ddd;
        }
        
        .filter-btn.nq.active { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .filter-btn.es.active { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        .filter-btn.bull.active { color: #22c55e; background: rgba(22, 163, 74, 0.2); }
        .filter-btn.bear.active { color: #f87171; background: rgba(220, 38, 38, 0.2); }
        
        .arrow-up, .arrow-down {
            display: inline-block;
            width: 0;
            height: 0;
            margin-right: 4px;
            vertical-align: middle;
        }
        
        .arrow-up {
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid currentColor;
        }
        
        .arrow-down {
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid currentColor;
        }
        
        .arrow-up-sm, .arrow-down-sm {
            display: inline-block;
            width: 0;
            height: 0;
            margin-left: 2px;
            vertical-align: middle;
        }
        
        .arrow-up-sm {
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-bottom: 5px solid currentColor;
        }
        
        .arrow-down-sm {
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-top: 5px solid currentColor;
        }
        
        .toolbar-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Breaker count badge - prominent display */
        .status-msg {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
            padding: 2px 8px;
            border-radius: 4px;
            transition: opacity 0.3s;
        }
        
        .status-msg.success {
            color: #4ade80;
        }
        
        .status-msg.error {
            color: #f87171;
        }
        
        /* ===== TIMELINE BAR ===== */
        .timeline-track {
            height: 6px;
            background: #252528;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            margin-bottom: 4px;
        }
        
        .timeline-viewport {
            position: absolute;
            height: 100%;
            background: #3b82f6;
            border-radius: 3px;
            cursor: grab;
            transition: background 0.15s;
        }
        
        .timeline-viewport:hover {
            background: #60a5fa;
        }
        
        .timeline-viewport:active {
            cursor: grabbing;
            background: #93c5fd;
        }
        
        /* ===== MAIN WRAPPER ===== */
        .main-wrapper {
            display: flex;
            height: calc(100vh - 130px);
            margin: 10px;
            gap: 10px;
        }
        
        /* ===== CHART AREA ===== */
        .chart-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #131315;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
            overflow: hidden;
            min-width: 0;
        }
        
        /* Fixed Header Row */
        .header-row {
            display: flex;
            flex-shrink: 0;
            background: #1a1a1c;
            border-bottom: 1px solid #2a2a2e;
        }
        
        .left-header {
            width: 195px;
            min-width: 195px;
            height: 48px;
            padding: 0 12px;
            display: flex;
            align-items: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: #888;
            box-sizing: border-box;
        }
        
        .time-header-wrapper {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 6px 10px 0 10px;
        }
        
        .time-header {
            height: 30px;
            position: relative;
            white-space: nowrap;
        }
        
        /* Unified Scroll Container */
        .scroll-container {
            flex-grow: 1;
            overflow: auto;
        }
        
        .scroll-inner {
            display: flex;
            min-width: fit-content;
        }
        
        /* Left Panel - labels */
        .left-panel {
            width: 195px;
            min-width: 195px;
            background: #151517;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 30;
            overflow: hidden;
        }
        
        /* TF section header */
        .tf-header {
            height: 4px;
            margin-top: 8px;
            position: sticky;
            top: 0;
            z-index: 5;
        }
        
        .tf-header.tf-4h { background: linear-gradient(90deg, #f87171 0%, transparent 100%); }
        .tf-header.tf-1h { background: linear-gradient(90deg, #fbbf24 0%, transparent 100%); }
        .tf-header.tf-15m { background: linear-gradient(90deg, #4ade80 0%, transparent 100%); }
        .tf-header.tf-5m { background: linear-gradient(90deg, #60a5fa 0%, transparent 100%); }
        .tf-header.tf-1m { background: linear-gradient(90deg, #c084fc 0%, transparent 100%); }
        
        .tf-header-chart {
            height: 2px;
            display: block;
            position: sticky;
            left: 0;
            z-index: 5;
            width: 100vw;
            max-width: calc(100vw - 195px);
            background-size: 75vw 100%; /* Gradient spans 75% of viewport */
            background-repeat: no-repeat;
        }
        
        .tf-spacer {
            height: 2px;
        }
        
        /* Left panel spacer - full gradient across the panel */
        .tf-spacer[data-tf="1m"] { background: linear-gradient(90deg, #c084fc 0%, rgba(192, 132, 252, 0.5) 100%); }
        .tf-spacer[data-tf="5m"] { background: linear-gradient(90deg, #60a5fa 0%, rgba(96, 165, 250, 0.5) 100%); }
        .tf-spacer[data-tf="15m"] { background: linear-gradient(90deg, #4ade80 0%, rgba(74, 222, 128, 0.5) 100%); }
        .tf-spacer[data-tf="1h"] { background: linear-gradient(90deg, #fbbf24 0%, rgba(251, 191, 36, 0.5) 100%); }
        .tf-spacer[data-tf="4h"] { background: linear-gradient(90deg, #f87171 0%, rgba(248, 113, 113, 0.5) 100%); }
        
        /* TF background tints for chart header - gradient uses background-size */
        .tf-header-chart[data-tf="1m"] { background-image: linear-gradient(90deg, rgba(192, 132, 252, 0.5) 0%, rgba(192, 132, 252, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="5m"] { background-image: linear-gradient(90deg, rgba(96, 165, 250, 0.5) 0%, rgba(96, 165, 250, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="15m"] { background-image: linear-gradient(90deg, rgba(74, 222, 128, 0.5) 0%, rgba(74, 222, 128, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="1h"] { background-image: linear-gradient(90deg, rgba(251, 191, 36, 0.5) 0%, rgba(251, 191, 36, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="4h"] { background-image: linear-gradient(90deg, rgba(248, 113, 113, 0.5) 0%, rgba(248, 113, 113, 0.2) 50%, transparent 100%); }
        
        /* Symbol Lane rows */
        .lane-label {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            transition: all 0.2s ease;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        /* TF Group container */
        .tf-group {
            display: flex;
            flex-direction: row;
            align-items: stretch;
        }
        
        .tf-group-accent {
            width: 30px;
            min-width: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        .tf-group-accent[data-tf="1m"] { background: #c084fc; color: #1a1a1c; }
        .tf-group-accent[data-tf="5m"] { background: #60a5fa; color: #1a1a1c; }
        .tf-group-accent[data-tf="15m"] { background: #4ade80; color: #1a1a1c; }
        .tf-group-accent[data-tf="1h"] { background: #fbbf24; color: #1a1a1c; }
        .tf-group-accent[data-tf="4h"] { background: #f87171; color: #1a1a1c; }
        
        .tf-group-lanes {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .lane-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            gap: 8px;
            box-sizing: border-box;
            min-height: 68px;
            overflow: hidden;
        }
        
        .lane-row[data-symbol="ES"] {
            box-shadow: inset 0 0 0 1000px rgba(0,0,0,0.1);
        }
        
        .lane-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }
        
        .lane-stat-row {
            display: flex;
            align-items: center;
            gap: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
        }
        
        .lane-stat-dir {
            width: 10px;
            font-size: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .lane-stat-dir.bull::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid #22c55e;
        }
        
        .lane-stat-dir.bear::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid #ef4444;
        }
        
        .lane-stat-counts {
            color: #888;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .lane-stat-bar {
            flex: 1;
            min-width: 20px;
            height: 6px;
            background: #252528;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .lane-stat-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .lane-stat-fill.bull {
            background: linear-gradient(90deg, #22c55e, #4ade80);
        }
        
        .lane-stat-fill.bear {
            background: linear-gradient(90deg, #ef4444, #f87171);
        }
        
        .lane-stat-pct {
            text-align: right;
            font-weight: 600;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .lane-stat-pct.bull { color: #4ade80; }
        .lane-stat-pct.bear { color: #f87171; }
        .lane-stat-pct.neutral { color: #555; }
        
        .lane-row.has-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-row.has-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Timeframe background tints for left panel */
        .tf-group[data-tf="1m"] .tf-group-lanes { background: rgba(192, 132, 252, 0.03); }
        .tf-group[data-tf="5m"] .tf-group-lanes { background: rgba(96, 165, 250, 0.03); }
        .tf-group[data-tf="15m"] .tf-group-lanes { background: rgba(74, 222, 128, 0.03); }
        .tf-group[data-tf="1h"] .tf-group-lanes { background: rgba(251, 191, 36, 0.03); }
        .tf-group[data-tf="4h"] .tf-group-lanes { background: rgba(248, 113, 113, 0.03); }
        
        .symbol-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 4px;
            min-width: 28px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .symbol-badge.nq { background: rgba(37, 99, 235, 0.25); color: #60a5fa; border: 1px solid rgba(37, 99, 235, 0.4); }
        .symbol-badge.es { background: rgba(6, 182, 212, 0.25); color: #22d3ee; border: 1px solid rgba(6, 182, 212, 0.4); }
        
        /* Right Panel - chart */
        .right-panel {
            flex-grow: 1;
            position: relative;
        }
        
        .time-tick-label {
            position: absolute;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #555;
            top: 50%;
            transform: translateY(-50%);
            white-space: nowrap;
        }
        
        .chart-inner {
            position: relative;
            overflow: visible;
        }
        
        /* Swimlane row */
        .swimlane {
            position: relative;
            box-sizing: border-box;
            min-height: 68px;
        }
        
        /* Timeframe background tints for swimlanes */
        .swimlane[data-tf="1m"] { background: rgba(192, 132, 252, 0.02); }
        .swimlane[data-tf="5m"] { background: rgba(96, 165, 250, 0.02); }
        .swimlane[data-tf="15m"] { background: rgba(74, 222, 128, 0.02); }
        .swimlane[data-tf="1h"] { background: rgba(251, 191, 36, 0.02); }
        .swimlane[data-tf="4h"] { background: rgba(248, 113, 113, 0.02); }
        
        /* ES rows slightly darker for visual separation */
        .swimlane[data-symbol="ES"] {
            box-shadow: inset 0 0 0 1000px rgba(0,0,0,0.1);
        }
        
        /* ===== BREAKER BARS ===== */
        .breaker-bar {
            position: absolute;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 5px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: rgba(255,255,255,0.95);
            overflow: hidden;
            min-width: 6px;
        }
        
        .bar-right-group {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .breaker-bar:hover {
            z-index: 20;
            filter: brightness(1.15);
            box-shadow: 0 0 12px rgba(255,255,255,0.2);
        }
        
        .breaker-bar.selected {
            box-shadow: 0 0 0 2px #fff;
            z-index: 21;
        }
        
        /* NQ Bull = Forest Green */
        .breaker-bar.nq.bull { background: #16a34a; }
        /* NQ Bear = Crimson Red */
        .breaker-bar.nq.bear { background: #dc2626; }
        /* ES Bull = Forest Green with bottom stripe */
        .breaker-bar.es.bull { background: #16a34a; }
        /* ES Bear = Crimson Red with bottom stripe */
        .breaker-bar.es.bear { background: #dc2626; }
        
        /* ES indicator - white bottom stripe */
        .breaker-bar.es::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 0 0 4px 4px;
        }
        
        /* Completed = slightly faded */
        .breaker-bar.completed {
            opacity: 0.75;
        }
        
        .breaker-bar.completed:hover {
            opacity: 1;
        }
        
        /* Fib label */
        .bar-fib {
            flex-shrink: 0;
        }
        
        /* Status dot */
        .status-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 700;
            flex-shrink: 0;
            border: 2px solid rgba(255,255,255,0.95);
            color: #fff;
        }
        
        .status-dot.success {
            background: #16a34a;
        }
        
        .status-dot.fail {
            background: #dc2626;
        }
        
        /* Active at entry highlight (for selection - yellow crisp) */
        .breaker-bar.active-at-entry {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 25;
            opacity: 1 !important;
        }
        
        /* Cursor hover highlight (yellow - crisp) */
        .breaker-bar.cursor-active {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 24;
            opacity: 1 !important;
        }
        
        .lane-row.cursor-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-row.cursor-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Live mode highlight (yellow - same as cursor) */
        .breaker-bar.live-active {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 23;
            opacity: 1 !important;
        }
        
        .lane-row.live-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-row.live-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Entry lines */
        .entry-line {
            position: absolute;
            top: 0;
            width: 2px;
            background: rgba(251, 191, 36, 0.4);
            z-index: 15;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        /* Wider invisible hit area for easier clicking */
        .entry-line::after {
            content: '';
            position: absolute;
            top: 0;
            left: -12px;
            width: 26px;
            height: 100%;
            background: transparent;
        }
        
        .entry-line:hover {
            background: #fbbf24;
            width: 6px;
            margin-left: -2px;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        .entry-line.selected {
            background: #fbbf24;
            width: 4px;
            margin-left: -1px;
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.8);
        }
        
        /* Cursor line */
        .cursor-line {
            position: absolute;
            top: 0;
            width: 1px;
            border-left: 1px dashed rgba(255, 255, 255, 0.5);
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        .cursor-line.visible {
            opacity: 1;
        }
        
        .cursor-time {
            position: fixed;
            display: none;
            background: #fbbf24;
            color: #000;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
        }
        
        /* ===== DETAIL PANEL ===== */
        .detail-panel {
            width: 320px;
            min-width: 320px;
            background: #1a1a1c;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-header {
            padding: 10px 16px;
            background: #1f1f22;
            border-bottom: 1px solid #2a2a2e;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .panel-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            color: #fbbf24;
        }
        
        .panel-type {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .panel-type.live {
            color: #f87171;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .panel-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #555;
            text-align: center;
            padding: 20px;
        }
        
        .panel-empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        
        .panel-empty-text {
            font-size: 13px;
            line-height: 1.5;
        }
        
        /* Breaker Detail View */
        .detail-section {
            margin-bottom: 20px;
        }
        
        .detail-section:last-child {
            margin-bottom: 0;
        }
        
        .detail-section-title {
            font-size: 10px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #2a2a2e;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .live-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #60a5fa;
            animation: pulse-live 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-live {
            0%, 100% { opacity: 1; box-shadow: 0 0 6px #60a5fa; }
            50% { opacity: 0.6; box-shadow: 0 0 3px #60a5fa; }
        }
        
        .detail-id {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
        }
        
        .detail-badges {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .detail-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 4px;
        }
        
        .detail-badge.nq { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .detail-badge.es { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        .detail-badge.bull { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .detail-badge.bear { background: rgba(249, 115, 22, 0.2); color: #fb923c; }
        .detail-badge.active { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .detail-badge.success { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
        .detail-badge.fail { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #222;
        }
        
        .detail-row:last-child {
            border-bottom: none;
        }
        
        .detail-label {
            color: #888;
            font-size: 12px;
        }
        
        .detail-value {
            font-family: 'JetBrains Mono', monospace;
            color: #ddd;
            font-size: 12px;
            font-weight: 500;
        }
        
        .detail-value.large {
            font-size: 18px;
            color: #fff;
        }
        
        /* Entry Context View */
        .context-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: 16px;
        }
        
        .context-grid {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .context-row {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            background: #151517;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .context-row.active {
            background: rgba(251, 191, 36, 0.12);
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
        }
        
        .context-row.live-active-row {
            background: rgba(251, 191, 36, 0.12);
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
        }
        
        .context-tf {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            width: 36px;
            color: #888;
        }
        
        .context-symbol {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            width: 28px;
            padding: 2px 4px;
            border-radius: 3px;
            text-align: center;
            margin-right: 10px;
        }
        
        .context-symbol.nq { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .context-symbol.es { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        
        .context-dir {
            font-size: 11px;
            font-weight: 600;
            width: 50px;
        }
        
        .context-dir.bull { color: #60a5fa; }
        .context-dir.bear { color: #fb923c; }
        .context-dir.none { color: #555; }
        
        .context-header {
            display: flex;
            align-items: center;
            padding: 4px 10px;
            font-size: 9px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #2a2a2e;
            margin-bottom: 4px;
        }
        
        .context-header span:nth-child(1) { width: 36px; }
        .context-header span:nth-child(2) { width: 38px; }
        .context-header span:nth-child(3) { width: 50px; }
        .context-header span:nth-child(4) { flex: 1; }
        .context-header span:nth-child(5) { width: 24px; text-align: center; }
        
        .context-fib {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #aaa;
            flex: 1;
        }
        
        .context-status-icon {
            font-size: 11px;
            width: 24px;
            text-align: center;
        }
        
        .context-status-icon.active { color: #60a5fa; }
        .context-status-icon.success { color: #4ade80; }
        .context-status-icon.fail { color: #f87171; }
        .context-status-icon.none { color: #444; }
        
        .arrow-bull { color: #4ade80; }
        .arrow-bear { color: #f87171; }
        
        .context-summary {
            margin-top: 16px;
            padding: 12px;
            background: #151517;
            border-radius: 6px;
        }
        
        .context-summary-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }
        
        .context-summary-label {
            color: #888;
            font-size: 12px;
        }
        
        .context-summary-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 12px;
        }
        
        .context-summary-value.good { color: #4ade80; }
        .context-summary-value.bad { color: #f87171; }
        .context-summary-value.neutral { color: #fbbf24; }
        
        /* Fib Chart */
        .fib-chart-container {
            margin-top: 8px;
            background: #151517;
            border-radius: 6px;
            padding: 12px;
        }
        
        .fib-chart {
            width: 100%;
            height: 120px;
        }
        
        .fib-chart-axis {
            stroke: #333;
            stroke-width: 1;
        }
        
        .fib-chart-grid {
            stroke: #222;
            stroke-width: 1;
            stroke-dasharray: 2, 4;
        }
        
        .fib-chart-line {
            fill: none;
            stroke: #60a5fa;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        .fib-chart-area {
            fill: url(#fibGradient);
            opacity: 0.3;
        }
        
        .fib-chart-dot {
            fill: #60a5fa;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .fib-chart-dot:hover {
            fill: #fff;
            r: 5;
        }
        
        .fib-chart-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            fill: #666;
        }
        
        .fib-chart-value-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            fill: #888;
        }
        
        .fib-chart-peak {
            fill: #4ade80;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .fib-peak-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            fill: #4ade80;
            font-weight: 600;
        }
        
        .fib-chart-container {
            position: relative;
        }
        
        .fib-cursor-line {
            stroke: #fbbf24;
            stroke-width: 1;
            stroke-dasharray: 3, 3;
            opacity: 0;
            pointer-events: none;
        }
        
        .fib-cursor-dot {
            fill: #fbbf24;
            opacity: 0;
            pointer-events: none;
        }
        
        .fib-cursor-tooltip {
            position: absolute;
            background: #252528;
            border: 1px solid #3a3a3e;
            border-radius: 4px;
            padding: 6px 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 10;
            white-space: nowrap;
        }
        
        .fib-cursor-tooltip .fib-val {
            color: #60a5fa;
            font-weight: 600;
        }
        
        .fib-cursor-tooltip .time-val {
            color: #888;
            margin-left: 8px;
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .toast.error { background: #dc2626; }
        .toast.success { background: #16a34a; }
        
        /* Legend */
        .legend {
            display: flex;
            gap: 12px;
            align-items: center;
            font-size: 11px;
            color: #888;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-swatch {
            width: 18px;
            height: 14px;
            border-radius: 3px;
            position: relative;
        }
        
        .legend-swatch.nq-bull { background: #16a34a; }
        .legend-swatch.nq-bear { background: #dc2626; }
        .legend-swatch.es-bull { background: #16a34a; }
        .legend-swatch.es-bear { background: #dc2626; }
        
        /* ES legend swatches get bottom stripe */
        .legend-swatch.es-bull::after,
        .legend-swatch.es-bear::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 0 0 3px 3px;
        }
        
        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 700;
            border: 2px solid rgba(255,255,255,0.8);
            color: #fff;
        }
        
        .legend-dot.win { 
            background: #16a34a;
        }
        .legend-dot.loss { 
            background: #dc2626;
        }
        
        .legend-swatch.entry { 
            background: #fbbf24; 
            width: 3px; 
            height: 16px;
        }
        
        .legend-divider {
            width: 1px;
            height: 16px;
            background: #3a3a3e;
            margin: 0 4px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1c;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #3a3a3e;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a4e;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-left">
            <div class="logo"><span class="logo-icon"></span> SigXFlow</div>
            <div class="stats-row">
                <div class="stat-compact success"><span id="stat-success">-</span> S</div>
                <div class="stat-compact fail"><span id="stat-fail">-</span> F</div>
                <div class="stat-compact win"><span id="stat-winrate">-</span></div>
            </div>
        </div>
        
        <div class="nav-group">
            <button class="btn inactive" id="mode-explore" onclick="setMode('explore')">üîç Explore</button>
            <button class="btn live" id="mode-live" onclick="setMode('live')">üî¥ Live</button>
            <div class="divider"></div>
            <div class="settings-group">
                <select class="select-styled" id="load-limit" onchange="loadData(true)">
                    <option value="8" selected>Load 8hr</option>
                    <option value="12">Load 12hr</option>
                    <option value="24">Load 24hr</option>
                    <option value="48">Load 48hr</option>
                </select>
                <select class="select-styled" id="refresh-interval" onchange="setRefreshInterval()">
                    <option value="0">Auto: Off</option>
                    <option value="30" selected>Auto: 30s</option>
                    <option value="60">Auto: 1m</option>
                    <option value="300">Auto: 5m</option>
                </select>
                <span class="countdown" id="countdown"></span>
                <button class="btn secondary" onclick="loadData(true)">‚Üª</button>
                <button class="btn primary" onclick="goToLatest()">Latest ‚Üí|</button>
            </div>
        </div>
    </div>
    
    <!-- Toolbar -->
    <div class="toolbar">
        <div class="legend">
            <div class="legend-item"><div class="legend-swatch nq-bull"></div>NQ Bull</div>
            <div class="legend-item"><div class="legend-swatch nq-bear"></div>NQ Bear</div>
            <div class="legend-item"><div class="legend-swatch es-bull"></div>ES Bull</div>
            <div class="legend-item"><div class="legend-swatch es-bear"></div>ES Bear</div>
            <div class="legend-divider"></div>
            <div class="legend-item"><div class="legend-dot win">S</div>Success</div>
            <div class="legend-item"><div class="legend-dot loss">F</div>Failure</div>
            <div class="legend-divider"></div>
            <div class="legend-item"><div class="legend-swatch entry"></div>Entry</div>
        </div>
        
        <div class="toolbar-right">
            <span class="status-msg" id="status-msg"></span>
            <div class="filter-group">
                <button class="filter-btn nq active" id="filter-nq" onclick="toggleFilter('nq')">NQ</button>
                <button class="filter-btn es active" id="filter-es" onclick="toggleFilter('es')">ES</button>
            </div>
            <div class="filter-group">
                <button class="filter-btn bull active" id="filter-bull" onclick="toggleFilter('bull')"><span class="arrow-up"></span> Bull</button>
                <button class="filter-btn bear active" id="filter-bear" onclick="toggleFilter('bear')"><span class="arrow-down"></span> Bear</button>
            </div>
        </div>
    </div>
    
    <!-- Main Wrapper -->
    <div class="main-wrapper">
        <!-- Chart Area -->
        <div class="chart-area">
            <div class="header-row">
                <div class="left-header" id="data-start">--</div>
                <div class="time-header-wrapper">
                    <div class="timeline-track" id="timeline-track">
                        <div class="timeline-viewport" id="viewport-indicator"></div>
                    </div>
                    <div class="time-header" id="time-header"></div>
                </div>
            </div>
            <div class="scroll-container" id="scroll-container">
                <div class="scroll-inner">
                    <div class="left-panel" id="left-panel"></div>
                    <div class="right-panel">
                        <div class="chart-inner" id="chart-inner"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Detail Panel -->
        <div class="detail-panel">
            <div class="panel-header">
                <span class="panel-time" id="panel-time"></span>
                <span class="panel-type" id="panel-type">Details</span>
            </div>
            <div class="panel-content" id="panel-content">
                <div class="panel-empty">
                    <div class="panel-empty-icon">üìã</div>
                    <div class="panel-empty-text">
                        Click a breaker bar or entry line to see details
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        // ===== CONFIG =====
        const FIREBASE_URL = "https://sigxflow-default-rtdb.firebaseio.com/snapshots.json";
        const PIXELS_PER_MINUTE = 30;
        const BAR_HEIGHT = 26;  // Height of breaker bars
        const BAR_GAP = 3;      // Gap between stacked bars
        const LANE_PADDING = 6; // Top/bottom padding in swimlanes
        const TF_HEADER_HEIGHT = 2;
        const LEFT_PANEL_MIN_HEIGHT = 68; // Minimum based on left panel content
        
        const TF_ORDER = ['1m', '5m', '15m', '1h', '4h'];
        const TF_DISPLAY = { '4h': '4H', '1h': '1H', '15m': '15m', '5m': '5m', '1m': '1m' };
        const SYMBOLS = ['NQ', 'ES'];
        
        // ===== STATE =====
        let allData = [];
        let breakerCache = {}; // For incremental updates
        let windowStartMin = 0;
        let windowEndMin = 0;
        let dataMinTime = 0;
        let dataMaxTime = 0;
        let isLive = true;
        let isFirstLoad = true;
        let lastFetchedTime = null; // Track last observation_time for incremental fetch
        let lastLoadLimit = null; // Track if limit changed (requires full reload)
        let refreshTimer = null;
        let countdownTimer = null;
        let countdownSecs = 0;
        let selectedEntryMin = null;
        let selectedBreakerId = null;
        let entryTimes = [];
        let chartAbortController = null; // For cleaning up event listeners
        let renderedBars = []; // Cached bar elements for fast highlight
        let renderedLaneLabels = []; // Cached lane labels
        let laneStats = {}; // Stats per tf/symbol/direction
        
        const filters = {
            nq: true, es: true,
            bull: true, bear: true
        };
        
        // ===== UTILITIES =====
        function datetimeToMin(datetime) {
            const parts = datetime.replace('T', ' ').split(' ');
            const dateParts = parts[0].split('-');
            const timeParts = (parts[1] || '00:00').split(':');
            const d = new Date(
                parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]),
                parseInt(timeParts[0]), parseInt(timeParts[1])
            );
            return Math.floor(d.getTime() / 60000);
        }
        
        function minToTime(m) {
            const d = new Date(m * 60000);
            return d.getHours().toString().padStart(2, '0') + ':' + 
                   d.getMinutes().toString().padStart(2, '0');
        }
        
        function minToDateTime(m) {
            const d = new Date(m * 60000);
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            return months[d.getMonth()] + ' ' + d.getDate() + ', ' + minToTime(m);
        }
        
        function minToDuration(startMin, endMin) {
            const mins = endMin - startMin;
            if (mins < 60) return mins + 'm';
            const hrs = Math.floor(mins / 60);
            const rem = mins % 60;
            return rem > 0 ? `${hrs}h ${rem}m` : `${hrs}h`;
        }
        
        let toastTimeout = null;
        
        function showToast(msg, type = '') {
            const el = document.getElementById('status-msg');
            el.textContent = msg;
            el.className = 'status-msg ' + type;
            // Clear previous timeout and set new one
            if (toastTimeout) clearTimeout(toastTimeout);
            if (type !== 'error') {
                toastTimeout = setTimeout(() => {
                    el.textContent = '';
                    toastTimeout = null;
                }, 5000);
            }
        }
        
        // ===== STACKING ALGORITHM =====
        function assignStackPositions(breakers) {
            if (!breakers.length) return [];
            
            const sorted = [...breakers].sort((a, b) => a.startMin - b.startMin);
            const stackEnds = [];
            
            sorted.forEach(b => {
                let stackIdx = 0;
                while (stackIdx < stackEnds.length && stackEnds[stackIdx] > b.startMin) {
                    stackIdx++;
                }
                
                b.stackIdx = stackIdx;
                stackEnds[stackIdx] = b.endMin + 1;
            });
            
            return sorted;
        }
        
        // ===== WINDOW MANAGEMENT =====
        function setWindow(startMin, endMin, label) {
            windowStartMin = startMin;
            windowEndMin = endMin;
            
            updateViewportIndicator();
        }
        
        function updateMiniTimeline() {
            updateViewportIndicator();
        }
        
        function setMode(mode) {
            isLive = (mode === 'live');
            
            const exploreBtn = document.getElementById('mode-explore');
            const liveBtn = document.getElementById('mode-live');
            
            if (isLive) {
                liveBtn.classList.remove('inactive');
                exploreBtn.classList.remove('explore-active');
                exploreBtn.classList.add('inactive');
                // Show live confluence if data exists and nothing selected
                if (allData.length > 0 && !selectedBreakerId && !selectedEntryMin) {
                    showLiveConfluence();
                }
            } else {
                exploreBtn.classList.remove('inactive');
                exploreBtn.classList.add('explore-active');
                liveBtn.classList.add('inactive');
                // Clear live highlights
                clearLiveHighlight();
                // Only show empty panel if nothing selected
                if (!selectedBreakerId && !selectedEntryMin) {
                    showEmptyPanel();
                }
            }
            
            loadData();
        }
        
        function goToLatest() {
            if (dataMaxTime === 0) {
                showToast('No data loaded', 'error');
                return;
            }
            
            const container = document.getElementById('scroll-container');
            container.scrollLeft = container.scrollWidth;
        }
        
        function shiftWindow(direction) {
            if (dataMinTime === 0 || dataMaxTime === 0) {
                showToast('No data loaded', 'error');
                return;
            }
            
            const windowHours = getLoadHours();
            const shift = direction * windowHours * 60;
            let newStart = windowStartMin + shift;
            let newEnd = windowEndMin + shift;
            
            if (newStart < dataMinTime) {
                newStart = dataMinTime;
                newEnd = newStart + windowHours * 60;
            }
            if (newEnd > dataMaxTime) {
                newEnd = dataMaxTime;
                newStart = Math.max(dataMinTime, newEnd - windowHours * 60);
            }
            
            if (newStart === windowStartMin && newEnd === windowEndMin) {
                showToast('No more data in that direction', 'error');
                return;
            }
            
            windowStartMin = newStart;
            windowEndMin = newEnd;
            setWindow(windowStartMin, windowEndMin, 'Custom ' + windowHours + 'hr');
            renderChart();
            
            setTimeout(() => {
                const container = document.getElementById('scroll-container');
                if (direction > 0) {
                    container.scrollLeft = 0;
                } else {
                    container.scrollLeft = container.scrollWidth;
                }
            }, 50);
        }
        
        function advanceLiveWindow() {
            // Get current time in minutes (matching how datetimeToMin works)
            const now = new Date();
            const nowMin = Math.floor(now.getTime() / 60000);
            
            // Extend dataMaxTime to now if it's behind
            if (nowMin > dataMaxTime) {
                dataMaxTime = nowMin;
            }
            
            // In live mode, keep window at the latest edge
            const windowSize = windowEndMin - windowStartMin;
            windowEndMin = dataMaxTime;
            windowStartMin = Math.max(dataMinTime, dataMaxTime - windowSize);
            
            setWindow(windowStartMin, windowEndMin, 'Live');
            renderChart();
            
            // Scroll to right edge and show live confluence (only if nothing selected)
            setTimeout(() => {
                const container = document.getElementById('scroll-container');
                container.scrollLeft = container.scrollWidth;
                if (!selectedBreakerId && !selectedEntryMin) {
                    showLiveConfluence();
                }
            }, 50);
        }
        
        // ===== FILTERS =====
        function toggleFilter(key) {
            filters[key] = !filters[key];
            const btn = document.getElementById('filter-' + key);
            if (btn) btn.classList.toggle('active', filters[key]);
            renderChart();
        }
        
        // ===== DATA LOADING =====
        function getLoadHours() {
            const el = document.getElementById('load-limit');
            return el ? parseInt(el.value) : 8;
        }
        
        function loadData(forceFullLoad = false) {
            const currentHours = getLoadHours();
            
            const needsFullLoad = forceFullLoad || 
                                  !lastFetchedTime || 
                                  lastLoadLimit !== currentHours ||
                                  Object.keys(breakerCache).length === 0;
            
            lastLoadLimit = currentHours;
            
            if (needsFullLoad) {
                // Full load with server-side time filtering
                showToast('Loading...', '');
                
                // Calculate cutoff time for server-side query (local time to match Firebase format)
                const now = new Date();
                const cutoffDate = new Date(now.getTime() - (currentHours * 60 * 60 * 1000));
                
                // Format as local time ISO string (Firebase stores Eastern time, not UTC)
                const pad = n => n.toString().padStart(2, '0');
                const cutoffISO = `${cutoffDate.getFullYear()}-${pad(cutoffDate.getMonth()+1)}-${pad(cutoffDate.getDate())}T${pad(cutoffDate.getHours())}:${pad(cutoffDate.getMinutes())}:${pad(cutoffDate.getSeconds())}`;
                
                // Try server-side filtered query first
                const filteredUrl = FIREBASE_URL + 
                    '?orderBy="observation_time"&startAt="' + cutoffISO + '"';
                
                fetch(filteredUrl)
                    .then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.json();
                    })
                    .then(data => {
                        if (!data) throw new Error('No data');
                        
                        let entries = Object.entries(data)
                            .filter(([k, v]) => v && v.observation_time);
                        
                        if (entries.length === 0) throw new Error('No valid data');
                        
                        console.log('‚úì Indexed query returned', entries.length, 'snapshots');
                        
                        // Sort by time
                        entries.sort((a, b) => {
                            const tsA = a[1].observation_time || '';
                            const tsB = b[1].observation_time || '';
                            return tsA.localeCompare(tsB);
                        });
                        
                        const limited = {};
                        entries.forEach(([k, v]) => limited[k] = v);
                        
                        processFirebaseData(limited, true);
                    })
                    .catch(err => {
                        // Fallback: If query fails (no index), try unfiltered load
                        console.warn('Filtered query failed, trying full load:', err);
                        return fetch(FIREBASE_URL)
                            .then(r => {
                                if (!r.ok) throw new Error('HTTP ' + r.status);
                                return r.json();
                            })
                            .then(data => {
                                if (!data) throw new Error('No data');
                                
                                let entries = Object.entries(data)
                                    .filter(([k, v]) => v && v.observation_time);
                                
                                if (entries.length === 0) throw new Error('No valid data');
                                
                                console.log('‚ö† Fallback: loaded ALL', entries.length, 'snapshots, filtering client-side');
                                
                                // Find the latest observation time
                                let latestTime = '';
                                entries.forEach(([k, v]) => {
                                    if (v.observation_time > latestTime) {
                                        latestTime = v.observation_time;
                                    }
                                });
                                
                                // Calculate cutoff time (X hours before latest)
                                const latestMin = datetimeToMin(latestTime);
                                const cutoffMin = latestMin - (currentHours * 60);
                                
                                // Filter to only include snapshots within time range
                                entries = entries.filter(([k, v]) => {
                                    const snapMin = datetimeToMin(v.observation_time);
                                    return snapMin >= cutoffMin;
                                });
                                
                                // Sort by time
                                entries.sort((a, b) => {
                                    const tsA = a[1].observation_time || '';
                                    const tsB = b[1].observation_time || '';
                                    return tsA.localeCompare(tsB);
                                });
                                
                                const limited = {};
                                entries.forEach(([k, v]) => limited[k] = v);
                                
                                processFirebaseData(limited, true);
                            });
                    })
                    .catch(err => {
                        showToast('Error: ' + err.message, 'error');
                        console.error(err);
                    });
            } else {
                // Incremental load - only fetch newer data from Firebase
                const url = FIREBASE_URL + 
                    '?orderBy="observation_time"&startAfter="' + lastFetchedTime + '"';
                
                console.log('Incremental fetch:', url);
                
                fetch(url)
                    .then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.json();
                    })
                    .then(data => {
                        if (!data || Object.keys(data).length === 0) {
                            // In Live mode, advance window to current time even if no data
                            if (isLive) {
                                advanceLiveWindow();
                                showToast('Live - no new data', '');
                            } else {
                                showToast('No new data', '');
                            }
                            return;
                        }
                        
                        console.log('Incremental data:', Object.keys(data).length, 'snapshots');
                        processIncrementalData(data);
                    })
                    .catch(err => {
                        // If query fails (no index), show error with instructions
                        console.error('Incremental fetch failed:', err);
                        showToast('Index needed - see console', 'error');
                    });
            }
        }
        
        function processFirebaseData(snapshots, isFullLoad = true) {
            if (isFullLoad) {
                breakerCache = {}; // Reset cache on full load
            }
            
            let snapshotList = Array.isArray(snapshots) 
                ? snapshots 
                : Object.values(snapshots).filter(s => s);
            
            if (snapshotList.length === 0) {
                showToast('No data', 'error');
                return;
            }
            
            snapshotList.sort((a, b) => {
                const tsA = a.observation_time || '';
                const tsB = b.observation_time || '';
                return tsA.localeCompare(tsB);
            });
            
            // Track the latest observation time for incremental fetches
            const latestSnap = snapshotList[snapshotList.length - 1];
            lastFetchedTime = latestSnap.observation_time;
            
            let minTime = Infinity, maxTime = 0;
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                if (ts) {
                    const min = datetimeToMin(ts);
                    if (min < minTime) minTime = min;
                    if (min > maxTime) maxTime = min;
                }
            });
            
            dataMinTime = minTime;
            dataMaxTime = maxTime;
            
            // Show all loaded data (use load limit, not hardcoded 8hr)
            windowEndMin = dataMaxTime;
            windowStartMin = dataMinTime;
            
            setWindow(windowStartMin, windowEndMin, 'Latest');
            
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                const datetime = ts.replace('T', ' ');
                const absMin = datetimeToMin(ts);
                
                Object.entries(snap.breakers || {}).forEach(([id, b]) => {
                    if (!breakerCache[id]) {
                        breakerCache[id] = {
                            id,
                            tf: b.tf.toLowerCase(),
                            dir: b.dir.toLowerCase(),
                            status: 'active',
                            events: [],
                            maxFib: 0
                        };
                    }
                    
                    const fib = b.fib || 1;
                    // Avoid duplicate events (same timestamp)
                    if (!breakerCache[id].events.some(e => e.absMin === absMin)) {
                        breakerCache[id].events.push({ datetime, absMin, fib });
                    }
                    breakerCache[id].maxFib = Math.max(breakerCache[id].maxFib, fib);
                    
                    if (b.status === 'success' || b.status === 'fail') {
                        breakerCache[id].status = b.status;
                    }
                });
            });
            
            finalizeBreakers();
            
            showToast('Loaded ' + allData.length + ' breakers', 'success');
        }
        
        function processIncrementalData(snapshots) {
            let snapshotList = Array.isArray(snapshots) 
                ? snapshots 
                : Object.values(snapshots).filter(s => s);
            
            if (snapshotList.length === 0) {
                showToast('No new data', '');
                return;
            }
            
            snapshotList.sort((a, b) => {
                const tsA = a.observation_time || '';
                const tsB = b.observation_time || '';
                return tsA.localeCompare(tsB);
            });
            
            // Update lastFetchedTime
            const latestSnap = snapshotList[snapshotList.length - 1];
            lastFetchedTime = latestSnap.observation_time;
            
            // Update max time
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                if (ts) {
                    const min = datetimeToMin(ts);
                    if (min > dataMaxTime) dataMaxTime = min;
                }
            });
            
            // Merge into cache
            let newBreakers = 0;
            
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                const datetime = ts.replace('T', ' ');
                const absMin = datetimeToMin(ts);
                
                Object.entries(snap.breakers || {}).forEach(([id, b]) => {
                    if (!breakerCache[id]) {
                        breakerCache[id] = {
                            id,
                            tf: b.tf.toLowerCase(),
                            dir: b.dir.toLowerCase(),
                            status: 'active',
                            events: [],
                            maxFib: 0
                        };
                        newBreakers++;
                    }
                    
                    const fib = b.fib || 1;
                    // Avoid duplicate events (same timestamp)
                    if (!breakerCache[id].events.some(e => e.absMin === absMin)) {
                        breakerCache[id].events.push({ datetime, absMin, fib });
                    }
                    breakerCache[id].maxFib = Math.max(breakerCache[id].maxFib, fib);
                    
                    if (b.status === 'success' || b.status === 'fail') {
                        breakerCache[id].status = b.status;
                    }
                });
            });
            
            // Update window to include new data
            // In live mode, keep window size fixed and slide it
            if (isLive) {
                const windowSize = windowEndMin - windowStartMin;
                windowEndMin = dataMaxTime;
                windowStartMin = Math.max(dataMinTime, dataMaxTime - windowSize);
            } else {
                windowEndMin = dataMaxTime;
            }
            setWindow(windowStartMin, windowEndMin, 'Latest');
            
            finalizeBreakers();
            
            showToast(`+${snapshotList.length} snapshots, ${newBreakers} new breakers`, 'success');
        }
        
        // Prune data outside retention window to prevent memory growth
        function pruneOldData() {
            if (dataMaxTime === 0) return;
            
            // Use load limit + 30 min buffer as retention window
            const retentionMinutes = (getLoadHours() * 60) + 30;
            const cutoffMin = dataMaxTime - retentionMinutes;
            let pruned = 0;
            
            for (const id in breakerCache) {
                const breaker = breakerCache[id];
                // Remove breakers that ended before the cutoff
                if (breaker.endMin && breaker.endMin < cutoffMin) {
                    delete breakerCache[id];
                    pruned++;
                }
            }
            
            // Update dataMinTime
            if (pruned > 0) {
                const remaining = Object.values(breakerCache);
                if (remaining.length > 0) {
                    dataMinTime = Math.min(...remaining.map(d => d.startMin || d.events[0]?.absMin || dataMaxTime));
                }
            }
        }
        
        function finalizeBreakers() {
            // First, set startMin/endMin on all breakers in cache
            for (const id in breakerCache) {
                const d = breakerCache[id];
                if (d.events.length > 0) {
                    d.events.sort((a, b) => a.absMin - b.absMin);
                    d.startMin = d.events[0]?.absMin || 0;
                    d.endMin = d.events[d.events.length - 1]?.absMin || 0;
                }
            }
            
            // Prune old data (needs endMin to be set first)
            pruneOldData();
            
            allData = Object.values(breakerCache);
            allData.forEach(d => {
                // Limit events per breaker to prevent huge fib charts
                if (d.events.length > 500) {
                    d.events = d.events.slice(-500);
                }
                d.symbol = d.id.toUpperCase().includes('NQ') ? 'NQ' : 'ES';
            });
            
            // Extract 1M NQ Bull entry times
            entryTimes = allData
                .filter(d => d.symbol === 'NQ' && d.tf === '1m' && d.dir === 'bull')
                .map(d => d.startMin);
            
            updateStats();
            renderChart();
            
            // In live mode: always scroll to latest and show live confluence
            // In explore mode: only scroll on first load
            if (isLive || isFirstLoad) {
                setTimeout(() => {
                    const container = document.getElementById('scroll-container');
                    container.scrollLeft = container.scrollWidth;
                    updateViewportIndicator();
                    // Only show live confluence if nothing selected
                    if (isLive && !selectedBreakerId && !selectedEntryMin) {
                        showLiveConfluence();
                    }
                }, 50);
                isFirstLoad = false;
            }
        }
        
        // ===== STATS =====
        function updateStats() {
            // Calculate overall stats (NQ Bull 1M only - the primary trading signal)
            const primary = { success: 0, fail: 0 };
            
            // Calculate stats per tf/symbol/direction
            laneStats = {};
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    ['bull', 'bear'].forEach(dir => {
                        laneStats[`${tf}-${symbol}-${dir}`] = { success: 0, fail: 0 };
                    });
                });
            });
            
            allData.forEach(d => {
                const status = d.status.toLowerCase();
                const tf = d.tf.replace('hr', 'h');
                const key = `${tf}-${d.symbol}-${d.dir}`;
                
                // Primary stats: NQ Bull 1M only
                if (tf === '1m' && d.symbol === 'NQ' && d.dir === 'bull') {
                    if (status === 'success') primary.success++;
                    else if (status === 'fail') primary.fail++;
                }
                
                // Per-lane stats
                if (laneStats[key]) {
                    if (status === 'success') laneStats[key].success++;
                    else if (status === 'fail') laneStats[key].fail++;
                }
            });
            
            const completed = primary.success + primary.fail;
            const winRate = completed > 0 ? Math.round(primary.success / completed * 100) : 0;
            
            document.getElementById('stat-success').textContent = primary.success;
            document.getElementById('stat-fail').textContent = primary.fail;
            document.getElementById('stat-winrate').textContent = winRate + '%';
        }
        
        function getLaneStats(tf, symbol, dir) {
            const key = `${tf}-${symbol}-${dir}`;
            const stats = laneStats[key] || { success: 0, fail: 0 };
            const total = stats.success + stats.fail;
            const pct = total > 0 ? Math.round(stats.success / total * 100) : 0;
            return { wins: stats.success, losses: stats.fail, total, pct };
        }
        
        // ===== RENDERING =====
        function renderChart() {
            // Clean up previous event listeners
            if (chartAbortController) {
                chartAbortController.abort();
                chartAbortController = null;
            }
            chartAbortController = new AbortController();
            const signal = chartAbortController.signal;
            
            const leftPanel = document.getElementById('left-panel');
            const chartInner = document.getElementById('chart-inner');
            const timeHeader = document.getElementById('time-header');
            
            leftPanel.innerHTML = '';
            chartInner.innerHTML = '';
            timeHeader.innerHTML = '';
            
            // Clear cached element arrays
            renderedBars = [];
            renderedLaneLabels = [];
            
            // Preserve selections across re-renders (both explore and live mode)
            const preservedEntryMin = selectedEntryMin;
            const preservedBreakerId = selectedBreakerId;
            
            selectedEntryMin = null;
            selectedBreakerId = null;
            
            // Calculate chart width based on data, add padding for future fade effect
            const chartWidth = (windowEndMin - windowStartMin) * PIXELS_PER_MINUTE + (PIXELS_PER_MINUTE * 2);
            
            chartInner.style.width = chartWidth + 'px';
            timeHeader.style.width = chartWidth + 'px';
            
            // Time header ticks - snap to 5-minute boundaries
            const tickInterval = 5;
            const firstTick = Math.ceil(windowStartMin / tickInterval) * tickInterval;
            for (let m = firstTick; m <= windowEndMin; m += tickInterval) {
                const x = (m - windowStartMin) * PIXELS_PER_MINUTE;
                const tick = document.createElement('div');
                tick.className = 'time-tick-label';
                tick.style.left = x + 'px';
                tick.textContent = minToTime(m);
                timeHeader.appendChild(tick);
            }
            
            // Filter data for window
            let windowData = allData.filter(d => {
                if (d.endMin < windowStartMin || d.startMin > windowEndMin) return false;
                if (d.symbol === 'NQ' && !filters.nq) return false;
                if (d.symbol === 'ES' && !filters.es) return false;
                if (d.dir === 'bull' && !filters.bull) return false;
                if (d.dir === 'bear' && !filters.bear) return false;
                return true;
            });
            
            // Limit total bars to prevent browser crash (prioritize recent)
            const MAX_BARS = 500;
            if (windowData.length > MAX_BARS) {
                windowData.sort((a, b) => b.endMin - a.endMin);
                windowData = windowData.slice(0, MAX_BARS);
            }
            
            // Group by TF ‚Üí Symbol
            const grouped = {};
            TF_ORDER.forEach(tf => {
                grouped[tf] = { NQ: [], ES: [] };
            });
            
            windowData.forEach(d => {
                const tf = d.tf.replace('hr', 'h');
                if (grouped[tf] && grouped[tf][d.symbol]) {
                    grouped[tf][d.symbol].push(d);
                }
            });
            
            // Determine which symbols are visible
            const visibleSymbols = SYMBOLS.filter(s => filters[s.toLowerCase()]);
            
            let totalHeight = 0;
            
            // Render TF sections
            TF_ORDER.forEach((tf, tfIndex) => {
                // TF divider spacer for left panel (matches chart divider height)
                const tfSpacer = document.createElement('div');
                tfSpacer.className = 'tf-spacer';
                tfSpacer.dataset.tf = tf;
                leftPanel.appendChild(tfSpacer);
                
                // TF divider - chart
                const tfHeaderChart = document.createElement('div');
                tfHeaderChart.className = 'tf-header-chart';
                // Width set via CSS to be viewport-based
                tfHeaderChart.dataset.tf = tf;
                chartInner.appendChild(tfHeaderChart);
                
                // TF_HEADER_HEIGHT for divider
                totalHeight += TF_HEADER_HEIGHT;
                
                // Calculate lane heights for all symbols in this TF first
                const laneHeights = {};
                let tfGroupHeight = 0;
                
                visibleSymbols.forEach((symbol, idx) => {
                    const breakers = grouped[tf][symbol];
                    const stackedBreakers = assignStackPositions(breakers);
                    const maxStack = stackedBreakers.length > 0 
                        ? Math.max(...stackedBreakers.map(b => b.stackIdx)) + 1 
                        : 1;
                    
                    // Calculate height needed for breaker stacking
                    const breakerStackHeight = LANE_PADDING * 2 + maxStack * (BAR_HEIGHT + BAR_GAP) - BAR_GAP;
                    
                    // Use the larger of left panel minimum or breaker stack needs
                    const laneHeight = Math.max(LEFT_PANEL_MIN_HEIGHT, breakerStackHeight);
                    
                    laneHeights[symbol] = laneHeight;
                    tfGroupHeight += laneHeight;
                });
                
                // Create TF group container for left panel
                const tfGroup = document.createElement('div');
                tfGroup.className = 'tf-group';
                // Height determined by children via flexbox
                tfGroup.dataset.tf = tf;
                
                // TF accent bar spanning all symbols
                const tfLabel = tf.toUpperCase();
                const tfAccent = document.createElement('div');
                tfAccent.className = 'tf-group-accent';
                tfAccent.dataset.tf = tf;
                tfAccent.textContent = tfLabel;
                tfGroup.appendChild(tfAccent);
                
                // Lanes container
                const tfLanes = document.createElement('div');
                tfLanes.className = 'tf-group-lanes';
                
                // Symbol lanes within this TF
                visibleSymbols.forEach((symbol, symbolIdx) => {
                    const breakers = grouped[tf][symbol];
                    const stackedBreakers = assignStackPositions(breakers);
                    const laneHeight = laneHeights[symbol];
                    
                    // Get stats for this lane
                    const bullStats = getLaneStats(tf, symbol, 'bull');
                    const bearStats = getLaneStats(tf, symbol, 'bear');
                    
                    // Lane row
                    const laneRow = document.createElement('div');
                    laneRow.className = 'lane-row';
                    // Only set explicit height if breakers need more than minimum
                    if (laneHeight > LEFT_PANEL_MIN_HEIGHT) {
                        laneRow.style.height = laneHeight + 'px';
                    }
                    laneRow.dataset.tf = tf;
                    laneRow.dataset.symbol = symbol;
                    
                    // Horizontal layout: symbol left, stats right
                    laneRow.innerHTML = `
                        <span class="symbol-badge ${symbol.toLowerCase()}">${symbol}</span>
                        <div class="lane-stats">
                            <div class="lane-stat-row">
                                <span class="lane-stat-dir bull"></span>
                                <span class="lane-stat-counts">${bullStats.wins}/${bullStats.losses}</span>
                                <div class="lane-stat-bar">
                                    <div class="lane-stat-fill bull" style="width: ${bullStats.pct}%"></div>
                                </div>
                                <span class="lane-stat-pct ${bullStats.total > 0 ? 'bull' : 'neutral'}">${bullStats.total > 0 ? bullStats.pct + '%' : '-'}</span>
                            </div>
                            <div class="lane-stat-row">
                                <span class="lane-stat-dir bear"></span>
                                <span class="lane-stat-counts">${bearStats.wins}/${bearStats.losses}</span>
                                <div class="lane-stat-bar">
                                    <div class="lane-stat-fill bear" style="width: ${bearStats.pct}%"></div>
                                </div>
                                <span class="lane-stat-pct ${bearStats.total > 0 ? 'bear' : 'neutral'}">${bearStats.total > 0 ? bearStats.pct + '%' : '-'}</span>
                            </div>
                        </div>
                    `;
                    
                    tfLanes.appendChild(laneRow);
                    
                    // Cache lane row for highlighting
                    renderedLaneLabels.push({ el: laneRow, tf: tf, symbol: symbol });
                    
                    // Swimlane
                    const swimlane = document.createElement('div');
                    swimlane.className = 'swimlane';
                    swimlane.style.width = chartWidth + 'px';
                    // Only set explicit height if breakers need more than minimum
                    if (laneHeight > LEFT_PANEL_MIN_HEIGHT) {
                        swimlane.style.height = laneHeight + 'px';
                    }
                    swimlane.dataset.symbol = symbol;
                    swimlane.dataset.tf = tf;
                    
                    // Render breaker bars with stacking
                    stackedBreakers.forEach(b => {
                        const bar = createBreakerBar(b, laneHeight);
                        swimlane.appendChild(bar);
                        // Cache bar with its time data for fast highlight
                        renderedBars.push({
                            el: bar,
                            startMin: b.startMin,
                            endMin: b.endMin,
                            tf: tf,
                            symbol: symbol
                        });
                    });
                    
                    chartInner.appendChild(swimlane);
                    totalHeight += laneHeight;
                });
                
                tfGroup.appendChild(tfLanes);
                leftPanel.appendChild(tfGroup);
            });
            
            // Render entry lines spanning full chart height
            // Subtract a few pixels for perfect alignment
            totalHeight -= 3;
            
            const windowEntries = entryTimes
                .filter(t => t >= windowStartMin && t <= windowEndMin)
                .slice(-100); // Limit entry lines
            
            windowEntries.forEach(entryMin => {
                const x = (entryMin - windowStartMin) * PIXELS_PER_MINUTE;
                
                // Entry line in chart
                const entryLine = document.createElement('div');
                entryLine.className = 'entry-line';
                entryLine.style.left = x + 'px';
                entryLine.style.height = totalHeight + 'px';
                entryLine.dataset.entryMin = entryMin;
                entryLine.title = 'Entry: ' + minToTime(entryMin);
                entryLine.onclick = () => selectEntry(entryMin);
                chartInner.appendChild(entryLine);
            });
            
            // Add cursor line
            const cursorLine = document.createElement('div');
            cursorLine.className = 'cursor-line';
            cursorLine.id = 'cursor-line';
            cursorLine.style.height = totalHeight + 'px';
            chartInner.appendChild(cursorLine);
            
            // Set chart inner height so absolute positioned elements span correctly
            chartInner.style.height = totalHeight + 'px';
            
            // Add cursor time tooltip to body (so it's not clipped)
            let cursorTime = document.getElementById('cursor-time');
            if (!cursorTime) {
                cursorTime = document.createElement('div');
                cursorTime.className = 'cursor-time';
                cursorTime.id = 'cursor-time';
                document.body.appendChild(cursorTime);
            }
            
            // Cursor line event handlers on scroll container
            const scrollContainer = document.getElementById('scroll-container');
            let lastClientX = null;
            let lastCursorMin = null;
            let cursorUpdatePending = false;
            
            function updateCursorPosition(clientX, isScroll = false) {
                const scrollRect = scrollContainer.getBoundingClientRect();
                const leftPanelWidth = 195; // matches .left-panel width
                
                // Check if mouse is actually over the chart area (not left panel)
                const mouseOverChart = clientX > scrollRect.left + leftPanelWidth;
                
                const x = clientX - scrollRect.left - leftPanelWidth + scrollContainer.scrollLeft;
                if (mouseOverChart && x >= 0 && x <= chartWidth) {
                    cursorLine.style.left = x + 'px';
                    cursorLine.classList.add('visible');
                    
                    // Calculate cursor time
                    const cursorMin = Math.round(windowStartMin + x / PIXELS_PER_MINUTE);
                    
                    // Always update tooltip position
                    cursorTime.textContent = minToTime(cursorMin);
                    cursorTime.style.display = 'block';
                    cursorTime.style.left = (clientX - 30) + 'px';
                    cursorTime.style.top = (scrollRect.top - 30) + 'px';
                    
                    // Only update panel and highlights if cursor minute changed
                    // Skip heavy operations during scroll - only update on mousemove
                    if (cursorMin !== lastCursorMin && !isScroll) {
                        lastCursorMin = cursorMin;
                        
                        // Show confluence at cursor position in right panel (only if nothing selected)
                        if (!selectedBreakerId && !selectedEntryMin) {
                            showCursorConfluence(cursorMin);
                        }
                        
                        // Highlight bars at cursor (yellow)
                        highlightCursorActive(cursorMin);
                    }
                } else {
                    cursorLine.classList.remove('visible');
                    cursorTime.style.display = 'none';
                    
                    // Clear cursor highlights when leaving chart area
                    if (!isScroll) {
                        clearCursorHighlight();
                    }
                }
            }
            
            scrollContainer.addEventListener('mousemove', (e) => {
                lastClientX = e.clientX;
                updateCursorPosition(e.clientX, false);
            }, { signal });
            
            scrollContainer.addEventListener('scroll', () => {
                if (lastClientX !== null && !cursorUpdatePending) {
                    cursorUpdatePending = true;
                    requestAnimationFrame(() => {
                        updateCursorPosition(lastClientX, true);
                        cursorUpdatePending = false;
                    });
                }
            }, { signal });
            
            scrollContainer.addEventListener('mouseleave', () => {
                lastClientX = null;
                cursorLine.classList.remove('visible');
                cursorTime.style.display = 'none';
                
                // Clear cursor highlights
                clearCursorHighlight();
                
                // Restore appropriate panel state (selection takes priority over live mode)
                if (selectedBreakerId) {
                    showBreakerDetail(selectedBreakerId);
                } else if (selectedEntryMin) {
                    showEntryContext(selectedEntryMin);
                } else if (isLive) {
                    showLiveConfluence();
                } else {
                    showEmptyPanel();
                }
            }, { signal });
            
            // Click on chart to select time (but not on breakers or entry lines)
            chartInner.addEventListener('click', (e) => {
                // Only handle clicks directly on chart or swimlanes
                if (e.target.classList.contains('breaker-bar') || 
                    e.target.classList.contains('entry-line') ||
                    e.target.closest('.breaker-bar') ||
                    e.target.closest('.entry-line')) {
                    return;
                }
                
                const rect = chartInner.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const clickedMin = Math.round(windowStartMin + x / PIXELS_PER_MINUTE);
                selectTimeContext(clickedMin);
            }, { signal });
            
            // Update scroll listener
            const container = document.getElementById('scroll-container');
            container.removeEventListener('scroll', onScroll);
            container.addEventListener('scroll', onScroll, { signal });
            
            // Setup viewport drag handlers
            setupViewportHandlers();
            
            // Restore selections (both explore and live mode)
            if (preservedBreakerId) {
                selectedBreakerId = preservedBreakerId;
                document.querySelectorAll(`.breaker-bar[data-breaker-id="${preservedBreakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                showBreakerDetail(preservedBreakerId);
            } else if (preservedEntryMin) {
                selectedEntryMin = preservedEntryMin;
                highlightActiveAtEntry(preservedEntryMin);
                showEntryContext(preservedEntryMin);
                // Highlight entry line and markers if they exist
                document.querySelectorAll('.entry-line').forEach(el => {
                    if (parseInt(el.dataset.entryMin) === preservedEntryMin) {
                        el.classList.add('selected');
                    }
                });
            } else if (isLive) {
                // In live mode, show current confluence
                showLiveConfluence();
            } else {
                // In explore mode with no selection, show empty panel
                clearEntryHighlight();
                showEmptyPanel();
            }
            
            // Update viewport indicator after DOM is ready
            setTimeout(updateViewportIndicator, 50);
        }
        
        function createBreakerBar(b, laneHeight) {
            const startX = Math.max(0, (b.startMin - windowStartMin) * PIXELS_PER_MINUTE);
            const endX = (b.endMin - windowStartMin) * PIXELS_PER_MINUTE;
            const barWidth = Math.max(endX - startX + PIXELS_PER_MINUTE, 6);
            
            // Calculate vertical position - top aligned with padding
            const topOffset = LANE_PADDING + b.stackIdx * (BAR_HEIGHT + BAR_GAP);
            
            const bar = document.createElement('div');
            bar.className = 'breaker-bar ' + b.symbol.toLowerCase() + ' ' + b.dir;
            
            if (b.status !== 'active') {
                bar.classList.add('completed');
            }
            
            bar.style.left = startX + 'px';
            bar.style.width = barWidth + 'px';
            bar.style.top = topOffset + 'px';
            bar.style.height = BAR_HEIGHT + 'px';
            bar.dataset.breakerId = b.id;
            bar.dataset.startMin = b.startMin;
            bar.dataset.endMin = b.endMin;
            
            // Right-side container for fib and status
            const rightGroup = document.createElement('div');
            rightGroup.className = 'bar-right-group';
            
            // Show fib on wider bars (right side, before status)
            if (barWidth > 50) {
                const fibSpan = document.createElement('span');
                fibSpan.className = 'bar-fib';
                fibSpan.textContent = b.maxFib.toFixed(1);
                rightGroup.appendChild(fibSpan);
            }
            
            // Status dot - only for completed
            if (b.status === 'success' || b.status === 'fail') {
                const dot = document.createElement('div');
                dot.className = 'status-dot ' + b.status;
                dot.textContent = b.status === 'success' ? 'S' : 'F';
                rightGroup.appendChild(dot);
            }
            
            bar.appendChild(rightGroup);
            
            // Click to show details
            bar.addEventListener('click', (e) => {
                e.stopPropagation();
                selectBreaker(b.id);
            });
            
            return bar;
        }
        
        // ===== DETAIL PANEL =====
        function showEmptyPanel() {
            document.getElementById('panel-time').textContent = '';
            document.getElementById('panel-type').textContent = 'Details';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="panel-empty">
                    <div class="panel-empty-icon">üìã</div>
                    <div class="panel-empty-text">
                        Click a breaker bar or entry line to see details
                    </div>
                </div>
            `;
        }
        
        function showCursorConfluence(cursorMin) {
            // Find all breakers active at cursor time
            const activeAtEntry = allData.filter(d => 
                d.startMin <= cursorMin && d.endMin >= cursorMin
            );
            
            // Build context for each TF/Symbol combination
            const contextRows = [];
            let nqBull = 0, nqBear = 0, esBull = 0, esBear = 0;
            
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    const breaker = activeAtEntry.find(d => 
                        d.tf.replace('hr', 'h') === tf && d.symbol === symbol
                    );
                    
                    if (breaker) {
                        // Count for alignment
                        if (symbol === 'NQ') {
                            if (breaker.dir === 'bull') nqBull++; else nqBear++;
                        } else {
                            if (breaker.dir === 'bull') esBull++; else esBear++;
                        }
                        
                        // Get fib at entry (first event)
                        const entryFib = breaker.events[0]?.fib || 1.0;
                        
                        // Get current fib (event closest to cursor time)
                        let currentFib = entryFib;
                        for (const evt of breaker.events) {
                            if (evt.absMin <= cursorMin) {
                                currentFib = evt.fib;
                            }
                        }
                        
                        // Status indicator
                        const statusIcon = breaker.status === 'success' ? 'S' : 
                                          breaker.status === 'fail' ? 'F' : '-';
                        const statusClass = breaker.status;
                        
                        contextRows.push(`
                            <div class="context-row active">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir ${breaker.dir}">${breaker.dir.toUpperCase()}</span>
                                <span class="context-fib">${entryFib.toFixed(1)} ‚Üí ${currentFib.toFixed(1)}</span>
                                <span class="context-status-icon ${statusClass}">${statusIcon}</span>
                            </div>
                        `);
                    } else {
                        contextRows.push(`
                            <div class="context-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir none">-</span>
                                <span class="context-fib">-</span>
                                <span class="context-status-icon none">-</span>
                            </div>
                        `);
                    }
                });
            });
            
            document.getElementById('panel-time').textContent = minToTime(cursorMin);
            document.getElementById('panel-type').textContent = 'Confluence';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-section-title">Active Breakers</div>
                    <div class="context-header">
                        <span>TF</span>
                        <span>Sym</span>
                        <span>Dir</span>
                        <span>Fib</span>
                        <span>St</span>
                    </div>
                    <div class="context-grid">
                        ${contextRows.join('')}
                    </div>
                </div>
                
                <div class="context-summary">
                    <div class="context-summary-row">
                        <span class="context-summary-label">NQ</span>
                        <span class="context-summary-value"><span class="arrow-bull">${nqBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${nqBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                    <div class="context-summary-row">
                        <span class="context-summary-label">ES</span>
                        <span class="context-summary-value"><span class="arrow-bull">${esBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${esBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                </div>
            `;
        }
        
        function showLiveConfluence() {
            const currentMin = dataMaxTime;
            
            // Highlight active breakers on chart and left panel (green for live)
            highlightLiveActive();
            
            // Find all breakers active at current time
            const activeAtEntry = allData.filter(d => 
                d.startMin <= currentMin && d.endMin >= currentMin
            );
            
            // Build context for each TF/Symbol combination
            const contextRows = [];
            let nqBull = 0, nqBear = 0, esBull = 0, esBear = 0;
            
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    const breaker = activeAtEntry.find(d => 
                        d.tf.replace('hr', 'h') === tf && d.symbol === symbol
                    );
                    
                    if (breaker) {
                        // Count for alignment
                        if (symbol === 'NQ') {
                            if (breaker.dir === 'bull') nqBull++; else nqBear++;
                        } else {
                            if (breaker.dir === 'bull') esBull++; else esBear++;
                        }
                        
                        // Get fib at entry (first event)
                        const entryFib = breaker.events[0]?.fib || 1.0;
                        
                        // Get current fib (latest event)
                        const currentFib = breaker.maxFib;
                        
                        // Status indicator
                        const statusIcon = breaker.status === 'success' ? 'S' : 
                                          breaker.status === 'fail' ? 'F' : '-';
                        const statusClass = breaker.status;
                        
                        contextRows.push(`
                            <div class="context-row live-active-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir ${breaker.dir}">${breaker.dir.toUpperCase()}</span>
                                <span class="context-fib">${entryFib.toFixed(1)} ‚Üí ${currentFib.toFixed(1)}</span>
                                <span class="context-status-icon ${statusClass}">${statusIcon}</span>
                            </div>
                        `);
                    } else {
                        contextRows.push(`
                            <div class="context-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir none">-</span>
                                <span class="context-fib">-</span>
                                <span class="context-status-icon none">-</span>
                            </div>
                        `);
                    }
                });
            });
            
            document.getElementById('panel-time').textContent = minToTime(currentMin);
            document.getElementById('panel-type').textContent = 'Live Confluence';
            document.getElementById('panel-type').classList.add('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-section-title">Active Breakers</div>
                    <div class="context-header">
                        <span>TF</span>
                        <span>Sym</span>
                        <span>Dir</span>
                        <span>Fib</span>
                        <span>St</span>
                    </div>
                    <div class="context-grid">
                        ${contextRows.join('')}
                    </div>
                </div>
                
                <div class="context-summary">
                    <div class="context-summary-row">
                        <span class="context-summary-label">NQ</span>
                        <span class="context-summary-value"><span class="arrow-bull">${nqBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${nqBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                    <div class="context-summary-row">
                        <span class="context-summary-label">ES</span>
                        <span class="context-summary-value"><span class="arrow-bull">${esBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${esBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                </div>
            `;
        }
        
        function showBreakerDetail(breakerId) {
            const b = allData.find(d => d.id === breakerId);
            if (!b) return;
            
            const duration = minToDuration(b.startMin, b.endMin);
            const statusClass = b.status.toLowerCase();
            const statusText = b.status.charAt(0).toUpperCase() + b.status.slice(1);
            
            // Generate fib chart
            const fibChart = generateFibChart(b);
            
            document.getElementById('panel-time').textContent = minToTime(b.startMin);
            document.getElementById('panel-type').textContent = 'Breaker Detail';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-id">${b.id}</div>
                    <div class="detail-badges">
                        <span class="detail-badge ${b.symbol.toLowerCase()}">${b.symbol}</span>
                        <span class="detail-badge ${b.dir}">${b.dir.toUpperCase()}</span>
                        <span class="detail-badge ${statusClass}">${statusText}</span>
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Fib Progression</div>
                    <div class="fib-chart-container">
                        ${fibChart}
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Metrics</div>
                    <div class="detail-row">
                        <span class="detail-label">Max Fib</span>
                        <span class="detail-value large">${b.maxFib.toFixed(2)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Timeframe</span>
                        <span class="detail-value">${TF_DISPLAY[b.tf] || b.tf.toUpperCase()}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Duration</span>
                        <span class="detail-value">${duration}</span>
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Timeline</div>
                    <div class="detail-row">
                        <span class="detail-label">Start</span>
                        <span class="detail-value">${minToDateTime(b.startMin)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">End</span>
                        <span class="detail-value">${minToDateTime(b.endMin)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Snapshots</span>
                        <span class="detail-value">${b.events.length}</span>
                    </div>
                </div>
            `;
        }
        
        function generateFibChart(breaker) {
            const events = breaker.events;
            if (events.length < 2) {
                return '<div style="color:#666;text-align:center;padding:20px;">Not enough data</div>';
            }
            
            const width = 280;
            const height = 120;
            const padding = { top: 20, right: 15, bottom: 25, left: 35 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Find min/max
            const minTime = events[0].absMin;
            const maxTime = events[events.length - 1].absMin;
            const timeRange = maxTime - minTime || 1;
            
            const maxFib = Math.max(...events.map(e => e.fib), 1);
            const fibCeil = Math.ceil(maxFib * 1.1); // Add 10% padding
            
            // Find peak point (first occurrence of max fib)
            const maxFibVal = Math.max(...events.map(e => e.fib));
            const peakIndex = events.findIndex(e => e.fib === maxFibVal);
            const peakEvent = events[peakIndex];
            
            // Downsample events if too many (keep first, last, peak, and sampled)
            let sampledEvents = events;
            let sampledPeakIndex = peakIndex;
            if (events.length > 100) {
                const step = Math.ceil(events.length / 80);
                sampledEvents = events.filter((e, i) => 
                    i === 0 || i === events.length - 1 || i === peakIndex || i % step === 0
                );
                sampledPeakIndex = sampledEvents.findIndex(e => e === events[peakIndex]);
            }
            
            // Generate points from sampled events
            const points = sampledEvents.map((e, i) => {
                const x = padding.left + ((e.absMin - minTime) / timeRange) * chartWidth;
                const y = padding.top + chartHeight - (e.fib / fibCeil) * chartHeight;
                return { x, y, fib: e.fib, time: e.absMin, isPeak: i === sampledPeakIndex };
            });
            
            // Create line path
            const linePath = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            
            // Create area path (for gradient fill)
            const areaPath = linePath + ` L ${points[points.length-1].x} ${padding.top + chartHeight} L ${points[0].x} ${padding.top + chartHeight} Z`;
            
            // Generate Y-axis labels
            const yLabels = [];
            const ySteps = 4;
            for (let i = 0; i <= ySteps; i++) {
                const val = (fibCeil / ySteps) * i;
                const y = padding.top + chartHeight - (i / ySteps) * chartHeight;
                yLabels.push(`<text class="fib-chart-value-label" x="${padding.left - 5}" y="${y + 3}" text-anchor="end">${val.toFixed(1)}</text>`);
                if (i > 0 && i < ySteps) {
                    yLabels.push(`<line class="fib-chart-grid" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}"/>`);
                }
            }
            
            // Generate time labels (start, middle, end)
            const midTime = minTime + Math.floor(timeRange / 2);
            const timeLabels = [];
            timeLabels.push(`<text class="fib-chart-label" x="${padding.left}" y="${height - 5}" text-anchor="start">${minToTime(minTime)}</text>`);
            timeLabels.push(`<text class="fib-chart-label" x="${padding.left + chartWidth/2}" y="${height - 5}" text-anchor="middle">${minToTime(midTime)}</text>`);
            timeLabels.push(`<text class="fib-chart-label" x="${width - padding.right}" y="${height - 5}" text-anchor="end">${minToTime(maxTime)}</text>`);
            
            // Find peak point coordinates
            const peakPoint = points.find(p => p.isPeak);
            
            // Generate dots (sample if too many)
            let dotPoints = points;
            if (points.length > 20) {
                const step = Math.ceil(points.length / 15);
                dotPoints = points.filter((p, i) => i === 0 || i === points.length - 1 || p.isPeak || i % step === 0);
            }
            
            const dots = dotPoints.map(p => {
                return `<circle class="${p.isPeak ? 'fib-chart-peak' : 'fib-chart-dot'}" cx="${p.x}" cy="${p.y}" r="${p.isPeak ? 4 : 3}"/>`;
            }).join('');
            
            // Peak label
            const peakLabel = peakPoint ? `
                <text class="fib-peak-label" x="${peakPoint.x}" y="${peakPoint.y - 8}" text-anchor="middle">${peakEvent.fib.toFixed(2)}</text>
            ` : '';
            
            // Store chart data for cursor interaction
            const chartId = 'fib-chart-' + Date.now();
            
            // Schedule cursor setup after DOM update
            setTimeout(() => setupFibChartCursor(chartId, points, padding, chartWidth, chartHeight, fibCeil, minTime, timeRange), 0);
            
            return `
                <svg id="${chartId}" class="fib-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                    <defs>
                        <linearGradient id="fibGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:0.4"/>
                            <stop offset="100%" style="stop-color:#60a5fa;stop-opacity:0"/>
                        </linearGradient>
                    </defs>
                    
                    <!-- Grid lines -->
                    ${yLabels.join('')}
                    
                    <!-- Axes -->
                    <line class="fib-chart-axis" x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${padding.top + chartHeight}"/>
                    <line class="fib-chart-axis" x1="${padding.left}" y1="${padding.top + chartHeight}" x2="${width - padding.right}" y2="${padding.top + chartHeight}"/>
                    
                    <!-- Area fill -->
                    <path class="fib-chart-area" d="${areaPath}"/>
                    
                    <!-- Line -->
                    <path class="fib-chart-line" d="${linePath}"/>
                    
                    <!-- Dots -->
                    ${dots}
                    
                    <!-- Peak label -->
                    ${peakLabel}
                    
                    <!-- Time labels -->
                    ${timeLabels.join('')}
                    
                    <!-- Cursor elements -->
                    <line class="fib-cursor-line" id="${chartId}-cursor-line" x1="0" y1="${padding.top}" x2="0" y2="${padding.top + chartHeight}"/>
                    <circle class="fib-cursor-dot" id="${chartId}-cursor-dot" cx="0" cy="0" r="5"/>
                    
                    <!-- Hover area -->
                    <rect x="${padding.left}" y="${padding.top}" width="${chartWidth}" height="${chartHeight}" fill="transparent" style="cursor:crosshair"/>
                </svg>
                <div class="fib-cursor-tooltip" id="${chartId}-tooltip">
                    <span class="fib-val">0.00</span>
                    <span class="time-val">00:00</span>
                </div>
            `;
        }
        
        function setupFibChartCursor(chartId, points, padding, chartWidth, chartHeight, fibCeil, minTime, timeRange) {
            const svg = document.getElementById(chartId);
            const cursorLine = document.getElementById(chartId + '-cursor-line');
            const cursorDot = document.getElementById(chartId + '-cursor-dot');
            const tooltip = document.getElementById(chartId + '-tooltip');
            
            // Guard: check if elements exist and listeners not already attached
            if (!svg || !cursorLine || !cursorDot || !tooltip) return;
            if (svg.dataset.listenersAttached) return;
            svg.dataset.listenersAttached = 'true';
            
            const container = svg.closest('.fib-chart-container');
            
            svg.addEventListener('mousemove', (e) => {
                const rect = svg.getBoundingClientRect();
                const scaleX = 280 / rect.width;
                const mouseX = (e.clientX - rect.left) * scaleX;
                
                // Check if within chart area
                if (mouseX < padding.left || mouseX > padding.left + chartWidth) {
                    cursorLine.style.opacity = '0';
                    cursorDot.style.opacity = '0';
                    tooltip.style.opacity = '0';
                    return;
                }
                
                // Find closest point
                let closest = points[0];
                let closestDist = Math.abs(points[0].x - mouseX);
                
                for (const p of points) {
                    const dist = Math.abs(p.x - mouseX);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = p;
                    }
                }
                
                // Update cursor
                cursorLine.setAttribute('x1', closest.x);
                cursorLine.setAttribute('x2', closest.x);
                cursorLine.style.opacity = '1';
                
                cursorDot.setAttribute('cx', closest.x);
                cursorDot.setAttribute('cy', closest.y);
                cursorDot.style.opacity = '1';
                
                // Update tooltip
                tooltip.querySelector('.fib-val').textContent = closest.fib.toFixed(2);
                tooltip.querySelector('.time-val').textContent = minToTime(closest.time);
                tooltip.style.opacity = '1';
                
                // Position tooltip
                const tooltipX = (closest.x / 280) * rect.width;
                const tooltipY = (closest.y / 120) * rect.height;
                
                // Flip tooltip if near right edge
                if (tooltipX > rect.width * 0.6) {
                    tooltip.style.left = (tooltipX - tooltip.offsetWidth - 10) + 'px';
                } else {
                    tooltip.style.left = (tooltipX + 10) + 'px';
                }
                tooltip.style.top = (tooltipY - 10) + 'px';
            });
            
            svg.addEventListener('mouseleave', () => {
                cursorLine.style.opacity = '0';
                cursorDot.style.opacity = '0';
                tooltip.style.opacity = '0';
            });
        }
        
        function showEntryContext(entryMin) {
            // Find all breakers active at this time
            const activeAtEntry = allData.filter(d => 
                d.startMin <= entryMin && d.endMin >= entryMin
            );
            
            // Build context for each TF/Symbol combination
            const contextRows = [];
            let nqBull = 0, nqBear = 0, esBull = 0, esBear = 0;
            
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    const breaker = activeAtEntry.find(d => 
                        d.tf.replace('hr', 'h') === tf && d.symbol === symbol
                    );
                    
                    if (breaker) {
                        // Count for alignment
                        if (symbol === 'NQ') {
                            if (breaker.dir === 'bull') nqBull++; else nqBear++;
                        } else {
                            if (breaker.dir === 'bull') esBull++; else esBear++;
                        }
                        
                        // Get fib at start
                        const startFib = breaker.events[0]?.fib || 1.0;
                        
                        // Get fib at entry time
                        let fibAtEntry = startFib;
                        for (const evt of breaker.events) {
                            if (evt.absMin <= entryMin) {
                                fibAtEntry = evt.fib;
                            }
                        }
                        
                        // Status indicator
                        const statusIcon = breaker.status === 'success' ? 'S' : 
                                          breaker.status === 'fail' ? 'F' : '-';
                        const statusClass = breaker.status;
                        
                        contextRows.push(`
                            <div class="context-row active">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir ${breaker.dir}">${breaker.dir.toUpperCase()}</span>
                                <span class="context-fib">${startFib.toFixed(1)} ‚Üí ${fibAtEntry.toFixed(1)}</span>
                                <span class="context-status-icon ${statusClass}">${statusIcon}</span>
                            </div>
                        `);
                    } else {
                        contextRows.push(`
                            <div class="context-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir none">-</span>
                                <span class="context-fib">-</span>
                                <span class="context-status-icon none">-</span>
                            </div>
                        `);
                    }
                });
            });
            
            document.getElementById('panel-time').textContent = minToTime(entryMin);
            document.getElementById('panel-type').textContent = 'Entry Confluence';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-section-title">Active Breakers</div>
                    <div class="context-header">
                        <span>TF</span>
                        <span>Sym</span>
                        <span>Dir</span>
                        <span>Fib</span>
                        <span>St</span>
                    </div>
                    <div class="context-grid">
                        ${contextRows.join('')}
                    </div>
                </div>
                
                <div class="context-summary">
                    <div class="context-summary-row">
                        <span class="context-summary-label">NQ</span>
                        <span class="context-summary-value"><span class="arrow-bull">${nqBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${nqBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                    <div class="context-summary-row">
                        <span class="context-summary-label">ES</span>
                        <span class="context-summary-value"><span class="arrow-bull">${esBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${esBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                </div>
            `;
        }
        
        // ===== SELECTION =====
        function selectBreaker(breakerId) {
            // Clear previous selection
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            clearEntryHighlight();
            selectedEntryMin = null;
            
            // Toggle selection
            if (selectedBreakerId === breakerId) {
                selectedBreakerId = null;
                showEmptyPanel();
            } else {
                selectedBreakerId = breakerId;
                
                // Highlight selected bar
                document.querySelectorAll(`.breaker-bar[data-breaker-id="${breakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                
                showBreakerDetail(breakerId);
            }
            
            // Update entry line and marker styling
            document.querySelectorAll('.entry-line').forEach(el => {
                el.classList.remove('selected');
            });
        }
        
        function selectEntry(entryMin) {
            // Clear previous selection
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            selectedBreakerId = null;
            
            // Toggle selection
            if (selectedEntryMin === entryMin) {
                selectedEntryMin = null;
                clearEntryHighlight();
                showEmptyPanel();
            } else {
                selectedEntryMin = entryMin;
                highlightActiveAtEntry(entryMin);
                showEntryContext(entryMin);
            }
            
            // Update entry line and marker styling
            document.querySelectorAll('.entry-line').forEach(el => {
                if (parseInt(el.dataset.entryMin) === selectedEntryMin) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });
        }
        
        function selectTimeContext(clickedMin) {
            // Clear previous selections
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.entry-line').forEach(el => {
                el.classList.remove('selected');
            });
            selectedBreakerId = null;
            
            // Toggle selection
            if (selectedEntryMin === clickedMin) {
                selectedEntryMin = null;
                clearEntryHighlight();
                showEmptyPanel();
            } else {
                selectedEntryMin = clickedMin;
                highlightActiveAtEntry(clickedMin);
                showEntryContext(clickedMin);
            }
        }
        
        function highlightActiveAtEntry(entryMin) {
            clearEntryHighlight();
            
            // Track which TF/symbol combinations have active breakers
            const activeLanes = new Set();
            
            // Use cached bars
            for (const bar of renderedBars) {
                if (bar.startMin <= entryMin && bar.endMin >= entryMin) {
                    bar.el.classList.add('active-at-entry');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('has-confluence');
                }
            }
        }
        
        function clearEntryHighlight() {
            for (const bar of renderedBars) {
                bar.el.classList.remove('active-at-entry');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('has-confluence');
            }
        }
        
        // Cursor highlighting (yellow) - separate from live/selected highlighting
        function highlightCursorActive(cursorMin) {
            clearCursorHighlight();
            clearLiveHighlight(); // Clear live highlight when cursor is active
            
            const activeLanes = new Set();
            
            // Use cached bars instead of querySelectorAll
            for (const bar of renderedBars) {
                if (bar.startMin <= cursorMin && bar.endMin >= cursorMin) {
                    bar.el.classList.add('cursor-active');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('cursor-confluence');
                }
            }
        }
        
        function clearCursorHighlight() {
            // Use cached bars instead of querySelectorAll
            for (const bar of renderedBars) {
                bar.el.classList.remove('cursor-active');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('cursor-confluence');
            }
        }
        
        // Live highlighting (green) - for live mode current time
        function highlightLiveActive() {
            clearLiveHighlight();
            const currentMin = dataMaxTime;
            
            const activeLanes = new Set();
            
            // Use cached bars
            for (const bar of renderedBars) {
                if (bar.startMin <= currentMin && bar.endMin >= currentMin) {
                    bar.el.classList.add('live-active');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('live-confluence');
                }
            }
        }
        
        function clearLiveHighlight() {
            for (const bar of renderedBars) {
                bar.el.classList.remove('live-active');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('live-confluence');
            }
        }
        
        // ===== VIEWPORT DRAG TO PAN =====
        let vpHandlersSetup = false;
        
        function setupViewportHandlers() {
            if (vpHandlersSetup) return;
            vpHandlersSetup = true;
            
            const track = document.getElementById('timeline-track');
            const viewport = document.getElementById('viewport-indicator');
            
            if (!track || !viewport) return;
            
            let isDragging = false;
            let hasDragged = false;
            let startX = 0;
            let startScrollLeft = 0;
            
            // Drag viewport to scroll chart
            viewport.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                hasDragged = false;
                startX = e.clientX;
                
                const container = document.getElementById('scroll-container');
                startScrollLeft = container ? container.scrollLeft : 0;
                viewport.style.cursor = 'grabbing';
            });
            
            // Click on track to jump
            track.addEventListener('click', (e) => {
                if (e.target !== track || hasDragged) {
                    hasDragged = false;
                    return;
                }
                
                if (dataMinTime === 0 || dataMaxTime === 0) return;
                
                const container = document.getElementById('scroll-container');
                const chartInner = document.getElementById('chart-inner');
                if (!container || !chartInner) return;
                
                const trackRect = track.getBoundingClientRect();
                const clickPct = (e.clientX - trackRect.left) / trackRect.width;
                const totalRange = dataMaxTime - dataMinTime;
                const clickMin = dataMinTime + clickPct * totalRange;
                
                // Calculate scroll position to center on clicked time
                const chartWidth = chartInner.offsetWidth;
                const viewportWidth = container.clientWidth;
                const windowRange = windowEndMin - windowStartMin;
                
                // Map clicked time to scroll position
                const timeInWindow = clickMin - windowStartMin;
                const scrollTarget = (timeInWindow / windowRange) * chartWidth - viewportWidth / 2;
                
                container.scrollLeft = Math.max(0, Math.min(scrollTarget, chartWidth - viewportWidth));
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                if (dataMinTime === 0 || dataMaxTime === 0) return;
                
                hasDragged = true;
                
                const container = document.getElementById('scroll-container');
                const chartInner = document.getElementById('chart-inner');
                const trackEl = document.getElementById('timeline-track');
                if (!container || !chartInner || !trackEl) return;
                
                const trackRect = trackEl.getBoundingClientRect();
                const trackWidth = trackRect.width;
                const chartWidth = chartInner.offsetWidth;
                const viewportWidth = container.clientWidth;
                const maxScroll = chartWidth - viewportWidth;
                
                if (maxScroll <= 0) return;
                
                const totalRange = dataMaxTime - dataMinTime;
                const windowRange = windowEndMin - windowStartMin;
                
                // Map drag distance on track to scroll distance
                const dx = e.clientX - startX;
                const dPctOfTotal = dx / trackWidth;
                const dTime = dPctOfTotal * totalRange;
                const dScroll = (dTime / windowRange) * chartWidth;
                
                container.scrollLeft = Math.max(0, Math.min(startScrollLeft + dScroll, maxScroll));
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    viewport.style.cursor = 'grab';
                }
            });
        }
        
        // ===== SCROLL =====
        let scrollTimeout;
        
        function onScroll() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(updateViewportFromScroll, 30);
            
            const container = document.getElementById('scroll-container');
            const header = document.getElementById('time-header');
            header.style.transform = `translateX(${-container.scrollLeft}px)`;
        }
        
        function updateViewportFromScroll() {
            if (dataMinTime === 0 || dataMaxTime === 0) return;
            
            const container = document.getElementById('scroll-container');
            const chartInner = document.getElementById('chart-inner');
            if (!container || !chartInner) return;
            
            const chartWidth = chartInner.offsetWidth;
            const viewportWidth = container.clientWidth;
            const scrollLeft = container.scrollLeft;
            
            if (chartWidth <= 0) return;
            
            const totalDataRange = dataMaxTime - dataMinTime;
            const windowRange = windowEndMin - windowStartMin;
            
            // Calculate visible time range based on scroll
            const scrollPct = chartWidth > viewportWidth ? scrollLeft / (chartWidth - viewportWidth) : 0;
            const visibleTimeWidth = (viewportWidth / chartWidth) * windowRange;
            const visibleStartMin = windowStartMin + scrollPct * (windowRange - visibleTimeWidth);
            const visibleEndMin = visibleStartMin + visibleTimeWidth;
            
            // Map to viewport bar position
            const startPct = Math.max(0, ((visibleStartMin - dataMinTime) / totalDataRange) * 100);
            const endPct = Math.min(100, ((visibleEndMin - dataMinTime) / totalDataRange) * 100);
            const widthPct = Math.max(2, endPct - startPct);
            
            const vpEl = document.getElementById('viewport-indicator');
            if (vpEl) {
                vpEl.style.left = startPct + '%';
                vpEl.style.width = widthPct + '%';
            }
        }
        
        function updateViewportIndicator() {
            // Update time labels
            if (dataMinTime > 0 && dataMaxTime > 0) {
                document.getElementById('data-start').textContent = minToDateTime(dataMinTime);
            }
            
            // Update viewport bar position based on current scroll
            updateViewportFromScroll();
        }
        
        // ===== AUTO REFRESH =====
        function setRefreshInterval() {
            if (refreshTimer) clearInterval(refreshTimer);
            if (countdownTimer) clearInterval(countdownTimer);
            
            const interval = parseInt(document.getElementById('refresh-interval').value);
            const countdownEl = document.getElementById('countdown');
            
            if (interval === 0) {
                countdownEl.textContent = '';
                return;
            }
            
            countdownSecs = interval;
            countdownEl.textContent = interval + 's';
            
            countdownTimer = setInterval(() => {
                countdownSecs--;
                if (countdownSecs <= 0) countdownSecs = interval;
                countdownEl.textContent = countdownSecs + 's';
            }, 1000);
            
            refreshTimer = setInterval(() => {
                loadData();
                countdownSecs = interval;
            }, interval * 1000);
        }
        
        // ===== INIT =====
        window.onload = function() {
            // Start in Live mode (buttons already set in HTML)
            isLive = true;
            loadData();
            setRefreshInterval();
            
            // Update viewport indicator on resize
            window.addEventListener('resize', updateViewportIndicator);
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (selectedEntryMin !== null) {
                        selectEntry(selectedEntryMin);
                    } else if (selectedBreakerId !== null) {
                        selectBreaker(selectedBreakerId);
                    }
                }
            });
        };
    </script>
</body>
</html>
