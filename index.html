<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SigXFlow</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f10;
            color: #e0e0e0;
            font-size: 13px;
        }
        
        /* ===== HEADER ===== */
        .header {
            background: linear-gradient(180deg, #1e1e20 0%, #1a1a1c 100%);
            border-bottom: 1px solid #2a2a2e;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .logo {
            font-size: 16px;
            font-weight: 600;
            color: #60a5fa;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .logo-icon {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            padding: 5px 7px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .logo-icon::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 7px solid #4ade80;
        }
        
        .logo-icon::after {
            content: '';
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 7px solid #f87171;
        }
        
        /* Stats */
        .stats-row {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        .stat-compact {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            padding: 6px 10px;
            background: linear-gradient(135deg, #1a1a1c 0%, #1e1e20 100%);
            border: 1px solid #2a2a2e;
            border-radius: 6px;
        }
        
        .stat-compact span {
            margin-right: 3px;
            font-size: 14px;
        }
        
        .stat-compact.success { 
            color: #4ade80; 
            border-color: rgba(74, 222, 128, 0.2);
        }
        .stat-compact.success span {
            text-shadow: 0 0 8px rgba(74, 222, 128, 0.4);
        }
        .stat-compact.fail { 
            color: #f87171; 
            border-color: rgba(248, 113, 113, 0.2);
        }
        .stat-compact.fail span {
            text-shadow: 0 0 8px rgba(248, 113, 113, 0.4);
        }
        .stat-compact.win { 
            color: #fbbf24; 
            border-color: rgba(251, 191, 36, 0.2);
        }
        .stat-compact.win span {
            text-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
        }
        
        .stat {
            padding: 8px 16px;
            background: #1f1f22;
            border: 1px solid #2a2a2e;
            border-radius: 6px;
            text-align: center;
            min-width: 70px;
        }
        
        .stat-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 18px;
            font-weight: 600;
        }
        
        .stat-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .stat.active .stat-value { color: #60a5fa; }
        .stat.success .stat-value { color: #22c55e; }
        .stat.fail .stat-value { color: #ef4444; }
        .stat.win .stat-value { color: #fbbf24; }
        
        /* Navigation */
        .nav-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .btn {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 500;
            padding: 8px 14px;
            border-radius: 6px;
            border: 1px solid #3a3a3e;
            background: #252528;
            color: #bbb;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .btn:hover {
            background: #303035;
            border-color: #4a4a4e;
        }
        
        /* Primary action - subtle gold theme */
        .btn.primary {
            background: linear-gradient(135deg, #252528 0%, #2a2a2e 100%);
            border: 1px solid rgba(251, 191, 36, 0.4);
            color: #fbbf24;
            font-weight: 600;
        }
        
        .btn.primary:hover {
            background: linear-gradient(135deg, #2a2a2e 0%, #333 100%);
            border-color: rgba(251, 191, 36, 0.7);
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.2);
        }
        
        /* Secondary action - muted style */
        .btn.secondary {
            background: linear-gradient(135deg, #1e1e20 0%, #252528 100%);
            border: 1px solid #333;
            color: #888;
            font-weight: 500;
        }
        
        .btn.secondary:hover {
            border-color: #444;
            color: #aaa;
            background: linear-gradient(135deg, #252528 0%, #2a2a2e 100%);
        }
        
        .btn.live {
            background: #dc2626;
            border-color: #dc2626;
            color: #fff;
        }
        
        .btn.inactive {
            background: #1a1a1c;
            border-color: #2a2a2e;
            color: #555;
        }
        
        .btn.explore-active {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #888;
            color: #fff;
        }
        
        /* Styled selects - cohesive dark theme */
        .select-styled {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #333;
            background: linear-gradient(135deg, #1a1a1c 0%, #222 100%);
            color: #888;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .select-styled:hover {
            border-color: #444;
            color: #aaa;
        }
        
        .select-styled:focus {
            outline: none;
            border-color: rgba(251, 191, 36, 0.5);
        }
        
        .divider {
            width: 1px;
            height: 24px;
            background: linear-gradient(180deg, transparent 0%, #3a3a3e 50%, transparent 100%);
            margin: 0 4px;
        }
        
        /* Settings group - load, refresh, latest */
        .settings-group {
            display: flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, #1a1a1c 0%, #1e1e20 100%);
            padding: 4px 6px;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
        }
        
        .settings-group .select-styled {
            border: none;
            background: transparent;
            padding: 6px 8px;
        }
        
        .settings-group .btn {
            padding: 6px 12px;
        }
        
        .settings-group .countdown {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #555;
            min-width: 24px;
            text-align: center;
        }
        
        /* ===== TOOLBAR ===== */
        .toolbar {
            background: linear-gradient(180deg, #1a1a1c 0%, #161618 100%);
            border-bottom: 1px solid #252528;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .filter-group {
            display: flex;
            gap: 4px;
            background: linear-gradient(135deg, #1e1e20 0%, #222 100%);
            padding: 3px;
            border-radius: 6px;
            border: 1px solid #2a2a2e;
        }
        
        .filter-btn {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            padding: 5px 10px;
            border-radius: 4px;
            border: none;
            background: transparent;
            color: #666;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .filter-btn:hover {
            color: #999;
        }
        
        .filter-btn.active {
            background: #333;
            color: #ddd;
        }
        
        .filter-btn.nq.active { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .filter-btn.es.active { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        .filter-btn.bull.active { color: #22c55e; background: rgba(22, 163, 74, 0.2); }
        .filter-btn.bear.active { color: #f87171; background: rgba(220, 38, 38, 0.2); }
        
        .arrow-up, .arrow-down {
            display: inline-block;
            width: 0;
            height: 0;
            margin-right: 4px;
            vertical-align: middle;
        }
        
        .arrow-up {
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid currentColor;
        }
        
        .arrow-down {
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid currentColor;
        }
        
        .arrow-up-sm, .arrow-down-sm {
            display: inline-block;
            width: 0;
            height: 0;
            margin-left: 2px;
            vertical-align: middle;
        }
        
        .arrow-up-sm {
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-bottom: 5px solid currentColor;
        }
        
        .arrow-down-sm {
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-top: 5px solid currentColor;
        }
        
        .toolbar-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Breaker count badge - prominent display */
        .status-msg {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
            padding: 2px 8px;
            border-radius: 4px;
            transition: opacity 0.3s;
        }
        
        .status-msg.success {
            color: #4ade80;
        }
        
        .status-msg.error {
            color: #f87171;
        }
        
        /* ===== TIMELINE BAR ===== */
        .timeline-track {
            height: 6px;
            background: #252528;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            margin-bottom: 4px;
        }
        
        .timeline-viewport {
            position: absolute;
            height: 100%;
            background: #3b82f6;
            border-radius: 3px;
            cursor: grab;
            transition: background 0.15s;
        }
        
        .timeline-viewport:hover {
            background: #60a5fa;
        }
        
        .timeline-viewport:active {
            cursor: grabbing;
            background: #93c5fd;
        }
        
        /* ===== MAIN WRAPPER ===== */
        .main-wrapper {
            display: flex;
            height: calc(100vh - 130px);
            margin: 10px;
            gap: 10px;
        }
        
        /* ===== CHART AREA ===== */
        .chart-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #131315;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
            overflow: hidden;
            min-width: 0;
        }
        
        /* Fixed Header Row */
        .header-row {
            display: flex;
            flex-shrink: 0;
            background: #1a1a1c;
            border-bottom: 1px solid #2a2a2e;
        }
        
        .left-header {
            width: 195px;
            min-width: 195px;
            height: 48px;
            padding: 0 12px;
            display: flex;
            align-items: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: #888;
            box-sizing: border-box;
        }
        
        .time-header-wrapper {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 6px 10px 0 10px;
        }
        
        .time-header {
            height: 30px;
            position: relative;
            white-space: nowrap;
        }
        
        /* Unified Scroll Container */
        .scroll-container {
            flex-grow: 1;
            overflow: auto;
        }
        
        .scroll-inner {
            display: flex;
            min-width: fit-content;
        }
        
        /* Left Panel - labels */
        .left-panel {
            width: 195px;
            min-width: 195px;
            background: #151517;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 30;
            overflow: hidden;
        }
        
        /* TF section header */
        .tf-header {
            height: 4px;
            margin-top: 8px;
            position: sticky;
            top: 0;
            z-index: 5;
        }
        
        .tf-header.tf-4h { background: linear-gradient(90deg, #f87171 0%, transparent 100%); }
        .tf-header.tf-1h { background: linear-gradient(90deg, #fbbf24 0%, transparent 100%); }
        .tf-header.tf-15m { background: linear-gradient(90deg, #4ade80 0%, transparent 100%); }
        .tf-header.tf-5m { background: linear-gradient(90deg, #60a5fa 0%, transparent 100%); }
        .tf-header.tf-1m { background: linear-gradient(90deg, #c084fc 0%, transparent 100%); }
        
        .tf-header-chart {
            height: 2px;
            display: block;
            position: sticky;
            left: 0;
            z-index: 5;
            width: 100vw;
            max-width: calc(100vw - 195px);
            background-size: 75vw 100%; /* Gradient spans 75% of viewport */
            background-repeat: no-repeat;
        }
        
        .tf-spacer {
            height: 2px;
        }
        
        /* Left panel spacer - full gradient across the panel */
        .tf-spacer[data-tf="1m"] { background: linear-gradient(90deg, #c084fc 0%, rgba(192, 132, 252, 0.5) 100%); }
        .tf-spacer[data-tf="5m"] { background: linear-gradient(90deg, #60a5fa 0%, rgba(96, 165, 250, 0.5) 100%); }
        .tf-spacer[data-tf="15m"] { background: linear-gradient(90deg, #4ade80 0%, rgba(74, 222, 128, 0.5) 100%); }
        .tf-spacer[data-tf="1h"] { background: linear-gradient(90deg, #fbbf24 0%, rgba(251, 191, 36, 0.5) 100%); }
        .tf-spacer[data-tf="4h"] { background: linear-gradient(90deg, #f87171 0%, rgba(248, 113, 113, 0.5) 100%); }
        
        /* TF background tints for chart header - gradient uses background-size */
        .tf-header-chart[data-tf="1m"] { background-image: linear-gradient(90deg, rgba(192, 132, 252, 0.5) 0%, rgba(192, 132, 252, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="5m"] { background-image: linear-gradient(90deg, rgba(96, 165, 250, 0.5) 0%, rgba(96, 165, 250, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="15m"] { background-image: linear-gradient(90deg, rgba(74, 222, 128, 0.5) 0%, rgba(74, 222, 128, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="1h"] { background-image: linear-gradient(90deg, rgba(251, 191, 36, 0.5) 0%, rgba(251, 191, 36, 0.2) 50%, transparent 100%); }
        .tf-header-chart[data-tf="4h"] { background-image: linear-gradient(90deg, rgba(248, 113, 113, 0.5) 0%, rgba(248, 113, 113, 0.2) 50%, transparent 100%); }
        
        /* Symbol Lane rows */
        .lane-label {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            transition: all 0.2s ease;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        /* TF Group container */
        .tf-group {
            display: flex;
            flex-direction: row;
            align-items: stretch;
        }
        
        .tf-group-accent {
            width: 30px;
            min-width: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        .tf-group-accent[data-tf="1m"] { background: #c084fc; color: #1a1a1c; }
        .tf-group-accent[data-tf="5m"] { background: #60a5fa; color: #1a1a1c; }
        .tf-group-accent[data-tf="15m"] { background: #4ade80; color: #1a1a1c; }
        .tf-group-accent[data-tf="1h"] { background: #fbbf24; color: #1a1a1c; }
        .tf-group-accent[data-tf="4h"] { background: #f87171; color: #1a1a1c; }
        
        .tf-group-lanes {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .lane-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            gap: 8px;
            box-sizing: border-box;
            min-height: 68px;
            overflow: hidden;
        }
        
        .lane-row[data-symbol="ES"] {
            box-shadow: inset 0 0 0 1000px rgba(0,0,0,0.1);
        }
        
        .lane-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }
        
        .lane-stat-row {
            display: flex;
            align-items: center;
            gap: 4px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
        }
        
        .lane-stat-dir {
            width: 10px;
            font-size: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .lane-stat-dir.bull::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid #22c55e;
        }
        
        .lane-stat-dir.bear::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid #ef4444;
        }
        
        .lane-stat-counts {
            color: #888;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .lane-stat-bar {
            flex: 1;
            min-width: 20px;
            height: 6px;
            background: #252528;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .lane-stat-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .lane-stat-fill.bull {
            background: linear-gradient(90deg, #22c55e, #4ade80);
        }
        
        .lane-stat-fill.bear {
            background: linear-gradient(90deg, #ef4444, #f87171);
        }
        
        .lane-stat-pct {
            text-align: right;
            font-weight: 600;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .lane-stat-pct.bull { color: #4ade80; }
        .lane-stat-pct.bear { color: #f87171; }
        .lane-stat-pct.neutral { color: #555; }
        
        .lane-row.has-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-row.has-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Timeframe background tints for left panel */
        .tf-group[data-tf="1m"] .tf-group-lanes { background: rgba(192, 132, 252, 0.03); }
        .tf-group[data-tf="5m"] .tf-group-lanes { background: rgba(96, 165, 250, 0.03); }
        .tf-group[data-tf="15m"] .tf-group-lanes { background: rgba(74, 222, 128, 0.03); }
        .tf-group[data-tf="1h"] .tf-group-lanes { background: rgba(251, 191, 36, 0.03); }
        .tf-group[data-tf="4h"] .tf-group-lanes { background: rgba(248, 113, 113, 0.03); }
        
        .symbol-badge {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 4px;
            min-width: 28px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .symbol-badge.nq { background: rgba(37, 99, 235, 0.25); color: #60a5fa; border: 1px solid rgba(37, 99, 235, 0.4); }
        .symbol-badge.es { background: rgba(6, 182, 212, 0.25); color: #22d3ee; border: 1px solid rgba(6, 182, 212, 0.4); }
        
        /* Right Panel - chart */
        .right-panel {
            flex-grow: 1;
            position: relative;
        }
        
        .time-tick-label {
            position: absolute;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #555;
            top: 50%;
            transform: translateY(-50%);
            white-space: nowrap;
        }
        
        /* Date separator - vertical line marking day boundaries */
        .date-separator {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, #60a5fa 0%, rgba(96, 165, 250, 0.3) 100%);
            z-index: 5;
        }
        
        .date-separator-label {
            position: absolute;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: #60a5fa;
            background: rgba(15, 15, 18, 0.95);
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid rgba(96, 165, 250, 0.4);
            top: 2px;
            transform: translateX(-50%);
            white-space: nowrap;
            z-index: 10;
        }
        
        /* Sticky date indicator */
        .sticky-date {
            position: fixed;
            top: 130px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            color: #60a5fa;
            background: rgba(15, 15, 18, 0.95);
            padding: 6px 16px;
            border-radius: 20px;
            border: 1px solid rgba(96, 165, 250, 0.4);
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .sticky-date.visible {
            opacity: 1;
        }
        
        .chart-inner {
            position: relative;
            overflow: visible;
        }
        
        /* Swimlane row */
        .swimlane {
            position: relative;
            box-sizing: border-box;
            min-height: 68px;
        }
        
        /* Timeframe background tints for swimlanes */
        .swimlane[data-tf="1m"] { background: rgba(192, 132, 252, 0.02); }
        .swimlane[data-tf="5m"] { background: rgba(96, 165, 250, 0.02); }
        .swimlane[data-tf="15m"] { background: rgba(74, 222, 128, 0.02); }
        .swimlane[data-tf="1h"] { background: rgba(251, 191, 36, 0.02); }
        .swimlane[data-tf="4h"] { background: rgba(248, 113, 113, 0.02); }
        
        /* ES rows slightly darker for visual separation */
        .swimlane[data-symbol="ES"] {
            box-shadow: inset 0 0 0 1000px rgba(0,0,0,0.1);
        }
        
        /* ===== BREAKER BARS ===== */
        .breaker-bar {
            position: absolute;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 5px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: rgba(255,255,255,0.95);
            overflow: hidden;
            min-width: 6px;
        }
        
        .bar-right-group {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .breaker-bar:hover {
            z-index: 20;
            filter: brightness(1.15);
            box-shadow: 0 0 12px rgba(255,255,255,0.2);
        }
        
        .breaker-bar.selected {
            box-shadow: 0 0 0 2px #00ffff, 0 0 12px #00ffff;
            z-index: 21;
        }
        
        /* NQ Bull = Forest Green */
        .breaker-bar.nq.bull { background: #16a34a; }
        /* NQ Bear = Crimson Red */
        .breaker-bar.nq.bear { background: #dc2626; }
        /* ES Bull = Forest Green with bottom stripe */
        .breaker-bar.es.bull { background: #16a34a; }
        /* ES Bear = Crimson Red with bottom stripe */
        .breaker-bar.es.bear { background: #dc2626; }
        
        /* ES indicator - white bottom stripe */
        .breaker-bar.es::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 0 0 4px 4px;
        }
        
        /* Completed = slightly faded */
        .breaker-bar.completed {
            opacity: 0.75;
        }
        
        .breaker-bar.completed:hover {
            opacity: 1;
        }
        
        /* Fib label */
        .bar-fib {
            flex-shrink: 0;
            font-size: 11px;
            opacity: 0.95;
            font-weight: 600;
            letter-spacing: -0.2px;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .bar-fib-value {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.9);
            border-radius: 3px;
            padding: 2px 5px;
            font-size: 10px;
            font-weight: 700;
            color: #000;
        }
        
        .bar-points {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.9);
            border-radius: 3px;
            padding: 2px 5px;
            font-size: 10px;
            font-weight: 700;
            color: #000;
        }
        
        /* Status dot */
        .status-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 700;
            flex-shrink: 0;
            border: 2px solid rgba(255,255,255,0.95);
            color: #fff;
        }
        
        .status-dot.success {
            background: #16a34a;
        }
        
        .status-dot.fail {
            background: #dc2626;
        }
        
        /* Active at entry highlight (for selection - yellow crisp) */
        .breaker-bar.active-at-entry {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 25;
            opacity: 1 !important;
        }
        
        /* Cursor hover highlight (yellow - crisp) */
        .breaker-bar.cursor-active {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 24;
            opacity: 1 !important;
        }
        
        .lane-row.cursor-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-row.cursor-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Live mode highlight (yellow - same as cursor) */
        .breaker-bar.live-active {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 23;
            opacity: 1 !important;
        }
        
        .lane-row.live-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-row.live-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Entry lines */
        .entry-line {
            position: absolute;
            top: 0;
            width: 2px;
            background: rgba(251, 191, 36, 0.4);
            z-index: 15;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        /* Wider invisible hit area for easier clicking */
        .entry-line::after {
            content: '';
            position: absolute;
            top: 0;
            left: -12px;
            width: 26px;
            height: 100%;
            background: transparent;
        }
        
        .entry-line:hover {
            background: #fbbf24;
            width: 6px;
            margin-left: -2px;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        .entry-line.selected {
            background: #fbbf24;
            width: 4px;
            margin-left: -1px;
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.8);
        }
        
        /* Cursor line */
        .cursor-line {
            position: absolute;
            top: 0;
            width: 1px;
            border-left: 1px dashed rgba(255, 255, 255, 0.5);
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        .cursor-line.visible {
            opacity: 1;
        }
        
        .cursor-time {
            position: fixed;
            display: none;
            background: #fbbf24;
            color: #000;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
        }
        
        /* ===== SMT MARKERS ===== */
        .smt-marker {
            position: absolute;
            width: 6px;
            z-index: 50;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        /* Invisible hit area for easier clicking */
        .smt-marker::before {
            content: '';
            position: absolute;
            top: 0;
            left: -12px;
            width: 30px;
            height: 100%;
            background: transparent;
        }
        
        .smt-marker.bull {
            background: linear-gradient(180deg, #4ade80, rgba(74, 222, 128, 0.4));
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.7), 0 0 24px rgba(74, 222, 128, 0.4);
        }
        
        .smt-marker.bear {
            background: linear-gradient(180deg, #f87171, rgba(248, 113, 113, 0.4));
            box-shadow: 0 0 12px rgba(248, 113, 113, 0.7), 0 0 24px rgba(248, 113, 113, 0.4);
        }
        
        .smt-marker:hover {
            width: 10px;
            margin-left: -2px;
            z-index: 60;
        }
        
        .smt-marker.bull:hover {
            box-shadow: 0 0 20px rgba(74, 222, 128, 1), 0 0 40px rgba(74, 222, 128, 0.6);
            background: linear-gradient(180deg, #4ade80, rgba(74, 222, 128, 0.6));
        }
        
        .smt-marker.bear:hover {
            box-shadow: 0 0 20px rgba(248, 113, 113, 1), 0 0 40px rgba(248, 113, 113, 0.6);
            background: linear-gradient(180deg, #f87171, rgba(248, 113, 113, 0.6));
        }
        
        .smt-marker:hover .smt-diamond {
            width: 16px;
            height: 16px;
            border-width: 3px;
        }
        
        .smt-marker:hover .smt-score {
            font-size: 11px;
            font-weight: 800;
        }
        
        .smt-marker.selected {
            width: 10px;
            margin-left: -2px;
            z-index: 61;
        }
        
        .smt-marker.selected.bull {
            box-shadow: 0 0 0 2px #fff, 0 0 24px rgba(74, 222, 128, 1), 0 0 48px rgba(74, 222, 128, 0.5);
            background: linear-gradient(180deg, #4ade80, rgba(74, 222, 128, 0.6));
        }
        
        .smt-marker.selected.bear {
            box-shadow: 0 0 0 2px #fff, 0 0 24px rgba(248, 113, 113, 1), 0 0 48px rgba(248, 113, 113, 0.5);
            background: linear-gradient(180deg, #f87171, rgba(248, 113, 113, 0.6));
        }
        
        .smt-marker.selected .smt-diamond {
            width: 16px;
            height: 16px;
            border-width: 3px;
        }
        
        .smt-marker.selected .smt-score {
            font-size: 11px;
            font-weight: 800;
        }
        
        .smt-marker .smt-diamond {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 12px;
            height: 12px;
            border: 2px solid;
            border-radius: 2px;
            background: #1a1a1f;
            transition: all 0.15s;
        }
        
        .smt-marker.bull .smt-diamond {
            border-color: #4ade80;
            box-shadow: 0 0 6px rgba(74, 222, 128, 0.5);
        }
        
        .smt-marker.bear .smt-diamond {
            border-color: #f87171;
            box-shadow: 0 0 6px rgba(248, 113, 113, 0.5);
        }
        
        .smt-marker .smt-score {
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
            white-space: nowrap;
            transition: all 0.15s;
            text-shadow: 0 0 4px rgba(0,0,0,0.8);
        }
        
        .smt-marker.bull .smt-score {
            color: #4ade80;
        }
        
        .smt-marker.bear .smt-score {
            color: #f87171;
        }
        
        /* Status-based marker styling */
        .smt-marker.smt-invalidated {
            opacity: 0.4;
        }
        .smt-marker.smt-invalidated .smt-diamond {
            border-style: dashed;
        }
        
        .smt-marker.smt-expired {
            opacity: 0.25;
        }
        .smt-marker.smt-expired .smt-diamond {
            border-style: dotted;
        }
        
        /* ═══════════════════════════════════════════════════════════════════════
           SMT DASHBOARD - Comprehensive Signal Analysis Panel
           ═══════════════════════════════════════════════════════════════════════ */
        
        /* Header Row - Status & Quality */
        .smt-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .smt-status-pill {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .smt-status-pill.active { background: #166534; color: #4ade80; }
        .smt-status-pill.invalidated { background: #7f1d1d; color: #fca5a5; }
        .smt-status-pill.expired { background: #44403c; color: #a8a29e; }
        
        .smt-quality-pill {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            background: #0f0f12;
            border: 1px solid #2a2a2f;
        }
        .smt-quality-pill.high { border-color: #16a34a; }
        .smt-quality-pill.med { border-color: #ca8a04; }
        .smt-quality-pill.low { border-color: #dc2626; }
        
        .smt-quality-score {
            padding: 6px 12px;
            border-radius: 6px;
            min-width: 50px;
            text-align: center;
        }
        
        .smt-quality-score .smt-quality-num {
            font-size: 16px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .smt-quality-num {
            font-size: 14px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
        }
        .smt-quality-pill.high .smt-quality-num { color: #4ade80; }
        .smt-quality-pill.med .smt-quality-num { color: #fbbf24; }
        .smt-quality-pill.low .smt-quality-num { color: #f87171; }
        
        .smt-quality-label {
            font-size: 8px;
            color: #666;
            text-transform: uppercase;
        }
        
        /* Direction Block */
        .smt-direction-block {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            border-radius: 8px;
            margin-bottom: 12px;
        }
        .smt-direction-block.bull {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
            border: 1px solid rgba(74, 222, 128, 0.3);
        }
        .smt-direction-block.bear {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.15) 0%, rgba(248, 113, 113, 0.05) 100%);
            border: 1px solid rgba(248, 113, 113, 0.3);
        }
        
        .smt-dir-icon {
            font-size: 28px;
            font-weight: 700;
            line-height: 1;
        }
        .smt-direction-block.bull .smt-dir-icon { color: #4ade80; }
        .smt-direction-block.bear .smt-dir-icon { color: #f87171; }
        
        .smt-dir-info {
            flex: 1;
        }
        .smt-dir-label {
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 1px;
        }
        .smt-direction-block.bull .smt-dir-label { color: #4ade80; }
        .smt-direction-block.bear .smt-dir-label { color: #f87171; }
        
        .smt-dir-expect {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }
        
        .smt-swept-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.4);
        }
        
        /* Section Title */
        .smt-section-title {
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #555;
            margin-bottom: 8px;
        }
        
        /* Story Cards */
        /* SMT Divergence Chart - Tight */
        .smt-div-chart {
            display: flex;
            gap: 4px;
            align-items: stretch;
        }
        
        .smt-div-panel {
            flex: 1;
            background: #18181a;
            border: 1px solid #2a2a2e;
            border-radius: 6px;
            padding: 6px 8px;
            min-width: 0;
        }
        
        .smt-div-panel.sweep { border-left: 2px solid #f87171; }
        .smt-div-panel.defender { border-left: 2px solid #4ade80; }
        
        .smt-div-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .smt-div-title {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .smt-div-role {
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .smt-div-panel.sweep .smt-div-role { color: #f87171; }
        .smt-div-panel.defender .smt-div-role { color: #4ade80; }
        
        .smt-div-asset {
            font-size: 10px;
            font-weight: 600;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .smt-div-asset.nq { background: #1e3a5f; color: #60a5fa; }
        .smt-div-asset.es { background: #3f2e1e; color: #fbbf24; }
        
        .smt-div-structure {
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            color: #555;
        }
        
        /* LL/LH = bearish structures, HL/HH = bullish structures */
        .smt-div-structure.LL, .smt-div-structure.LH { color: #f87171; }
        .smt-div-structure.HL, .smt-div-structure.HH { color: #4ade80; }
        
        .smt-div-chart-area {
            height: 60px;
            position: relative;
        }
        
        .smt-div-svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .smt-div-svg .price-label {
            font-family: 'Roboto Mono', monospace;
            font-weight: 500;
        }
        
        .smt-div-svg .price-label.prev { fill: #999; }
        .smt-div-svg .price-label.curr { fill: #e0e0e0; }
        
        .smt-div-svg .time-label {
            font-family: 'Roboto Mono', monospace;
            fill: #999;
        }
        
        .smt-div-svg .chart-line {
            stroke-width: 2;
            fill: none;
            stroke-linecap: round;
        }
        
        .smt-div-panel.sweep .smt-div-svg .chart-line { stroke: #f87171; }
        .smt-div-panel.defender .smt-div-svg .chart-line { stroke: #4ade80; }
        
        .smt-div-svg .chart-point {
            stroke-width: 2;
        }
        
        .smt-div-svg .chart-point.prev {
            fill: #18181a;
            stroke: #555;
        }
        
        .smt-div-panel.sweep .smt-div-svg .chart-point.curr { fill: #f87171; stroke: #f87171; }
        .smt-div-panel.defender .smt-div-svg .chart-point.curr { fill: #4ade80; stroke: #4ade80; }
        
        .smt-div-delta {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            margin-top: 4px;
            text-align: right;
        }
        
        .smt-div-delta.positive { color: #4ade80; }
        .smt-div-delta.negative { color: #f87171; }
        
        .smt-div-vs {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            flex-shrink: 0;
            color: #444;
            font-size: 12px;
        }
        
        /* Detection Grid */
        .smt-detection-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .smt-detect-item {
            background: #0a0a0c;
            border-radius: 6px;
            padding: 8px 10px;
            border: 1px solid #1a1a1f;
        }
        
        .smt-detect-label {
            font-size: 8px;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .smt-detect-value {
            font-size: 11px;
            font-weight: 600;
            color: #ccc;
        }
        .smt-detect-value.method {
            font-size: 10px;
            color: #a78bfa;
        }
        .smt-detect-value.strength {
            color: #fbbf24;
            letter-spacing: 2px;
        }
        .smt-detect-value.asset {
            font-weight: 700;
        }
        .smt-detect-value.asset.nq { color: #60a5fa; }
        .smt-detect-value.asset.es { color: #fbbf24; }
        .smt-detect-value.price {
            font-family: 'Roboto Mono', monospace;
            color: #fb923c;
        }
        
        /* Criteria Chips */
        .smt-criteria-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }
        .smt-criteria-row:last-child { margin-bottom: 0; }
        
        .smt-criteria-chip {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            background: #0a0a0c;
            border: 1px solid #2a2a2f;
            cursor: default;
        }
        .smt-criteria-chip.ok {
            border-color: rgba(74, 222, 128, 0.4);
            color: #4ade80;
        }
        .smt-criteria-chip.fail {
            border-color: #333;
            color: #666;
        }
        .smt-criteria-row.levels .smt-criteria-chip.ok {
            border-color: rgba(251, 191, 36, 0.4);
            color: #fbbf24;
        }
        
        .smt-chip-icon {
            font-size: 9px;
        }
        .smt-chip-label {
            font-family: 'Roboto Mono', monospace;
        }
        
        /* Methods Pills - inside direction block */
        .smt-dir-methods {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }
        
        .smt-method-pill {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            padding: 3px 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.7);
        }
        
        /* Criteria List - Big & Visible */
        .smt-criteria-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .smt-criteria-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 4px;
            background: #0a0a0c;
            border: 1px solid #1a1a1f;
        }
        
        .smt-criteria-row.ok {
            border-color: rgba(74, 222, 128, 0.25);
            background: rgba(74, 222, 128, 0.03);
        }
        
        .smt-criteria-label {
            font-size: 12px;
            font-weight: 500;
            color: #555;
        }
        
        .smt-criteria-row.ok .smt-criteria-label {
            color: #ccc;
        }
        
        .smt-criteria-status {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            width: 16px;
            text-align: center;
        }
        
        .smt-criteria-row.ok .smt-criteria-status {
            color: #4ade80;
        }
        
        .smt-criteria-row:not(.ok) .smt-criteria-status {
            color: #444;
        }
        
        /* Quality Bar Section */
        .smt-quality-bar-section {
            background: #0a0a0c;
            border-radius: 6px;
            padding: 10px;
        }
        
        .smt-qbar-track {
            position: relative;
            height: 8px;
            background: #1a1a1f;
            border-radius: 4px;
            overflow: visible;
            margin-bottom: 6px;
        }
        
        .smt-qbar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .smt-qbar-fill.high { background: linear-gradient(90deg, #16a34a, #4ade80); }
        .smt-qbar-fill.med { background: linear-gradient(90deg, #ca8a04, #fbbf24); }
        .smt-qbar-fill.low { background: linear-gradient(90deg, #dc2626, #f87171); }
        
        .smt-qbar-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
        }
        .smt-qbar-mark {
            position: absolute;
            top: -14px;
            transform: translateX(-50%);
            font-size: 8px;
            color: #444;
            font-family: 'Roboto Mono', monospace;
        }
        
        .smt-qbar-labels {
            display: flex;
            justify-content: space-between;
            font-size: 8px;
            color: #444;
            text-transform: uppercase;
        }
        
        /* Meta Row */
        .smt-meta-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin-top: 8px;
            border-top: 1px solid #1a1a1f;
        }
        
        .smt-meta-tf {
            font-size: 10px;
            font-weight: 700;
            color: #888;
            font-family: 'Roboto Mono', monospace;
        }
        .smt-meta-sep { color: #333; }
        .smt-meta-id {
            font-size: 9px;
            color: #444;
            font-family: 'Roboto Mono', monospace;
        }
        
        /* Footer Section */
        .smt-footer-section {
            background: #0a0a0c;
            border-radius: 6px;
            padding: 10px 12px;
            margin-top: 8px;
        }
        
        .smt-footer-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
        }
        
        .smt-footer-row:not(:last-child) {
            border-bottom: 1px solid #1a1a1f;
        }
        
        .smt-footer-label {
            font-size: 10px;
            color: #555;
            text-transform: uppercase;
        }
        
        .smt-footer-value {
            font-family: 'Roboto Mono', monospace;
        }
        
        .smt-footer-value.time {
            font-size: 12px;
            font-weight: 600;
            color: #fbbf24;
        }
        
        .smt-footer-value.tf {
            font-size: 12px;
            font-weight: 700;
            color: #a78bfa;
        }
        
        .smt-footer-value.id {
            font-size: 11px;
            color: #aaa;
            word-break: break-all;
        }
        
        /* ===== DETAIL PANEL ===== */
        .detail-panel {
            width: 420px;
            min-width: 420px;
            background: #1a1a1c;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-header {
            padding: 10px 16px;
            background: #1f1f22;
            border-bottom: 1px solid #2a2a2e;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .panel-time {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            color: #fbbf24;
        }
        
        .panel-type {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .panel-type.live {
            color: #f87171;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .panel-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #555;
            text-align: center;
            padding: 20px;
        }
        
        .panel-empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        
        .panel-empty-text {
            font-size: 13px;
            line-height: 1.5;
        }
        
        /* Breaker Detail View */
        .detail-section {
            margin-bottom: 20px;
        }
        
        .detail-section:last-child {
            margin-bottom: 0;
        }
        
        .detail-section-title {
            font-size: 10px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #2a2a2e;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .live-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #60a5fa;
            animation: pulse-live 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-live {
            0%, 100% { opacity: 1; box-shadow: 0 0 6px #60a5fa; }
            50% { opacity: 0.6; box-shadow: 0 0 3px #60a5fa; }
        }
        
        .detail-id {
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
        }
        
        .detail-badges {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .detail-badge {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 4px;
        }
        
        .detail-badge.nq { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .detail-badge.es { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        .detail-badge.bull { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .detail-badge.bear { background: rgba(249, 115, 22, 0.2); color: #fb923c; }
        .detail-badge.active { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .detail-badge.success { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
        .detail-badge.fail { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #222;
        }
        
        .detail-row:last-child {
            border-bottom: none;
        }
        
        .detail-label {
            color: #888;
            font-size: 12px;
        }
        
        .detail-value {
            font-family: 'Roboto Mono', monospace;
            color: #ddd;
            font-size: 12px;
            font-weight: 500;
        }
        
        .detail-value.large {
            font-size: 18px;
            color: #fff;
        }
        
        .detail-metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 8px;
        }
        
        .detail-metric {
            background: #1a1a1c;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }
        
        .detail-metric-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 18px;
            font-weight: 600;
            color: #fff;
        }
        
        .detail-metric-label {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .failure-reason {
            margin-top: 8px;
            padding: 6px 10px;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 4px;
            font-size: 11px;
            color: #ef4444;
        }
        
        .detail-badge.tf {
            background: #374151;
            color: #9ca3af;
        }
        
        .compact-info {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px 0 !important;
        }
        
        .info-item {
            flex: 1 1 45%;
            min-width: 60px;
            background: #1a1a1c;
            border-radius: 4px;
            padding: 8px;
            text-align: center;
        }
        
        .info-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            display: block;
        }
        
        .info-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .price-zone-container {
            background: #151517;
            border-radius: 6px;
            padding: 12px;
        }
        
        .price-chart {
            width: 100%;
            height: 100px;
        }
        
        .price-chart-breaker-zone {
            fill: rgba(96, 165, 250, 0.15);
        }
        
        .price-chart-breaker-line {
            stroke: #60a5fa;
            stroke-width: 2;
        }
        
        .price-chart-level {
            stroke: #444;
            stroke-width: 1;
            stroke-dasharray: 4, 4;
        }
        
        .price-chart-price-line {
            fill: none;
            stroke: #f97316;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        .price-chart-price-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            fill: #60a5fa;
        }
        
        /* Entry Context View */
        .context-time {
            font-family: 'Roboto Mono', monospace;
            font-size: 20px;
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: 16px;
        }
        
        .context-grid {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .context-row {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            background: #151517;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .context-row.active {
            background: rgba(251, 191, 36, 0.12);
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
        }
        
        .context-row.live-active-row {
            background: rgba(251, 191, 36, 0.12);
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
        }
        
        .context-tf {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            width: 36px;
            color: #888;
        }
        
        .context-symbol {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            width: 28px;
            padding: 2px 4px;
            border-radius: 3px;
            text-align: center;
            margin-right: 10px;
        }
        
        .context-symbol.nq { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .context-symbol.es { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        
        .context-dir {
            font-size: 11px;
            font-weight: 600;
            width: 50px;
        }
        
        .context-dir.bull { color: #60a5fa; }
        .context-dir.bear { color: #fb923c; }
        .context-dir.none { color: #555; }
        
        .context-header {
            display: flex;
            align-items: center;
            padding: 4px 10px;
            font-size: 9px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #2a2a2e;
            margin-bottom: 4px;
        }
        
        .context-header span:nth-child(1) { width: 36px; }
        .context-header span:nth-child(2) { width: 38px; }
        .context-header span:nth-child(3) { width: 50px; }
        .context-header span:nth-child(4) { flex: 1; }
        .context-header span:nth-child(5) { width: 24px; text-align: center; }
        
        .context-fib {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #aaa;
            flex: 1;
        }
        
        .context-status-icon {
            font-size: 11px;
            width: 24px;
            text-align: center;
        }
        
        .context-status-icon.active { color: #60a5fa; }
        .context-status-icon.success { color: #4ade80; }
        .context-status-icon.fail { color: #f87171; }
        .context-status-icon.none { color: #444; }
        
        .arrow-bull { color: #4ade80; }
        .arrow-bear { color: #f87171; }
        
        .context-summary {
            margin-top: 16px;
            padding: 12px;
            background: #151517;
            border-radius: 6px;
        }
        
        .context-summary-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }
        
        .context-summary-label {
            color: #888;
            font-size: 12px;
        }
        
        .context-summary-value {
            font-family: 'Roboto Mono', monospace;
            font-weight: 600;
            font-size: 12px;
        }
        
        .context-summary-value.good { color: #4ade80; }
        .context-summary-value.bad { color: #f87171; }
        .context-summary-value.neutral { color: #fbbf24; }
        
        /* Confluence Fib Tracks */
        .confluence-fib-tracks {
            margin-top: 16px;
        }
        
        .confluence-fib-track {
            background: #151517;
            border-radius: 6px;
            margin-bottom: 8px;
            overflow: hidden;
            border-left: 3px solid #333;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .confluence-fib-track:hover {
            background: #1a1a1c;
            border-color: #555;
        }
        
        .confluence-fib-track.bull {
            border-left-color: #4ade80;
        }
        
        .confluence-fib-track.bear {
            border-left-color: #f87171;
        }
        
        .confluence-fib-track-header {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            gap: 6px;
        }
        
        .confluence-fib-track-tf {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            color: #e0e0e0;
            width: 28px;
        }
        
        .confluence-fib-track-badge {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: 500;
        }
        
        .confluence-fib-track-badge.nq { background: #2563eb20; color: #60a5fa; }
        .confluence-fib-track-badge.es { background: #7c3aed20; color: #a78bfa; }
        
        .confluence-fib-track-fib {
            margin-left: auto;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #60a5fa;
            font-weight: 500;
        }
        
        .confluence-fib-track-chart {
            padding: 0 8px 8px 8px;
        }
        
        /* Stacked view styles */
        .confluence-stacked-view {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        /* Stacked Breaker Charts */
        .stack-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .stack-item {
            background: #111;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: filter 0.15s, box-shadow 0.15s;
        }
        
        .stack-item:hover {
            filter: brightness(1.15);
        }
        
        .stack-item.selected {
            box-shadow: 0 0 0 2px #00ffff, 0 0 8px #00ffff;
        }
        
        .stack-label {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: #0a0a0c;
            border-left: 4px solid #888;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
        }
        
        .stack-tf {
            font-weight: 700;
            min-width: 24px;
        }
        
        .stack-sym {
            color: #777;
        }
        
        .stack-dir {
            font-weight: 600;
        }
        
        .stack-spacer {
            flex: 1;
        }
        
        .stack-legend {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            color: #777;
        }
        
        .legend-line {
            width: 14px;
            height: 2px;
            border-radius: 1px;
        }
        
        .legend-line.dashed {
            height: 0;
            border-top: 2px dashed;
        }
        
        .stack-charts {
            display: flex;
            flex-direction: column;
            background: #0d0d0f;
        }
        
        .stack-svg {
            width: 100%;
            height: 90px;
            display: block;
        }
        
        .stack-svg-tall {
            width: 100%;
            height: 130px;
            display: block;
        }
        
        .stack-empty {
            padding: 16px;
            text-align: center;
            color: #444;
            font-size: 10px;
        }
        
        /* Unified Breaker Cards */
        .confluence-cards {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        /* Old card styles - keep for right panel */
        .confluence-card-old {
            display: flex;
            background: #111;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .confluence-card-old:hover {
            background: #1a1a1c;
        }
        
        .card-accent {
            width: 4px;
            flex-shrink: 0;
        }
        
        .card-content {
            flex: 1;
            min-width: 0;
        }
        
        .card-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: #0a0a0a;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
        }
        
        .card-tf {
            font-weight: 700;
            min-width: 24px;
        }
        
        .card-symbol {
            color: #888;
        }
        
        .card-dir {
            font-weight: 600;
        }
        
        .card-spacer {
            flex: 1;
        }
        
        .card-fib {
            color: #666;
        }
        
        .card-price {
            color: #555;
        }
        
        .card-charts {
            display: flex;
            flex-direction: column;
            gap: 1px;
            padding: 2px;
        }
        
        .card-chart {
            width: 100%;
            height: 32px;
            display: block;
        }
        
        .card-no-data {
            padding: 8px;
            text-align: center;
            color: #444;
            font-size: 10px;
        }
        
        .confluence-stack-section {
            background: #111;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .confluence-stack-title {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 8px 12px;
            background: #0a0a0a;
            border-bottom: 1px solid #1a1a1a;
        }
        
        .confluence-stack-charts {
            display: flex;
            flex-direction: column;
        }
        
        .confluence-stack-box {
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid #1a1a1a;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .confluence-stack-box:last-child {
            border-bottom: none;
        }
        
        .confluence-stack-box:hover {
            background: #151515;
        }
        
        /* Standard: bull=green, bear=red */
        .confluence-stack-box.bull {
            border-left: 3px solid #4ade80;
        }
        
        .confluence-stack-box.bear {
            border-left: 3px solid #f87171;
        }
        
        .confluence-stack-label {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: #0d0d0d;
        }
        
        .stack-tf {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: #ccc;
        }
        
        .stack-sym {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            color: #888;
        }
        
        .stack-dir {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            font-weight: 500;
        }
        
        /* Standard: bull=green, bear=red */
        .stack-dir.bull { color: #4ade80; }
        .stack-dir.bear { color: #f87171; }
        
        .confluence-stack-chart {
            padding: 2px 4px;
        }
        
        .confluence-stack-item {
            border-bottom: 1px solid #1a1a1a;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .confluence-stack-item:last-child {
            border-bottom: none;
        }
        
        .confluence-stack-item:hover {
            background: #151515;
        }
        
        /* Standard: bull=green, bear=red */
        .confluence-stack-item.bull {
            border-left: 3px solid #4ade80;
        }
        
        .confluence-stack-item.bear {
            border-left: 3px solid #f87171;
        }
        
        .confluence-stack-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: #0d0d0d;
        }
        
        .confluence-stack-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: #888;
        }
        
        .stack-dir {
            font-weight: 600;
        }
        
        .stack-dir.bull { color: #4ade80; }
        .stack-dir.bear { color: #f87171; }
        
        .confluence-stack-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: #666;
        }
        
        .confluence-stack-svg {
            width: 100%;
            height: 50px;
            display: block;
        }
        
        /* Legacy combined view styles (keep for compatibility) */
        .confluence-combined-view {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .confluence-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px;
            background: #151517;
            border-radius: 6px;
        }
        
        .confluence-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            background: #1a1a1c;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .confluence-legend-item:hover {
            background: #252528;
        }
        
        .confluence-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .confluence-legend-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: #ccc;
        }
        
        .confluence-chart-section {
            background: #111;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .confluence-chart-title {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            font-weight: 600;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 6px 10px;
            background: #0a0a0a;
            border-bottom: 1px solid #1a1a1a;
        }
        
        .confluence-combined-svg {
            width: 100%;
            height: 200px;
            display: block;
        }
        
        .confluence-time-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 8px;
            fill: #555;
        }
        
        .confluence-price-scale {
            font-family: 'Roboto Mono', monospace;
            font-size: 8px;
            fill: #555;
        }
        
        .confluence-fib-grid {
            stroke: #2a2a2e;
            stroke-width: 0.5;
        }
        
        .confluence-fib-scale {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            fill: #666;
        }
        
        .confluence-price-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 8px;
            fill: #60a5fa;
        }
        
        /* INVERTED: Bulls are RED, Bears are GREEN */
        .confluence-fib-line.bull { stroke: #f87171; }
        .confluence-fib-line.bear { stroke: #4ade80; }
        
        .confluence-fib-area.bull { fill: rgba(248, 113, 113, 0.15); }
        .confluence-fib-area.bear { fill: rgba(74, 222, 128, 0.15); }
        
        .confluence-fib-dot.bull { fill: #f87171; }
        .confluence-fib-dot.bear { fill: #4ade80; }
        
        /* Track border colors inverted too */
        .confluence-fib-track.bull {
            border-left-color: #f87171;
        }
        
        .confluence-fib-track.bear {
            border-left-color: #4ade80;
        }
        
        /* Badge colors inverted */
        .confluence-fib-track-badge.bull { background: #dc262615; color: #f87171; }
        .confluence-fib-track-badge.bear { background: #16a34a15; color: #4ade80; }
        
        .confluence-fib-track-svg {
            width: 100%;
            height: 100%;
        }
        
        .confluence-fib-ref-line {
            stroke: #333;
            stroke-width: 0.5;
            stroke-dasharray: 2, 3;
        }
        
        .confluence-fib-line {
            fill: none;
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        .confluence-fib-line.bull { stroke: #4ade80; }
        .confluence-fib-line.bear { stroke: #f87171; }
        
        .confluence-fib-area.bull { fill: rgba(74, 222, 128, 0.15); }
        .confluence-fib-area.bear { fill: rgba(248, 113, 113, 0.15); }
        
        .confluence-fib-dot {
            stroke: #1a1a1c;
            stroke-width: 1.5;
        }
        
        .confluence-fib-dot.bull { fill: #4ade80; }
        .confluence-fib-dot.bear { fill: #f87171; }
        
        .confluence-section-title {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .confluence-section-title::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #2a2a2e;
        }
        
        .confluence-no-active {
            text-align: center;
            color: #555;
            padding: 20px;
            font-size: 12px;
        }
        
        /* Fib Chart */
        .fib-chart-container {
            margin-top: 8px;
            background: #151517;
            border-radius: 6px;
            padding: 12px;
        }
        
        .fib-chart-legend {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-bottom: 4px;
            font-size: 10px;
            color: #888;
        }
        
        .fib-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .fib-legend-line {
            width: 16px;
            height: 3px;
            border-radius: 1px;
        }
        
        .fib-legend-line.max {
            background: #60a5fa;
        }
        
        .fib-legend-line.current {
            background: #f97316;
        }
        
        .fib-chart {
            width: 100%;
            height: 120px;
        }
        
        .fib-chart-axis {
            stroke: #333;
            stroke-width: 1;
        }
        
        .fib-chart-grid {
            stroke: #222;
            stroke-width: 1;
            stroke-dasharray: 2, 4;
        }
        
        .fib-chart-line {
            fill: none;
            stroke: #60a5fa;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        .fib-chart-line-current {
            fill: none;
            stroke: #f97316;
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
            opacity: 0.8;
        }
        
        .fib-chart-area {
            fill: url(#fibGradient);
            opacity: 0.3;
        }
        
        .fib-chart-dot {
            fill: #60a5fa;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .fib-chart-dot:hover {
            fill: #fff;
            r: 5;
        }
        
        .fib-chart-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            fill: #666;
        }
        
        .fib-chart-value-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            fill: #888;
        }
        
        .fib-chart-peak {
            fill: #4ade80;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .fib-peak-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            fill: #4ade80;
            font-weight: 600;
        }
        
        .fib-chart-container {
            position: relative;
        }
        
        .fib-cursor-line {
            stroke: #fbbf24;
            stroke-width: 1;
            stroke-dasharray: 3, 3;
            opacity: 0;
            pointer-events: none;
        }
        
        .fib-cursor-dot {
            fill: #fbbf24;
            opacity: 0;
            pointer-events: none;
        }
        
        .fib-cursor-tooltip {
            position: absolute;
            background: #252528;
            border: 1px solid #3a3a3e;
            border-radius: 4px;
            padding: 6px 10px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 10;
            white-space: nowrap;
        }
        
        .fib-cursor-tooltip .fib-val {
            color: #60a5fa;
            font-weight: 600;
        }
        
        .fib-cursor-tooltip .time-val {
            color: #888;
            margin-left: 8px;
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .toast.error { background: #dc2626; }
        .toast.success { background: #16a34a; }
        
        /* Legend */
        .legend {
            display: flex;
            gap: 12px;
            align-items: center;
            font-size: 11px;
            color: #888;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-swatch {
            width: 18px;
            height: 14px;
            border-radius: 3px;
            position: relative;
        }
        
        .legend-swatch.nq-bull { background: #16a34a; }
        .legend-swatch.nq-bear { background: #dc2626; }
        .legend-swatch.es-bull { background: #16a34a; }
        .legend-swatch.es-bear { background: #dc2626; }
        
        /* ES legend swatches get bottom stripe */
        .legend-swatch.es-bull::after,
        .legend-swatch.es-bear::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 0 0 3px 3px;
        }
        
        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 700;
            border: 2px solid rgba(255,255,255,0.8);
            color: #fff;
        }
        
        .legend-dot.win { 
            background: #16a34a;
        }
        .legend-dot.loss { 
            background: #dc2626;
        }
        
        .legend-swatch.entry { 
            background: #fbbf24; 
            width: 3px; 
            height: 16px;
        }
        
        .legend-divider {
            width: 1px;
            height: 16px;
            background: #3a3a3e;
            margin: 0 4px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1c;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #3a3a3e;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a4e;
        }
        
        /* Analysis Modal - Redesigned */
        .analysis-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
        }
        
        .analysis-modal-overlay.visible { display: flex; }
        
        .analysis-modal {
            background: linear-gradient(180deg, #1a1a1c 0%, #0f0f11 100%);
            border-radius: 16px;
            border: 1px solid #333;
            width: calc(100% - 40px);
            max-width: none;
            height: calc(100% - 40px);
            max-height: none;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.7);
            position: relative;
        }
        
        /* Hero Section */
        .analysis-hero {
            padding: 28px 32px 20px;
            background: linear-gradient(135deg, rgba(35, 35, 40, 0.9) 0%, rgba(25, 25, 30, 0.9) 100%);
            border-bottom: 1px solid #333;
            position: relative;
        }
        
        .analysis-hero-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(255,255,255,0.08);
            border: none;
            color: #666;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.2s;
        }
        
        .analysis-hero-close:hover { background: rgba(255,255,255,0.12); color: #fff; }
        
        .analysis-hero-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .analysis-hero-decision {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .analysis-decision-badge {
            font-family: 'Roboto Mono', monospace;
            font-size: 24px;
            font-weight: 800;
            padding: 14px 32px;
            border-radius: 10px;
            letter-spacing: 3px;
        }
        
        .analysis-decision-badge.execute {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.08) 100%);
            color: #4ade80;
            border: 2px solid rgba(74, 222, 128, 0.3);
            box-shadow: 0 0 40px rgba(74, 222, 128, 0.15);
        }
        
        .analysis-decision-badge.caution {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2) 0%, rgba(251, 191, 36, 0.08) 100%);
            color: #fbbf24;
            border: 2px solid rgba(251, 191, 36, 0.3);
            box-shadow: 0 0 40px rgba(251, 191, 36, 0.15);
        }
        
        .analysis-decision-badge.skip, .analysis-decision-badge.blocked {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.08) 100%);
            color: #f87171;
            border: 2px solid rgba(248, 113, 113, 0.3);
            box-shadow: 0 0 40px rgba(248, 113, 113, 0.15);
        }
        
        .analysis-hero-id {
            font-family: 'Roboto Mono', monospace;
            font-size: 13px;
            color: #94a3b8;
        }
        
        .analysis-hero-meta {
            font-size: 12px;
            color: #64748b;
            margin-top: 2px;
        }
        
        .analysis-hero-score {
            text-align: right;
        }
        
        .analysis-score-big {
            font-family: 'Roboto Mono', monospace;
            font-size: 36px;
            font-weight: 700;
            color: #fff;
        }
        
        .analysis-score-label {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Category Tabs */
        .analysis-tabs {
            display: flex;
            background: rgba(15, 15, 18, 0.6);
            border-bottom: 1px solid #333;
            padding: 0 24px;
        }
        
        .analysis-tab {
            padding: 16px 24px;
            font-size: 12px;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -1px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .analysis-tab:hover { color: #94a3b8; background: rgba(255,255,255,0.02); }
        
        .analysis-tab.active {
            color: #fff;
            border-bottom-color: #60a5fa;
            background: rgba(96, 165, 250, 0.05);
        }
        
        .analysis-tab-count {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 10px;
        }
        
        .analysis-tab-count.all-pass { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-tab-count.has-warn { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-tab-count.has-fail { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        .analysis-tab-count.has-error { background: rgba(248, 113, 113, 0.4); color: #fff; }
        
        /* Content Area */
        .analysis-content {
            flex: 1;
            overflow-y: auto;
            padding: 28px;
        }
        
        .analysis-panel { display: none; }
        .analysis-panel.active { display: block; }
        
        /* Dimension Cards */
        .analysis-cards {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        
        .analysis-card {
            background: rgba(30, 30, 35, 0.5);
            border: 1px solid #2a2a30;
            border-radius: 12px;
            padding: 20px 24px;
            transition: all 0.2s;
        }
        
        .analysis-card:hover {
            border-color: #3a3a45;
            background: rgba(40, 40, 48, 0.5);
        }
        
        .analysis-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        
        .analysis-card-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .analysis-card-code {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.12);
            padding: 4px 10px;
            border-radius: 5px;
        }
        
        .analysis-card-name {
            font-size: 14px;
            font-weight: 600;
            color: #e2e8f0;
        }
        
        .analysis-card-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            font-weight: 700;
            padding: 6px 16px;
            border-radius: 5px;
        }
        
        .analysis-card-value.pass { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-card-value.warn { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-card-value.fail { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        .analysis-card-value.error { background: rgba(248, 113, 113, 0.3); color: #f87171; font-size: 9px; }
        
        .analysis-card.error-card {
            border: 1px solid rgba(248, 113, 113, 0.5);
            background: rgba(248, 113, 113, 0.05);
        }
        
        /* Visual breakdown section */
        .analysis-card-visual {
            margin-bottom: 16px;
        }
        
        /* Bias row for direction dimensions */
        .analysis-bias-row {
            display: flex;
            gap: 8px;
        }
        
        .analysis-bias-item {
            flex: 1;
            background: rgba(0,0,0,0.25);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }
        
        .analysis-bias-tf {
            font-size: 10px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .analysis-bias-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            font-weight: 600;
        }
        
        .analysis-bias-value.bullish { color: #4ade80; }
        .analysis-bias-value.bearish { color: #f87171; }
        .analysis-bias-value.neutral { color: #fbbf24; }
        
        /* TF count bars for support/resistance */
        .analysis-tf-bars {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            height: 60px;
            padding: 0 10px;
        }
        
        .analysis-tf-bar {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .analysis-tf-bar-fill {
            width: 100%;
            border-radius: 4px 4px 0 0;
            min-height: 4px;
            transition: height 0.3s;
        }
        
        .analysis-tf-bar-fill.support { background: linear-gradient(180deg, #4ade80 0%, #22c55e 100%); }
        .analysis-tf-bar-fill.resistance { background: linear-gradient(180deg, #f87171 0%, #ef4444 100%); }
        .analysis-tf-bar-fill.empty { background: rgba(255,255,255,0.08); height: 4px !important; }
        
        .analysis-tf-bar-label {
            font-size: 10px;
            color: #64748b;
            font-weight: 600;
        }
        
        .analysis-tf-bar-count {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #ccc;
            font-weight: 600;
        }
        
        /* Metric row for energy/gate */
        .analysis-metric-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .analysis-metric {
            background: rgba(0,0,0,0.25);
            border-radius: 6px;
            padding: 10px 14px;
            flex: 1;
            min-width: 70px;
        }
        
        .analysis-metric-label {
            font-size: 9px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .analysis-metric-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 13px;
            font-weight: 600;
            color: #e2e8f0;
        }
        
        .analysis-metric-value.pass { color: #4ade80; }
        .analysis-metric-value.warn { color: #fbbf24; }
        .analysis-metric-value.fail { color: #f87171; }
        
        /* Calculation explanation */
        .analysis-card-calc {
            margin-top: 14px;
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.06);
        }
        
        .analysis-calc-title {
            font-size: 9px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }
        
        .analysis-calc-text {
            font-size: 12px;
            color: #94a3b8;
            line-height: 1.5;
        }
        
        /* Failed breakers visual */
        .analysis-failed-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .analysis-failed-item {
            background: rgba(0,0,0,0.25);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            border: 1px solid transparent;
        }
        
        .analysis-failed-item.failed {
            border-color: rgba(74, 222, 128, 0.3);
            background: rgba(74, 222, 128, 0.1);
        }
        
        .analysis-failed-item-label {
            font-size: 9px;
            color: #64748b;
            margin-bottom: 4px;
        }
        
        .analysis-failed-item-status {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
        }
        
        .analysis-failed-item.failed .analysis-failed-item-status { color: #4ade80; }
        .analysis-failed-item:not(.failed) .analysis-failed-item-status { color: #64748b; }
        
        /* Premium/Discount gauge */
        .analysis-gauge {
            position: relative;
            height: 20px;
            background: linear-gradient(90deg, #4ade80 0%, #fbbf24 50%, #f87171 100%);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .analysis-gauge-marker {
            position: absolute;
            top: 2px;
            bottom: 2px;
            width: 4px;
            background: #fff;
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(0,0,0,0.5);
        }
        
        .analysis-gauge-labels {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #64748b;
            margin-top: 6px;
        }
        
        /* Progress bar for burn/ratios */
        .analysis-progress {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .analysis-progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
        
        .analysis-progress-fill.good { background: linear-gradient(90deg, #4ade80, #22c55e); }
        .analysis-progress-fill.warn { background: linear-gradient(90deg, #fbbf24, #f59e0b); }
        .analysis-progress-fill.bad { background: linear-gradient(90deg, #f87171, #ef4444); }
        
        
        
        .analysis-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #333;
            background: linear-gradient(135deg, #1e1e20 0%, #252528 100%);
        }
        
        .analysis-modal-title {
            font-size: 16px;
            font-weight: 600;
            color: #60a5fa;
        }
        
        .analysis-modal-subtitle {
            font-size: 12px;
            color: #888;
            margin-top: 2px;
        }
        
        .analysis-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .analysis-modal-close:hover {
            background: #333;
            color: #fff;
        }
        
        .analysis-modal-body {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .analysis-categories {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr auto;
            gap: 16px;
            flex: 1;
            min-height: 0;
        }
        
        .analysis-category.gate {
            grid-column: 1 / -1;
            min-height: auto;
            max-height: fit-content;
        }
        
        .analysis-category.gate .analysis-category-body {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .analysis-category.gate .analysis-dimension {
            margin-bottom: 0;
        }
        
        .analysis-category.gate .analysis-dimension .analysis-dimension-detail {
            display: none;
        }
        
        .analysis-category.gate .analysis-dimension.expanded .analysis-dimension-detail {
            display: block;
        }
        
        .analysis-category {
            background: rgba(30, 30, 32, 0.6);
            border-radius: 8px;
            border: 1px solid #333;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .analysis-category-header {
            padding: 10px 14px;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .analysis-category-toggle {
            font-size: 10px;
            color: #666;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 3px;
            background: rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        
        .analysis-category-toggle:hover {
            background: rgba(0,0,0,0.4);
            color: #aaa;
        }
        
        .analysis-category.gate .analysis-category-header {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.15) 0%, rgba(251, 191, 36, 0.05) 100%);
            color: #fbbf24;
        }
        
        .analysis-category.direction .analysis-category-header {
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.15) 0%, rgba(96, 165, 250, 0.05) 100%);
            color: #60a5fa;
        }
        
        .analysis-category.support .analysis-category-header {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
            color: #4ade80;
        }
        
        .analysis-category.resistance .analysis-category-header {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.15) 0%, rgba(248, 113, 113, 0.05) 100%);
            color: #f87171;
        }
        
        .analysis-category.energy .analysis-category-header {
            background: linear-gradient(135deg, rgba(192, 132, 252, 0.15) 0%, rgba(192, 132, 252, 0.05) 100%);
            color: #c084fc;
        }
        
        .analysis-category-body {
            padding: 10px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }
        
        .analysis-dimension {
            border-radius: 4px;
            margin-bottom: 6px;
            background: rgba(40, 40, 44, 0.4);
            overflow: hidden;
        }
        
        .analysis-dimension:last-child {
            margin-bottom: 0;
        }
        
        .analysis-dimension-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .analysis-dimension-header:hover {
            background: rgba(60, 60, 64, 0.4);
        }
        
        .analysis-dimension-left {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .analysis-dimension-name {
            font-size: 12px;
            color: #ccc;
        }
        
        .analysis-dimension-code {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #666;
            background: rgba(0,0,0,0.2);
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .analysis-dimension-expand {
            color: #666;
            font-size: 10px;
            transition: transform 0.2s;
        }
        
        .analysis-dimension.expanded .analysis-dimension-expand {
            transform: rotate(180deg);
        }
        
        .analysis-dimension-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            padding: 3px 10px;
            border-radius: 3px;
            min-width: 80px;
            text-align: center;
        }
        
        .analysis-dimension-value.pass,
        .analysis-dimension-value.aligned,
        .analysis-dimension-value.converged,
        .analysis-dimension-value.strong,
        .analysis-dimension-value.confirms,
        .analysis-dimension-value.clear,
        .analysis-dimension-value.high,
        .analysis-dimension-value.powered,
        .analysis-dimension-value.discount,
        .analysis-dimension-value.available {
            background: rgba(74, 222, 128, 0.15);
            color: #4ade80;
        }
        
        .analysis-dimension-value.warn,
        .analysis-dimension-value.moderate,
        .analysis-dimension-value.partial,
        .analysis-dimension-value.neutral,
        .analysis-dimension-value.friction,
        .analysis-dimension-value.equilibrium,
        .analysis-dimension-value.limited {
            background: rgba(251, 191, 36, 0.15);
            color: #fbbf24;
        }
        
        .analysis-dimension-value.fail,
        .analysis-dimension-value.opposed,
        .analysis-dimension-value.diverged,
        .analysis-dimension-value.weak,
        .analysis-dimension-value.none,
        .analysis-dimension-value.conflicts,
        .analysis-dimension-value.blocked,
        .analysis-dimension-value.low,
        .analysis-dimension-value.exhausted,
        .analysis-dimension-value.premium {
            background: rgba(248, 113, 113, 0.15);
            color: #f87171;
        }
        
        .analysis-dimension-detail {
            display: none;
            padding: 12px 14px;
            background: rgba(20, 20, 22, 0.6);
            border-top: 1px solid rgba(255,255,255,0.05);
            font-size: 11px;
            line-height: 1.6;
        }
        
        .analysis-dimension.expanded .analysis-dimension-detail {
            display: block;
        }
        
        .analysis-detail-question {
            color: #888;
            font-style: italic;
            margin-bottom: 10px;
        }
        
        .analysis-detail-reason {
            font-size: 12px;
            color: #e2e8f0;
            padding: 10px 12px;
            margin-bottom: 10px;
            background: rgba(96, 165, 250, 0.1);
            border-left: 3px solid #60a5fa;
            border-radius: 0 4px 4px 0;
        }
        
        .analysis-detail-calc {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 10px 12px;
            margin-bottom: 10px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
        }
        
        .analysis-detail-calc-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .analysis-detail-calc-row:last-child {
            border-bottom: none;
            padding-top: 6px;
            margin-top: 4px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-weight: 600;
        }
        
        .analysis-detail-calc-label {
            color: #888;
        }
        
        .analysis-detail-calc-value {
            color: #ccc;
        }
        
        .analysis-detail-calc-value.pass { color: #4ade80; background: rgba(74, 222, 128, 0.15); padding: 1px 6px; border-radius: 3px; }
        .analysis-detail-calc-value.fail { color: #f87171; background: rgba(248, 113, 113, 0.15); padding: 1px 6px; border-radius: 3px; }
        .analysis-detail-calc-value.warn { color: #fbbf24; background: rgba(251, 191, 36, 0.15); padding: 1px 6px; border-radius: 3px; }
        
        .analysis-detail-logic {
            margin-top: 10px;
        }
        
        .analysis-detail-logic-title {
            color: #666;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        .analysis-detail-logic-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .analysis-detail-logic-table th,
        .analysis-detail-logic-table td {
            padding: 4px 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 10px;
        }
        
        .analysis-detail-logic-table th {
            color: #666;
            font-weight: 500;
        }
        
        .analysis-detail-logic-table td {
            color: #aaa;
        }
        
        .analysis-detail-logic-table tr.active {
            background: rgba(96, 165, 250, 0.1);
        }
        
        .analysis-detail-logic-table tr.active td {
            color: #60a5fa;
        }
        
        /* Zone visualization */
        .analysis-zones {
            margin-top: 12px;
        }
        
        .analysis-zones-title {
            color: #666;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .analysis-zones-entry {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
            padding: 2px 8px;
            border-radius: 3px;
        }
        
        .analysis-zone-stack {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .analysis-zone {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: rgba(30, 30, 34, 0.6);
            border-radius: 4px;
            border-left: 3px solid #444;
            font-size: 10px;
        }
        
        .analysis-zone.tf-4h { border-left-color: #c084fc; }
        .analysis-zone.tf-1h { border-left-color: #60a5fa; }
        .analysis-zone.tf-15m { border-left-color: #4ade80; }
        .analysis-zone.tf-5m { border-left-color: #fbbf24; }
        .analysis-zone.tf-1m { border-left-color: #f87171; }
        
        .analysis-zone-tf {
            font-family: 'Roboto Mono', monospace;
            font-weight: 600;
            min-width: 32px;
            padding: 2px 6px;
            border-radius: 3px;
            text-align: center;
            font-size: 9px;
        }
        
        .analysis-zone.tf-4h .analysis-zone-tf { background: rgba(192, 132, 252, 0.2); color: #c084fc; }
        .analysis-zone.tf-1h .analysis-zone-tf { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .analysis-zone.tf-15m .analysis-zone-tf { background: rgba(74, 222, 128, 0.2); color: #4ade80; }
        .analysis-zone.tf-5m .analysis-zone-tf { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
        .analysis-zone.tf-1m .analysis-zone-tf { background: rgba(248, 113, 113, 0.2); color: #f87171; }
        
        .analysis-zone-type {
            color: #888;
            min-width: 50px;
        }
        
        .analysis-zone-type.bull { color: #4ade80; }
        .analysis-zone-type.bear { color: #f87171; }
        
        .analysis-zone-range {
            font-family: 'Roboto Mono', monospace;
            color: #ccc;
            min-width: 120px;
        }
        
        .analysis-zone-fib {
            font-family: 'Roboto Mono', monospace;
            padding: 2px 6px;
            border-radius: 3px;
            min-width: 55px;
            text-align: center;
        }
        
        .analysis-zone-fib.fresh { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-zone-fib.tested { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-zone-fib.extended { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        
        .analysis-zone-dist {
            font-family: 'Roboto Mono', monospace;
            color: #888;
            min-width: 60px;
            text-align: right;
        }
        
        .analysis-zone-status {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            min-width: 50px;
            text-align: center;
        }
        
        .analysis-zone-status.active { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        .analysis-zone-status.touched { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .analysis-zone-status.broken { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        
        /* ===== ENHANCED VISUALS ===== */
        
        /* Price Ladder - Unified Support/Resistance View */
        .price-ladder {
            position: relative;
            margin: 12px 0;
            padding: 16px;
            background: linear-gradient(180deg, rgba(15,15,18,0.95) 0%, rgba(20,20,25,0.9) 100%);
            border-radius: 10px;
            border: 1px solid #333;
            min-height: 280px;
        }
        
        .price-ladder-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .price-ladder-title {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .price-ladder-legend {
            display: flex;
            gap: 12px;
            font-size: 9px;
            color: #888;
        }
        
        .price-ladder-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .price-ladder-legend-swatch {
            width: 12px;
            height: 8px;
            border-radius: 2px;
        }
        
        .price-ladder-legend-swatch.breaker-support { background: rgba(74, 222, 128, 0.4); border: 1px solid #4ade80; }
        .price-ladder-legend-swatch.fvg-support { background: rgba(74, 222, 128, 0.2); border: 1px dashed rgba(74, 222, 128, 0.5); }
        .price-ladder-legend-swatch.breaker-resist { background: rgba(248, 113, 113, 0.4); border: 1px solid #f87171; }
        .price-ladder-legend-swatch.fvg-resist { background: rgba(248, 113, 113, 0.2); border: 1px dashed rgba(248, 113, 113, 0.5); }
        
        .price-ladder-body {
            display: flex;
            height: 240px;
        }
        
        .price-ladder-axis {
            width: 60px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            border-right: 1px solid #333;
            padding-right: 8px;
            margin-right: 12px;
        }
        
        .price-ladder-axis-tick {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            color: #555;
            text-align: right;
        }
        
        .price-ladder-axis-tick.entry { color: #60a5fa; font-weight: 600; }
        .price-ladder-axis-tick.target { color: #4ade80; font-weight: 600; }
        .price-ladder-axis-tick.stop { color: #f87171; font-weight: 600; }
        
        .price-ladder-chart {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        /* Price level lines */
        .price-ladder-level {
            position: absolute;
            left: 0;
            right: 80px;
            height: 2px;
            display: flex;
            align-items: center;
        }
        
        .price-ladder-level-line {
            flex: 1;
            height: 100%;
        }
        
        .price-ladder-level.entry .price-ladder-level-line {
            background: #60a5fa;
            box-shadow: 0 0 10px rgba(96, 165, 250, 0.6);
        }
        
        .price-ladder-level.target .price-ladder-level-line {
            background: repeating-linear-gradient(90deg, #4ade80 0, #4ade80 6px, transparent 6px, transparent 10px);
        }
        
        .price-ladder-level.stop .price-ladder-level-line {
            background: #f87171;
            box-shadow: 0 0 8px rgba(248, 113, 113, 0.5);
        }
        
        .price-ladder-level-label {
            position: absolute;
            right: 0;
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            padding: 3px 8px;
            border-radius: 3px;
            white-space: nowrap;
        }
        
        .price-ladder-level.entry .price-ladder-level-label {
            background: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
            border: 1px solid rgba(96, 165, 250, 0.4);
        }
        
        .price-ladder-level.target .price-ladder-level-label {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .price-ladder-level.stop .price-ladder-level-label {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        /* Zone blocks */
        .price-ladder-zone {
            position: absolute;
            left: 0;
            right: 85px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            transition: all 0.15s;
            cursor: default;
        }
        
        .price-ladder-zone:hover {
            transform: translateX(4px);
            z-index: 10;
        }
        
        .price-ladder-zone.support-breaker {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.35) 0%, rgba(74, 222, 128, 0.15) 100%);
            border: 1px solid rgba(74, 222, 128, 0.6);
            border-left: 3px solid #4ade80;
            color: #4ade80;
        }
        
        .price-ladder-zone.support-fvg {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.08) 100%);
            border: 1px dashed rgba(74, 222, 128, 0.5);
            color: rgba(74, 222, 128, 0.9);
        }
        
        .price-ladder-zone.resist-breaker {
            background: linear-gradient(90deg, rgba(248, 113, 113, 0.35) 0%, rgba(248, 113, 113, 0.15) 100%);
            border: 1px solid rgba(248, 113, 113, 0.6);
            border-left: 3px solid #f87171;
            color: #f87171;
        }
        
        .price-ladder-zone.resist-fvg {
            background: linear-gradient(90deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.08) 100%);
            border: 1px dashed rgba(248, 113, 113, 0.5);
            color: rgba(248, 113, 113, 0.9);
        }
        
        /* TF badge colors */
        .price-ladder-zone .zone-tf {
            font-weight: 600;
            padding: 1px 4px;
            border-radius: 2px;
            margin-right: 6px;
            font-size: 8px;
        }
        
        .price-ladder-zone.tf-4h .zone-tf { background: rgba(192, 132, 252, 0.3); color: #c084fc; }
        .price-ladder-zone.tf-1h .zone-tf { background: rgba(96, 165, 250, 0.3); color: #60a5fa; }
        .price-ladder-zone.tf-15m .zone-tf { background: rgba(74, 222, 128, 0.3); color: #4ade80; }
        .price-ladder-zone.tf-5m .zone-tf { background: rgba(251, 191, 36, 0.3); color: #fbbf24; }
        
        .price-ladder-zone .zone-info {
            margin-left: auto;
            opacity: 0.7;
            font-size: 8px;
        }
        
        /* Current price arrow */
        .price-ladder-current {
            position: absolute;
            left: -6px;
            width: 0;
            height: 0;
            border-top: 7px solid transparent;
            border-bottom: 7px solid transparent;
            border-left: 10px solid #60a5fa;
            filter: drop-shadow(0 0 4px rgba(96, 165, 250, 0.8));
            z-index: 20;
        }
        
        /* R:R sidebar */
        .price-ladder-rr {
            position: absolute;
            right: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        
        .price-ladder-rr-segment {
            width: 14px;
            border-radius: 2px;
        }
        
        .price-ladder-rr-segment.reward { background: linear-gradient(180deg, #4ade80, rgba(74, 222, 128, 0.3)); }
        .price-ladder-rr-segment.risk { background: linear-gradient(0deg, #f87171, rgba(248, 113, 113, 0.3)); }
        
        .price-ladder-rr-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            color: #4ade80;
            margin: 4px 0;
        }
        
        /* Direction Flow Visual */
        .direction-flow {
            margin: 8px 0;
        }
        
        .direction-flow-row {
            display: flex;
            align-items: center;
            padding: 8px 0;
        }
        
        .direction-flow-symbol {
            width: 36px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            color: #888;
        }
        
        .direction-flow-tfs {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .direction-flow-tf {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .direction-flow-tf-label {
            font-size: 9px;
            color: #666;
            margin-bottom: 4px;
        }
        
        .direction-flow-tf-box {
            width: 44px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            position: relative;
        }
        
        .direction-flow-tf-box.bullish {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.25) 0%, rgba(74, 222, 128, 0.1) 100%);
            border: 1px solid rgba(74, 222, 128, 0.5);
            color: #4ade80;
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.2);
        }
        
        .direction-flow-tf-box.bearish {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.25) 0%, rgba(248, 113, 113, 0.1) 100%);
            border: 1px solid rgba(248, 113, 113, 0.5);
            color: #f87171;
            box-shadow: 0 0 12px rgba(248, 113, 113, 0.2);
        }
        
        .direction-flow-tf-box.neutral {
            background: rgba(100, 100, 100, 0.15);
            border: 1px solid rgba(150, 150, 150, 0.3);
            color: #888;
        }
        
        .direction-flow-arrow {
            width: 24px;
            height: 2px;
            margin: 0 -4px;
            position: relative;
            top: 4px;
        }
        
        .direction-flow-arrow::after {
            content: '';
            position: absolute;
            right: 0;
            top: -3px;
            border: 4px solid transparent;
        }
        
        .direction-flow-arrow.aligned {
            background: #4ade80;
        }
        
        .direction-flow-arrow.aligned::after {
            border-left-color: #4ade80;
        }
        
        .direction-flow-arrow.mixed {
            background: linear-gradient(90deg, #fbbf24, #f87171);
        }
        
        .direction-flow-arrow.mixed::after {
            border-left-color: #f87171;
        }
        
        .direction-flow-result {
            width: 85px;
            text-align: center;
            padding: 6px 10px;
            border-radius: 6px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
        }
        
        .direction-flow-result.aligned {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.08) 100%);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .direction-flow-result.partial {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2) 0%, rgba(251, 191, 36, 0.08) 100%);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.4);
        }
        
        .direction-flow-result.opposed, .direction-flow-result.diverged {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.08) 100%);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        /* Inversion Grid */
        .inversion-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin: 8px 0;
        }
        
        .inversion-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
            transition: all 0.2s;
        }
        
        .inversion-cell.failed {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
            border-color: rgba(74, 222, 128, 0.4);
        }
        
        .inversion-cell.active {
            background: rgba(60, 60, 60, 0.2);
            border-color: #444;
        }
        
        .inversion-cell-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            color: #888;
            margin-bottom: 6px;
        }
        
        .inversion-cell-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        .inversion-cell.failed .inversion-cell-icon { color: #4ade80; }
        .inversion-cell.active .inversion-cell-icon { color: #666; }
        
        .inversion-cell-status {
            font-size: 8px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .inversion-cell.failed .inversion-cell-status { color: #4ade80; }
        .inversion-cell.active .inversion-cell-status { color: #666; }
        
        /* ADR Burn Gauges */
        .burn-gauges {
            display: flex;
            gap: 24px;
            justify-content: center;
            padding: 8px 0;
        }
        
        .burn-gauge {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .burn-gauge-label {
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            color: #888;
            margin-bottom: 8px;
        }
        
        .burn-gauge-ring {
            position: relative;
            width: 80px;
            height: 80px;
        }
        
        .burn-gauge-ring svg {
            transform: rotate(-90deg);
        }
        
        .burn-gauge-bg {
            fill: none;
            stroke: #333;
            stroke-width: 6;
        }
        
        .burn-gauge-fill {
            fill: none;
            stroke-width: 6;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }
        
        .burn-gauge-fill.available { stroke: #4ade80; }
        .burn-gauge-fill.limited { stroke: #fbbf24; }
        .burn-gauge-fill.exhausted { stroke: #f87171; }
        
        .burn-gauge-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            font-weight: 700;
        }
        
        .burn-gauge-value.available { color: #4ade80; }
        .burn-gauge-value.limited { color: #fbbf24; }
        .burn-gauge-value.exhausted { color: #f87171; }
        
        .burn-gauge-status {
            margin-top: 6px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .burn-gauge-status.available { color: #4ade80; }
        .burn-gauge-status.limited { color: #fbbf24; }
        .burn-gauge-status.exhausted { color: #f87171; }
        
        /* Formation Visual - FVG + Sweep */
        .formation-visual {
            position: relative;
            margin: 8px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
            height: 120px;
        }
        
        .formation-visual-bar {
            position: absolute;
            left: 30%;
            width: 40%;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
        }
        
        .formation-visual-bar.breaker {
            background: linear-gradient(90deg, rgba(96, 165, 250, 0.3) 0%, rgba(96, 165, 250, 0.15) 100%);
            border: 1px solid rgba(96, 165, 250, 0.5);
            color: #60a5fa;
        }
        
        .formation-visual-bar.fvg {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.4) 0%, rgba(74, 222, 128, 0.2) 100%);
            border: 1px solid rgba(74, 222, 128, 0.6);
            color: #4ade80;
        }
        
        .formation-visual-sweep {
            position: absolute;
            left: 15%;
            width: 2px;
            background: #fbbf24;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.5);
        }
        
        .formation-visual-sweep::before {
            content: '⚡';
            position: absolute;
            left: -8px;
            top: -10px;
            font-size: 12px;
        }
        
        .formation-visual-label {
            position: absolute;
            font-family: 'Roboto Mono', monospace;
            font-size: 8px;
            color: #888;
        }
        
        /* Attraction Zone Visual */
        .attraction-visual {
            margin: 8px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .attraction-visual-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .attraction-visual-tf {
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 4px;
        }
        
        .attraction-visual-tf.bullish {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .attraction-visual-tf.bearish {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        .attraction-visual-sd {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .attraction-visual-sd-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 18px;
            font-weight: 700;
        }
        
        .attraction-visual-sd-label {
            font-size: 9px;
            color: #888;
        }
        
        .attraction-visual-phase {
            padding: 4px 10px;
            border-radius: 4px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            font-weight: 600;
        }
        
        .attraction-visual-phase.fresh {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.4);
        }
        
        .attraction-visual-phase.tested {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.4);
        }
        
        .attraction-visual-phase.exhausted {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.4);
        }
        
        .attraction-visual-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .attraction-visual-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
        
        .attraction-visual-bar-fill.bullish { background: linear-gradient(90deg, #4ade80, rgba(74, 222, 128, 0.5)); }
        .attraction-visual-bar-fill.bearish { background: linear-gradient(90deg, #f87171, rgba(248, 113, 113, 0.5)); }
        
        /* R:R Visual for Gate */
        .rr-visual {
            margin: 8px 0;
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .rr-visual-prices {
            display: flex;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        
        .rr-visual-price {
            text-align: center;
        }
        
        .rr-visual-price-label {
            font-size: 9px;
            color: #888;
            margin-bottom: 4px;
        }
        
        .rr-visual-price-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 600;
        }
        
        .rr-visual-price.entry .rr-visual-price-value { color: #60a5fa; }
        .rr-visual-price.stop .rr-visual-price-value { color: #f87171; }
        .rr-visual-price.target .rr-visual-price-value { color: #4ade80; }
        
        .rr-visual-bar {
            position: relative;
            height: 32px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        
        .rr-visual-bar-risk {
            position: absolute;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, #f87171, rgba(248, 113, 113, 0.3));
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #f87171;
        }
        
        .rr-visual-bar-reward {
            position: absolute;
            right: 0;
            height: 100%;
            background: linear-gradient(270deg, #4ade80, rgba(74, 222, 128, 0.3));
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #4ade80;
        }
        
        .rr-visual-bar-entry {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #60a5fa;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.8);
        }
        
        .rr-visual-ratio {
            text-align: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 20px;
            font-weight: 700;
        }
        
        .rr-visual-ratio.pass { color: #4ade80; }
        .rr-visual-ratio.fail { color: #f87171; }
        
        /* VIX Gauge */
        .vix-gauge {
            margin: 8px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .vix-gauge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .vix-gauge-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 24px;
            font-weight: 700;
        }
        
        .vix-gauge-value.stable { color: #4ade80; }
        .vix-gauge-value.elevated { color: #fbbf24; }
        .vix-gauge-value.high { color: #f87171; }
        
        .vix-gauge-ratio {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 4px;
        }
        
        .vix-gauge-ratio.stable {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }
        
        .vix-gauge-ratio.elevated {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }
        
        .vix-gauge-ratio.high {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }
        
        .vix-gauge-bar {
            height: 6px;
            background: linear-gradient(90deg, #4ade80 0%, #fbbf24 50%, #f87171 100%);
            border-radius: 3px;
            position: relative;
        }
        
        .vix-gauge-marker {
            position: absolute;
            top: -4px;
            width: 4px;
            height: 14px;
            background: #fff;
            border-radius: 2px;
            transform: translateX(-50%);
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.5);
        }
        
        /* Premium/Discount Gauge */
        .pd-gauge {
            margin: 8px 0;
        }
        
        .pd-gauge-bar {
            position: relative;
            height: 24px;
            background: linear-gradient(90deg, 
                rgba(74, 222, 128, 0.3) 0%, 
                rgba(74, 222, 128, 0.15) 35%,
                rgba(251, 191, 36, 0.15) 35%,
                rgba(251, 191, 36, 0.15) 65%,
                rgba(248, 113, 113, 0.15) 65%,
                rgba(248, 113, 113, 0.3) 100%
            );
            border-radius: 4px;
            border: 1px solid #444;
        }
        
        .pd-gauge-marker {
            position: absolute;
            top: -2px;
            width: 4px;
            height: 28px;
            background: #fff;
            border-radius: 2px;
            transform: translateX(-50%);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
        }
        
        .pd-gauge-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 9px;
            color: #888;
        }
        
        .pd-gauge-labels span:first-child { color: #4ade80; }
        .pd-gauge-labels span:last-child { color: #f87171; }
        
        /* Session Indicator */
        .session-visual {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .session-visual-time {
            font-family: 'Roboto Mono', monospace;
            font-size: 20px;
            font-weight: 600;
            color: #fff;
        }
        
        .session-visual-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            font-weight: 600;
        }
        
        .session-visual-badge.active {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.25) 0%, rgba(74, 222, 128, 0.1) 100%);
            border: 1px solid rgba(74, 222, 128, 0.5);
            color: #4ade80;
        }
        
        .session-visual-badge.inactive {
            background: rgba(100, 100, 100, 0.2);
            border: 1px solid #555;
            color: #888;
        }
        
        /* Visual Zone Chart */
        .analysis-zone-chart {
            position: relative;
            margin: 16px 0;
            padding: 12px;
            background: rgba(15, 15, 18, 0.8);
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .analysis-zone-chart-title {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        
        .analysis-zone-chart-inner {
            position: relative;
            height: 280px;
            display: flex;
        }
        
        .analysis-zone-chart-axis {
            width: 70px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px 0;
            border-right: 1px solid #333;
            margin-right: 12px;
        }
        
        .analysis-zone-chart-price {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            color: #666;
            text-align: right;
            padding-right: 8px;
        }
        
        .analysis-zone-chart-price.entry { color: #60a5fa; font-weight: 600; }
        .analysis-zone-chart-price.target { color: #4ade80; font-weight: 600; }
        .analysis-zone-chart-price.stop { color: #f87171; font-weight: 600; }
        
        .analysis-zone-chart-body {
            flex: 1;
            position: relative;
        }
        
        .analysis-zone-chart-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: #333;
        }
        
        .analysis-zone-chart-line.entry {
            background: #60a5fa;
            height: 2px;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.5);
        }
        
        .analysis-zone-chart-line.target {
            background: #4ade80;
            height: 2px;
            border-style: dashed;
            box-shadow: 0 0 8px rgba(74, 222, 128, 0.5);
        }
        
        .analysis-zone-chart-line.stop {
            background: #f87171;
            height: 2px;
            box-shadow: 0 0 8px rgba(248, 113, 113, 0.5);
        }
        
        .analysis-zone-chart-label {
            position: absolute;
            right: 0;
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            transform: translateY(-50%);
        }
        
        .analysis-zone-chart-label.entry {
            background: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
        }
        
        .analysis-zone-chart-label.target {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }
        
        .analysis-zone-chart-label.stop {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }
        
        .analysis-zone-chart-zone {
            position: absolute;
            left: 80px;
            right: 60px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding-left: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            opacity: 0.9;
            transition: opacity 0.2s;
        }
        
        .analysis-zone-chart-zone:hover {
            opacity: 1;
        }
        
        .analysis-zone-chart-zone.bull {
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.3) 0%, rgba(74, 222, 128, 0.1) 100%);
            border-left: 3px solid #4ade80;
            color: #4ade80;
        }
        
        .analysis-zone-chart-zone.bear {
            background: linear-gradient(90deg, rgba(248, 113, 113, 0.3) 0%, rgba(248, 113, 113, 0.1) 100%);
            border-left: 3px solid #f87171;
            color: #f87171;
        }
        
        .analysis-zone-chart-zone-tf {
            font-weight: 600;
            min-width: 28px;
        }
        
        .analysis-zone-chart-zone.tf-4h { border-left-color: #c084fc; }
        .analysis-zone-chart-zone.tf-1h { border-left-color: #60a5fa; }
        .analysis-zone-chart-zone.tf-15m { border-left-color: #4ade80; }
        .analysis-zone-chart-zone.tf-5m { border-left-color: #fbbf24; }
        
        .analysis-zone-chart-zone.tf-4h .analysis-zone-chart-zone-tf { color: #c084fc; }
        .analysis-zone-chart-zone.tf-1h .analysis-zone-chart-zone-tf { color: #60a5fa; }
        .analysis-zone-chart-zone.tf-15m .analysis-zone-chart-zone-tf { color: #4ade80; }
        .analysis-zone-chart-zone.tf-5m .analysis-zone-chart-zone-tf { color: #fbbf24; }
        
        .analysis-zone-chart-current {
            position: absolute;
            left: 75px;
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 8px solid #60a5fa;
            transform: translateY(-50%);
        }
        
        .analysis-zones-summary {
            margin-top: 8px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-size: 10px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .analysis-zones-summary-result {
            font-weight: 600;
        }
        
        .analysis-zones-summary-result.strong { color: #4ade80; }
        .analysis-zones-summary-result.moderate { color: #fbbf24; }
        .analysis-zones-summary-result.weak { color: #f87171; }
        
        .analysis-zone-ladder {
            position: relative;
            margin: 12px 0;
            padding-left: 20px;
            border-left: 2px solid #333;
        }
        
        .analysis-zone-ladder-entry {
            position: relative;
            padding: 6px 0 6px 15px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #60a5fa;
        }
        
        .analysis-zone-ladder-entry::before {
            content: '►';
            position: absolute;
            left: -8px;
            color: #60a5fa;
            font-size: 8px;
        }
        
        .analysis-zone-ladder-target {
            position: relative;
            padding: 6px 0 6px 15px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #4ade80;
        }
        
        .analysis-zone-ladder-target::before {
            content: '◆';
            position: absolute;
            left: -8px;
            color: #4ade80;
            font-size: 8px;
        }
        
        .analysis-zone-ladder-stop {
            position: relative;
            padding: 6px 0 6px 15px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            color: #f87171;
        }
        
        .analysis-zone-ladder-stop::before {
            content: '■';
            position: absolute;
            left: -7px;
            color: #f87171;
            font-size: 8px;
        }
        
        .analysis-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #1e1e20 0%, #252528 100%);
        }
        
        .analysis-decision {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .analysis-decision-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .analysis-decision-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            padding: 6px 16px;
            border-radius: 4px;
        }
        
        .analysis-decision-value.execute {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(74, 222, 128, 0.1) 100%);
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.3);
        }
        
        .analysis-decision-value.caution {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2) 0%, rgba(251, 191, 36, 0.1) 100%);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }
        
        .analysis-decision-value.skip {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.1) 100%);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.3);
        }
        
        .analysis-decision-value.blocked {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.3) 0%, rgba(180, 50, 50, 0.2) 100%);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.5);
        }
        
        .analysis-score {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .analysis-score-bar {
            width: 120px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .analysis-score-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .analysis-score-fill.high { background: #4ade80; }
        .analysis-score-fill.moderate { background: #fbbf24; }
        .analysis-score-fill.low { background: #f87171; }
        
        .analysis-score-text {
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            color: #888;
        }
        
        .analysis-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: #60a5fa;
            font-size: 11px;
            cursor: pointer;
            padding: 6px 10px;
            border-radius: 4px;
            background: rgba(96, 165, 250, 0.1);
            border: 1px solid rgba(96, 165, 250, 0.2);
            transition: all 0.2s;
            margin-top: 12px;
        }
        
        .analysis-link:hover {
            background: rgba(96, 165, 250, 0.2);
            border-color: rgba(96, 165, 250, 0.4);
        }
        
        .analysis-link-disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .analysis-link-disabled:hover {
            background: rgba(96, 165, 250, 0.1);
            border-color: rgba(96, 165, 250, 0.2);
        }
        
        /* Confluence Button */
        .confluence-btn {
            background: linear-gradient(135deg, #7c3aed 0%, #4f46e5 100%) !important;
            border: none !important;
        }
        
        .confluence-btn:hover {
            background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%) !important;
        }
        
        /* Confluence Modal */
        .confluence-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0a0a0c;
            z-index: 10000;
            display: none;
        }
        
        .confluence-modal-overlay.visible {
            display: flex;
            flex-direction: column;
        }
        
        .confluence-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: #0a0a0c;
            border-bottom: 1px solid #18181a;
        }
        
        .confluence-modal-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .confluence-modal-title span {
            color: #a78bfa;
        }
        
        .confluence-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
        }
        
        .confluence-modal-close:hover {
            color: #fff;
        }
        
        .confluence-modal-time-header {
            height: 28px;
            background: #0a0a0c;
            border-bottom: 1px solid #18181a;
            position: relative;
            overflow: hidden;
        }
        
        .confluence-time-inner {
            position: absolute;
            height: 100%;
            display: flex;
            align-items: center;
        }
        
        .confluence-time-tick {
            position: absolute;
            font-size: 10px;
            color: #555;
            font-family: 'Roboto Mono', monospace;
            transform: translateX(-50%);
        }
        
        .confluence-modal-body {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: #030304;
        }
        
        .confluence-scroll-container {
            height: 100%;
            overflow-x: auto;
            overflow-y: auto;
            position: relative;
            background: #030304;
        }
        
        .confluence-chart-inner {
            position: relative;
            min-height: 100%;
            padding-left: 20px;
            padding-top: 10px;
            background: #030304;
        }
        
        .confluence-cursor-line {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(168, 85, 247, 0.7);
            pointer-events: none;
            z-index: 10001;
            display: none;
        }
        
        .confluence-cursor-line.visible {
            display: block;
        }
        
        .confluence-cursor-time {
            position: fixed;
            background: #7c3aed;
            color: #fff;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-family: 'Roboto Mono', monospace;
            pointer-events: none;
            z-index: 10004;
            display: none;
            transform: translateX(-50%);
        }
        
        .confluence-card {
            position: absolute;
            background: #131416;
            border-radius: 6px;
            overflow: hidden;
            min-width: 100px;
            height: 220px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        
        .confluence-card-body {
            height: 220px;
            position: relative;
            background: #131416;
        }
        
        .confluence-card-body svg {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* Cursor label that appears at top of each card */
        .confluence-cursor-label {
            position: fixed;
            background: rgba(19, 20, 22, 0.98);
            border-radius: 2px 0 0 2px;
            padding: 4px 8px 4px 6px;
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            color: #fff;
            pointer-events: none;
            z-index: 10003;
            white-space: nowrap;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }
        
        .confluence-labels-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10002;
        }
        
        .confluence-no-data {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #555;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-left">
            <div class="logo"><span class="logo-icon"></span> SigXFlow</div>
            <div class="stats-row">
                <div class="stat-compact success"><span id="stat-success">-</span> S</div>
                <div class="stat-compact fail"><span id="stat-fail">-</span> F</div>
                <div class="stat-compact win"><span id="stat-winrate">-</span></div>
            </div>
        </div>
        
        <div class="nav-group">
            <button class="btn inactive" id="mode-explore" onclick="setMode('explore')">🔍 Explore</button>
            <button class="btn live" id="mode-live" onclick="setMode('live')">🔴 Live</button>
            <button class="btn confluence-btn" onclick="openConfluenceModal()">◈ Confluence</button>
            <div class="divider"></div>
            <div class="settings-group">
                <select class="select-styled" id="load-limit" onchange="loadData(true)">
                    <option value="8">Load 8hr</option>
                    <option value="12">Load 12hr</option>
                    <option value="24" selected>Load 1 day</option>
                    <option value="48">Load 2 days</option>
                    <option value="72">Load 3 days</option>
                    <option value="96">Load 4 days</option>
                    <option value="120">Load 5 days</option>
                    <option value="144">Load 6 days</option>
                </select>
                <select class="select-styled" id="refresh-interval" onchange="setRefreshInterval()">
                    <option value="0">Auto: Off</option>
                    <option value="30" selected>Auto: 30s</option>
                    <option value="60">Auto: 1m</option>
                    <option value="300">Auto: 5m</option>
                </select>
                <span class="countdown" id="countdown"></span>
                <button class="btn secondary" onclick="loadData(true)">↻</button>
                <button class="btn primary" onclick="goToLatest()">Latest →|</button>
            </div>
        </div>
    </div>
    
    <!-- Toolbar -->
    <div class="toolbar">
        <div class="legend">
            <div class="legend-item"><div class="legend-swatch nq-bull"></div>NQ Bull</div>
            <div class="legend-item"><div class="legend-swatch nq-bear"></div>NQ Bear</div>
            <div class="legend-item"><div class="legend-swatch es-bull"></div>ES Bull</div>
            <div class="legend-item"><div class="legend-swatch es-bear"></div>ES Bear</div>
            <div class="legend-divider"></div>
            <div class="legend-item"><div class="legend-dot win">S</div>Success</div>
            <div class="legend-item"><div class="legend-dot loss">F</div>Failure</div>
            <div class="legend-divider"></div>
            <div class="legend-item"><div class="legend-swatch entry"></div>Entry</div>
        </div>
        
        <div class="toolbar-right">
            <span class="status-msg" id="status-msg"></span>
            <div class="filter-group">
                <button class="filter-btn nq active" id="filter-nq" onclick="toggleFilter('nq')">NQ</button>
                <button class="filter-btn es active" id="filter-es" onclick="toggleFilter('es')">ES</button>
            </div>
            <div class="filter-group">
                <button class="filter-btn bull active" id="filter-bull" onclick="toggleFilter('bull')"><span class="arrow-up"></span> Bull</button>
                <button class="filter-btn bear active" id="filter-bear" onclick="toggleFilter('bear')"><span class="arrow-down"></span> Bear</button>
            </div>
        </div>
    </div>
    
    <!-- Main Wrapper -->
    <div class="main-wrapper">
        <!-- Chart Area -->
        <div class="chart-area">
            <div class="header-row">
                <div class="left-header" id="data-start">--</div>
                <div class="time-header-wrapper">
                    <div class="timeline-track" id="timeline-track">
                        <div class="timeline-viewport" id="viewport-indicator"></div>
                    </div>
                    <div class="time-header" id="time-header"></div>
                </div>
            </div>
            <div class="scroll-container" id="scroll-container">
                <div class="scroll-inner">
                    <div class="left-panel" id="left-panel"></div>
                    <div class="right-panel">
                        <div class="chart-inner" id="chart-inner"></div>
                    </div>
                </div>
            </div>
            <div class="sticky-date" id="sticky-date"></div>
        </div>
        
        <!-- Detail Panel -->
        <div class="detail-panel">
            <div class="panel-header">
                <span class="panel-time" id="panel-time"></span>
                <span class="panel-type" id="panel-type">Details</span>
            </div>
            <div class="panel-content" id="panel-content">
                <div class="panel-empty">
                    <div class="panel-empty-icon">📋</div>
                    <div class="panel-empty-text">
                        Click a breaker bar or entry line to see details
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>
    
    <!-- Analysis Modal -->
    <div class="analysis-modal-overlay" id="analysis-modal" onclick="closeAnalysisModal(event)">
        <div class="analysis-modal" onclick="event.stopPropagation()">
            <!-- Hero Section with Decision -->
            <div class="analysis-hero">
                <button class="analysis-hero-close" onclick="closeAnalysisModal()">&times;</button>
                <div class="analysis-hero-top">
                    <div class="analysis-hero-decision">
                        <span class="analysis-decision-badge" id="analysis-decision-badge">EXECUTE</span>
                        <div>
                            <div class="analysis-hero-id" id="analysis-hero-id">NQ_1m_20250115_1205</div>
                            <div class="analysis-hero-meta" id="analysis-hero-meta">10:05 AM ET</div>
                        </div>
                    </div>
                    <div class="analysis-hero-score">
                        <div class="analysis-score-big" id="analysis-score-big">18/21</div>
                        <div class="analysis-score-label">Dimensions Passed</div>
                    </div>
                </div>
            </div>
            
            <!-- Category Tabs -->
            <div class="analysis-tabs" id="analysis-tabs">
                <!-- Tabs generated by JS -->
            </div>
            
            <!-- Content Area -->
            <div class="analysis-content" id="analysis-content">
                <!-- Category panels generated by JS -->
            </div>
        </div>
    </div>

    <!-- Confluence Modal -->
    <div class="confluence-modal-overlay" id="confluence-modal">
        <div class="confluence-modal-header">
            <div class="confluence-modal-title"><span>◈</span> Confluence View</div>
            <button class="confluence-modal-close" onclick="closeConfluenceModal()">&times;</button>
        </div>
        <div class="confluence-modal-time-header" id="confluence-time-header">
            <div class="confluence-time-inner" id="confluence-time-inner"></div>
        </div>
        <div class="confluence-modal-body">
            <div class="confluence-scroll-container" id="confluence-scroll">
                <div class="confluence-chart-inner" id="confluence-chart-inner">
                    <!-- Cards rendered here -->
                </div>
            </div>
        </div>
        <div class="confluence-cursor-line" id="confluence-cursor-line"></div>
        <div class="confluence-cursor-time" id="confluence-cursor-time"></div>
        <div class="confluence-labels-container" id="confluence-labels-container"></div>
    </div>

    <script>
        // ===== CONFIG =====
        const FIREBASE_URL = "https://sigxflow-default-rtdb.firebaseio.com/snapshots.json";
        const SMT_FIREBASE_URL = "https://sigxflow-default-rtdb.firebaseio.com/smt_signals.json";
        const PIXELS_PER_MINUTE = 30;
        const BAR_HEIGHT = 26;  // Height of breaker bars
        const BAR_GAP = 3;      // Gap between stacked bars
        const LANE_PADDING = 6; // Top/bottom padding in swimlanes
        const TF_HEADER_HEIGHT = 2;
        const LEFT_PANEL_MIN_HEIGHT = 68; // Minimum based on left panel content
        
        const TF_ORDER = ['1m', '5m', '15m', '1h', '4h'];
        const TF_DISPLAY = { '4h': '4H', '1h': '1H', '15m': '15m', '5m': '5m', '1m': '1m' };
        const SYMBOLS = ['NQ', 'ES'];
        
        // ===== STATE =====
        let allData = [];
        let smtData = [];  // SMT signals
        let smtCache = {}; // For incremental SMT updates
        let lastSmtFetchTime = null; // Track last SMT fetch for incremental updates
        let breakerCache = {}; // For incremental updates
        let windowStartMin = 0;
        let windowEndMin = 0;
        let dataMinTime = 0;
        let dataMaxTime = 0;
        let isLive = true;
        let isFirstLoad = true;
        let lastFetchedTime = null; // Track last observation_time for incremental fetch
        let lastLoadLimit = null; // Track if limit changed (requires full reload)
        let refreshTimer = null;
        let countdownTimer = null;
        let countdownSecs = 0;
        let selectedEntryMin = null;
        let selectedBreakerId = null;
        let lockedConfluenceMin = null;
        let entryTimes = [];
        let chartAbortController = null; // For cleaning up event listeners
        let renderedBars = []; // Cached bar elements for fast highlight
        let renderedLaneLabels = []; // Cached lane labels
        let laneStats = {}; // Stats per tf/symbol/direction
        
        const filters = {
            nq: true, es: true,
            bull: true, bear: true
        };
        
        // ===== UTILITIES =====
        function datetimeToMin(datetime) {
            const parts = datetime.replace('T', ' ').split(' ');
            const dateParts = parts[0].split('-');
            const timeParts = (parts[1] || '00:00').split(':');
            const d = new Date(
                parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]),
                parseInt(timeParts[0]), parseInt(timeParts[1])
            );
            return Math.floor(d.getTime() / 60000);
        }
        
        function minToTime(m) {
            const d = new Date(m * 60000);
            return d.getHours().toString().padStart(2, '0') + ':' + 
                   d.getMinutes().toString().padStart(2, '0');
        }
        
        function minToDateTime(m) {
            const d = new Date(m * 60000);
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            return months[d.getMonth()] + ' ' + d.getDate() + ', ' + minToTime(m);
        }
        
        function minToDateStr(m) {
            const d = new Date(m * 60000);
            const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            return days[d.getDay()] + ' ' + months[d.getMonth()] + ' ' + d.getDate();
        }
        
        function minToDateKey(m) {
            // Returns YYYY-MM-DD for comparison
            const d = new Date(m * 60000);
            return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
        }
        
        function minToShortDateTime(m) {
            // Returns compact date+time like "1/14 10:05"
            const d = new Date(m * 60000);
            return (d.getMonth() + 1) + '/' + d.getDate() + ' ' + 
                   d.getHours().toString().padStart(2, '0') + ':' + 
                   d.getMinutes().toString().padStart(2, '0');
        }
        
        function minToDuration(startMin, endMin) {
            const mins = endMin - startMin;
            if (mins < 60) return mins + 'm';
            const hrs = Math.floor(mins / 60);
            const rem = mins % 60;
            return rem > 0 ? `${hrs}h ${rem}m` : `${hrs}h`;
        }
        
        let toastTimeout = null;
        
        function showToast(msg, type = '') {
            const el = document.getElementById('status-msg');
            el.textContent = msg;
            el.className = 'status-msg ' + type;
            // Clear previous timeout and set new one
            if (toastTimeout) clearTimeout(toastTimeout);
            if (type !== 'error') {
                toastTimeout = setTimeout(() => {
                    el.textContent = '';
                    toastTimeout = null;
                }, 5000);
            }
        }
        
        // ===== STACKING ALGORITHM =====
        function assignStackPositions(breakers) {
            if (!breakers.length) return [];
            
            const sorted = [...breakers].sort((a, b) => a.startMin - b.startMin);
            const stackEnds = [];
            
            sorted.forEach(b => {
                let stackIdx = 0;
                while (stackIdx < stackEnds.length && stackEnds[stackIdx] > b.startMin) {
                    stackIdx++;
                }
                
                b.stackIdx = stackIdx;
                stackEnds[stackIdx] = b.endMin + 1;
            });
            
            return sorted;
        }
        
        // ===== WINDOW MANAGEMENT =====
        function setWindow(startMin, endMin, label) {
            windowStartMin = startMin;
            windowEndMin = endMin;
            
            updateViewportIndicator();
        }
        
        function updateMiniTimeline() {
            updateViewportIndicator();
        }
        
        function setMode(mode) {
            isLive = (mode === 'live');
            
            const exploreBtn = document.getElementById('mode-explore');
            const liveBtn = document.getElementById('mode-live');
            
            if (isLive) {
                liveBtn.classList.remove('inactive');
                exploreBtn.classList.remove('explore-active');
                exploreBtn.classList.add('inactive');
                // Show live confluence if data exists and nothing locked
                if (allData.length > 0 && lockedConfluenceMin === null) {
                    showLiveConfluence();
                }
            } else {
                exploreBtn.classList.remove('inactive');
                exploreBtn.classList.add('explore-active');
                liveBtn.classList.add('inactive');
                // Clear live highlights
                clearLiveHighlight();
                // Only show empty panel if nothing locked
                if (lockedConfluenceMin === null) {
                    showEmptyPanel();
                }
            }
            
            loadData();
        }
        
        function goToLatest() {
            if (dataMaxTime === 0) {
                showToast('No data loaded', 'error');
                return;
            }
            
            const container = document.getElementById('scroll-container');
            container.scrollLeft = container.scrollWidth;
        }
        
        function shiftWindow(direction) {
            if (dataMinTime === 0 || dataMaxTime === 0) {
                showToast('No data loaded', 'error');
                return;
            }
            
            const windowHours = getLoadHours();
            const shift = direction * windowHours * 60;
            let newStart = windowStartMin + shift;
            let newEnd = windowEndMin + shift;
            
            if (newStart < dataMinTime) {
                newStart = dataMinTime;
                newEnd = newStart + windowHours * 60;
            }
            if (newEnd > dataMaxTime) {
                newEnd = dataMaxTime;
                newStart = Math.max(dataMinTime, newEnd - windowHours * 60);
            }
            
            if (newStart === windowStartMin && newEnd === windowEndMin) {
                showToast('No more data in that direction', 'error');
                return;
            }
            
            windowStartMin = newStart;
            windowEndMin = newEnd;
            setWindow(windowStartMin, windowEndMin, 'Custom ' + windowHours + 'hr');
            renderChart();
            
            setTimeout(() => {
                const container = document.getElementById('scroll-container');
                if (direction > 0) {
                    container.scrollLeft = 0;
                } else {
                    container.scrollLeft = container.scrollWidth;
                }
            }, 50);
        }
        
        function advanceLiveWindow() {
            // Get current time in minutes (matching how datetimeToMin works)
            const now = new Date();
            const nowMin = Math.floor(now.getTime() / 60000);
            
            // Extend dataMaxTime to now if it's behind
            if (nowMin > dataMaxTime) {
                dataMaxTime = nowMin;
            }
            
            // In live mode, keep window at the latest edge
            const windowSize = windowEndMin - windowStartMin;
            windowEndMin = dataMaxTime;
            windowStartMin = Math.max(dataMinTime, dataMaxTime - windowSize);
            
            setWindow(windowStartMin, windowEndMin, 'Live');
            renderChart();
            
            // Scroll to right edge and show live confluence (only if nothing locked)
            setTimeout(() => {
                const container = document.getElementById('scroll-container');
                container.scrollLeft = container.scrollWidth;
                if (lockedConfluenceMin === null) {
                    showLiveConfluence();
                }
            }, 50);
        }
        
        // ===== FILTERS =====
        function toggleFilter(key) {
            filters[key] = !filters[key];
            // Convert camelCase to kebab-case for button ID
            const btnId = 'filter-' + key.replace(/([A-Z])/g, '-$1').toLowerCase();
            const btn = document.getElementById(btnId);
            if (btn) btn.classList.toggle('active', filters[key]);
            renderChart();
        }
        
        // ===== DATA LOADING =====
        function getLoadHours() {
            const el = document.getElementById('load-limit');
            return el ? parseInt(el.value) : 8;
        }
        
        function loadData(forceFullLoad = false) {
            const currentHours = getLoadHours();
            
            const needsFullLoad = forceFullLoad || 
                                  !lastFetchedTime || 
                                  lastLoadLimit !== currentHours ||
                                  Object.keys(breakerCache).length === 0;
            
            lastLoadLimit = currentHours;
            
            if (needsFullLoad) {
                // Full load with server-side time filtering
                showToast('Loading...', '');
                
                // Also reload SMT data
                loadSmtData();
                
                // For multi-day loads during market closures, always use fallback
                // (indexed query uses wall clock time which misses old data when market is closed)
                const useFullLoad = currentHours >= 24;
                
                if (useFullLoad) {
                    // Load all data and filter client-side based on LATEST DATA TIME
                    console.log(`📊 Loading ${currentHours} hours - using full load for accuracy`);
                    
                    fetch(FIREBASE_URL)
                        .then(r => {
                            if (!r.ok) throw new Error('HTTP ' + r.status);
                            return r.json();
                        })
                        .then(data => {
                            if (!data) throw new Error('No data');
                            
                            // Snapshot key IS the timestamp (e.g. "2026-01-21T0731")
                            // Convert to entries with observation_time from key
                            let entries = Object.entries(data)
                                .filter(([k, v]) => v && typeof v === 'object')
                                .map(([k, v]) => {
                                    // Convert key "2026-01-21T0731" to "2026-01-21T07:31"
                                    let obsTime = k;
                                    if (k.match(/^\d{4}-\d{2}-\d{2}T\d{4}$/)) {
                                        obsTime = k.slice(0, 13) + ':' + k.slice(13);
                                    }
                                    return [k, { ...v, observation_time: obsTime }];
                                });
                            
                            if (entries.length === 0) throw new Error('No valid data');
                            
                            // Find the latest observation time
                            let latestTime = '';
                            let earliestTime = 'Z';
                            entries.forEach(([k, v]) => {
                                if (v.observation_time > latestTime) latestTime = v.observation_time;
                                if (v.observation_time < earliestTime) earliestTime = v.observation_time;
                            });
                            
                            console.log(`📊 Full data range: ${earliestTime} to ${latestTime}`);
                            
                            // Calculate cutoff from LATEST DATA TIME (not wall clock)
                            const latestMin = datetimeToMin(latestTime);
                            const cutoffMin = latestMin - (currentHours * 60);
                            
                            console.log(`📊 Filtering to ${currentHours} hours before latest data (cutoff: ${minToDateTime(cutoffMin)})`);
                            
                            // Filter to only include snapshots within time range
                            const beforeFilter = entries.length;
                            entries = entries.filter(([k, v]) => {
                                const snapMin = datetimeToMin(v.observation_time);
                                return snapMin >= cutoffMin;
                            });
                            
                            console.log(`📊 After filter: ${entries.length} snapshots (removed ${beforeFilter - entries.length})`);
                            
                            // Sort by time
                            entries.sort((a, b) => {
                                const tsA = a[1].observation_time || '';
                                const tsB = b[1].observation_time || '';
                                return tsA.localeCompare(tsB);
                            });
                            
                            const limited = {};
                            entries.forEach(([k, v]) => limited[k] = v);
                            
                            processFirebaseData(limited, true);
                        })
                        .catch(err => {
                            showToast('Error: ' + err.message, 'error');
                            console.error(err);
                        });
                } else {
                    // For short time ranges (<24h), use indexed query with wall clock time
                    // Since the key IS the timestamp now, we need to filter differently
                    const now = new Date();
                    const cutoffDate = new Date(now.getTime() - (currentHours * 60 * 60 * 1000));
                    
                    const pad = n => n.toString().padStart(2, '0');
                    // Key format is "2026-01-21T0731" (no colon in time)
                    const cutoffKey = `${cutoffDate.getFullYear()}-${pad(cutoffDate.getMonth()+1)}-${pad(cutoffDate.getDate())}T${pad(cutoffDate.getHours())}${pad(cutoffDate.getMinutes())}`;
                    
                    console.log(`📊 Loading ${currentHours} hours of data`);
                    console.log(`📊 Cutoff key: ${cutoffKey}`);
                    
                    // Query by key (since key IS the timestamp)
                    const filteredUrl = FIREBASE_URL + 
                        '?orderBy="$key"&startAt="' + cutoffKey + '"';
                    
                    fetch(filteredUrl)
                        .then(r => {
                            if (!r.ok) throw new Error('HTTP ' + r.status);
                            return r.json();
                        })
                        .then(data => {
                            if (!data) throw new Error('No data');
                            
                            // Convert keys to observation_time
                            let entries = Object.entries(data)
                                .filter(([k, v]) => v && typeof v === 'object')
                                .map(([k, v]) => {
                                    let obsTime = k;
                                    if (k.match(/^\d{4}-\d{2}-\d{2}T\d{4}$/)) {
                                        obsTime = k.slice(0, 13) + ':' + k.slice(13);
                                    }
                                    return [k, { ...v, observation_time: obsTime }];
                                });
                            
                            if (entries.length === 0) throw new Error('No valid data');
                            
                            const times = entries.map(([k, v]) => v.observation_time).sort();
                            console.log(`✓ Query returned ${entries.length} snapshots`);
                            console.log(`✓ Data range: ${times[0]} to ${times[times.length-1]}`);
                            
                            entries.sort((a, b) => {
                                const tsA = a[1].observation_time || '';
                                const tsB = b[1].observation_time || '';
                                return tsA.localeCompare(tsB);
                            });
                            
                            const limited = {};
                            entries.forEach(([k, v]) => limited[k] = v);
                            
                            processFirebaseData(limited, true);
                        })
                        .catch(err => {
                            showToast('Error: ' + err.message, 'error');
                            console.error(err);
                        });
                }
            } else {
                // Incremental load - only fetch newer data from Firebase
                // Also refresh SMT data incrementally
                loadSmtData(true);
                
                // Convert lastFetchedTime from "2026-01-21T07:31" to key format "2026-01-21T0731"
                const lastKey = lastFetchedTime ? lastFetchedTime.replace(':', '') : '';
                const url = FIREBASE_URL + 
                    '?orderBy="$key"&startAfter="' + lastKey + '"';
                
                console.log('Incremental fetch:', url);
                
                fetch(url)
                    .then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.json();
                    })
                    .then(data => {
                        if (!data || Object.keys(data).length === 0) {
                            // In Live mode, advance window to current time even if no data
                            if (isLive) {
                                advanceLiveWindow();
                                showToast('Live - no new data', '');
                            } else {
                                showToast('No new data', '');
                            }
                            return;
                        }
                        
                        // Convert keys to snapshots with observation_time
                        const converted = {};
                        Object.entries(data).forEach(([k, v]) => {
                            if (v && typeof v === 'object') {
                                let obsTime = k;
                                if (k.match(/^\d{4}-\d{2}-\d{2}T\d{4}$/)) {
                                    obsTime = k.slice(0, 13) + ':' + k.slice(13);
                                }
                                converted[k] = { ...v, observation_time: obsTime };
                            }
                        });
                        
                        console.log('Incremental data:', Object.keys(converted).length, 'snapshots');
                        processIncrementalData(converted);
                    })
                    .catch(err => {
                        // If query fails (no index), show error with instructions
                        console.error('Incremental fetch failed:', err);
                        showToast('Index needed - see console', 'error');
                    });
            }
        }
        
        function processFirebaseData(snapshots, isFullLoad = true) {
            if (isFullLoad) {
                breakerCache = {}; // Reset cache on full load
            }
            
            let snapshotList = Array.isArray(snapshots) 
                ? snapshots 
                : Object.values(snapshots).filter(s => s);
            
            if (snapshotList.length === 0) {
                showToast('No data', 'error');
                return;
            }
            
            snapshotList.sort((a, b) => {
                const tsA = a.observation_time || '';
                const tsB = b.observation_time || '';
                return tsA.localeCompare(tsB);
            });
            
            // Track the latest observation time for incremental fetches
            const latestSnap = snapshotList[snapshotList.length - 1];
            lastFetchedTime = latestSnap.observation_time;
            
            let minTime = Infinity, maxTime = 0;
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                if (ts) {
                    const min = datetimeToMin(ts);
                    if (min < minTime) minTime = min;
                    if (min > maxTime) maxTime = min;
                }
            });
            
            dataMinTime = minTime;
            dataMaxTime = maxTime;
            
            console.log(`📊 Processing ${snapshotList.length} snapshots`);
            console.log(`📊 Time range: ${minToDateTime(minTime)} to ${minToDateTime(maxTime)}`);
            console.log(`📊 Duration: ${((maxTime - minTime) / 60).toFixed(1)} hours`);
            
            // Show all loaded data (use load limit, not hardcoded 8hr)
            windowEndMin = dataMaxTime;
            windowStartMin = dataMinTime;
            
            setWindow(windowStartMin, windowEndMin, 'Latest');
            
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                const datetime = ts.replace('T', ' ');
                const absMin = datetimeToMin(ts);
                
                // Breakers are direct children of snapshot (not under 'breakers' key)
                Object.entries(snap).forEach(([id, b]) => {
                    // Skip non-breaker fields
                    if (id === 'observation_time' || typeof b !== 'object' || !b) return;
                    
                    // Parse all fields from breaker ID
                    // Format: ES-15m-260120T1000-260121T0715-6865-24p-S
                    const idParts = id.split('-');
                    const symbol = idParts[0] || 'ES';
                    const tf = idParts[1] || '1m';
                    const dir = idParts[idParts.length - 1] === 'S' ? 'bear' : 'bull';
                    const formationTime = idParts[2] || ''; // e.g., "260120T1000"
                    const confirmationTime = idParts[3] || ''; // e.g., "260121T0715"
                    const price = parseInt(idParts[4]) || 0; // e.g., "6865"
                    const pointsStr = idParts[5] || ''; // e.g., "24p"
                    const points = parseInt(pointsStr.replace('p', '')) || 0;
                    
                    if (!breakerCache[id]) {
                        breakerCache[id] = {
                            id,
                            displayId: b.display_id || id,
                            symbol: symbol.toUpperCase(),
                            tf: tf.toLowerCase(),
                            dir: dir.toLowerCase(),
                            price: price,
                            points: points,
                            formationTime: formationTime,
                            confirmationTime: confirmationTime,
                            status: 'active',
                            events: [],
                            currentFib: 0,
                            maxFib: 0
                        };
                    }
                    
                    // Update display_id if we get a newer one
                    if (b.display_id) {
                        breakerCache[id].displayId = b.display_id;
                    }
                    
                    // Parse fib - "current/max" string format
                    let currentFib = 0, maxFib = 0;
                    try {
                        const fibStr = String(b.fib || '0/0');
                        const [curr, max] = fibStr.split('/').map(parseFloat);
                        currentFib = curr || 0;
                        maxFib = max || curr || 0;
                    } catch (e) {
                    }
                    
                    // Get snapshot price
                    const snapshotPrice = b.price || 0;
                    
                    // Avoid duplicate events (same timestamp)
                    if (!breakerCache[id].events.some(e => e.absMin === absMin)) {
                        breakerCache[id].events.push({ datetime, absMin, fib: currentFib, maxFib: maxFib, price: snapshotPrice });
                    }
                    breakerCache[id].currentFib = currentFib;
                    breakerCache[id].maxFib = Math.max(breakerCache[id].maxFib, maxFib);
                    
                    if (b.status === 'success' || b.status?.startsWith('failed:')) {
                        breakerCache[id].status = b.status;
                    }
                });
            });
            
            
            finalizeBreakers();
            
            showToast('Loaded ' + allData.length + ' breakers', 'success');
        }
        
        function processIncrementalData(snapshots) {
            let snapshotList = Array.isArray(snapshots) 
                ? snapshots 
                : Object.values(snapshots).filter(s => s);
            
            if (snapshotList.length === 0) {
                showToast('No new data', '');
                return;
            }
            
            snapshotList.sort((a, b) => {
                const tsA = a.observation_time || '';
                const tsB = b.observation_time || '';
                return tsA.localeCompare(tsB);
            });
            
            // Update lastFetchedTime
            const latestSnap = snapshotList[snapshotList.length - 1];
            lastFetchedTime = latestSnap.observation_time;
            
            // Update max time
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                if (ts) {
                    const min = datetimeToMin(ts);
                    if (min > dataMaxTime) dataMaxTime = min;
                }
            });
            
            // Merge into cache
            let newBreakers = 0;
            
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                const datetime = ts.replace('T', ' ');
                const absMin = datetimeToMin(ts);
                
                // Breakers are direct children of snapshot (not under 'breakers' key)
                Object.entries(snap).forEach(([id, b]) => {
                    // Skip non-breaker fields
                    if (id === 'observation_time' || typeof b !== 'object' || !b) return;
                    
                    // Parse all fields from breaker ID
                    // Format: ES-15m-260120T1000-260121T0715-6865-24p-S
                    const idParts = id.split('-');
                    const symbol = idParts[0] || 'ES';
                    const tf = idParts[1] || '1m';
                    const dir = idParts[idParts.length - 1] === 'S' ? 'bear' : 'bull';
                    const formationTime = idParts[2] || '';
                    const confirmationTime = idParts[3] || '';
                    const price = parseInt(idParts[4]) || 0;
                    const pointsStr = idParts[5] || '';
                    const points = parseInt(pointsStr.replace('p', '')) || 0;
                    
                    if (!breakerCache[id]) {
                        breakerCache[id] = {
                            id,
                            displayId: b.display_id || id,
                            symbol: symbol.toUpperCase(),
                            tf: tf.toLowerCase(),
                            dir: dir.toLowerCase(),
                            price: price,
                            points: points,
                            formationTime: formationTime,
                            confirmationTime: confirmationTime,
                            status: 'active',
                            events: [],
                            currentFib: 0,
                            maxFib: 0
                        };
                        newBreakers++;
                    }
                    
                    // Update display_id if we get a newer one
                    if (b.display_id) {
                        breakerCache[id].displayId = b.display_id;
                    }
                    
                    // Parse fib - "current/max" string format
                    let currentFib = 0, maxFib = 0;
                    try {
                        const fibStr = String(b.fib || '0/0');
                        const [curr, max] = fibStr.split('/').map(parseFloat);
                        currentFib = curr || 0;
                        maxFib = max || curr || 0;
                    } catch (e) {
                    }
                    
                    // Get snapshot price
                    const snapshotPrice = b.price || 0;
                    
                    // Avoid duplicate events (same timestamp)
                    if (!breakerCache[id].events.some(e => e.absMin === absMin)) {
                        breakerCache[id].events.push({ datetime, absMin, fib: currentFib, maxFib: maxFib, price: snapshotPrice });
                    }
                    breakerCache[id].currentFib = currentFib;
                    breakerCache[id].maxFib = Math.max(breakerCache[id].maxFib, maxFib);
                    
                    if (b.status === 'success' || b.status?.startsWith('failed:')) {
                        breakerCache[id].status = b.status;
                    }
                });
            });
            
            // Update window to include new data
            // In live mode, keep window size fixed and slide it
            if (isLive) {
                const windowSize = windowEndMin - windowStartMin;
                windowEndMin = dataMaxTime;
                windowStartMin = Math.max(dataMinTime, dataMaxTime - windowSize);
            } else {
                windowEndMin = dataMaxTime;
            }
            setWindow(windowStartMin, windowEndMin, 'Latest');
            
            finalizeBreakers();
            
            showToast(`+${snapshotList.length} snapshots, ${newBreakers} new breakers`, 'success');
        }
        
        // Prune data outside retention window to prevent memory growth
        function pruneOldData() {
            if (dataMaxTime === 0) return;
            
            // Use load limit + 30 min buffer as retention window
            const loadHours = getLoadHours();
            const retentionMinutes = (loadHours * 60) + 30;
            const cutoffMin = dataMaxTime - retentionMinutes;
            
            console.log(`📊 Prune check: retention=${loadHours}h, cutoff=${minToDateTime(cutoffMin)}, maxTime=${minToDateTime(dataMaxTime)}`);
            
            let pruned = 0;
            
            for (const id in breakerCache) {
                const breaker = breakerCache[id];
                // Remove breakers that ended before the cutoff
                if (breaker.endMin && breaker.endMin < cutoffMin) {
                    delete breakerCache[id];
                    pruned++;
                }
            }
            
            // Update dataMinTime
            if (pruned > 0) {
                const remaining = Object.values(breakerCache);
                if (remaining.length > 0) {
                    dataMinTime = Math.min(...remaining.map(d => d.startMin || d.events[0]?.absMin || dataMaxTime));
                }
            }
        }
        
        // Parse confirmation time from breaker ID
        // Format: ES-15m-260120T1000-260121T0715-6865-24p-S
        //                            ^^^^^^^^^^^^^ confirmation time
        function parseConfirmationTime(breakerId) {
            const parts = breakerId.split('-');
            // parts: [asset, tf, formationTime, confirmationTime, price, range, dir]
            if (parts.length >= 4) {
                const confTime = parts[3]; // e.g. "260121T0715"
                // Parse: YYMMDDTHHMM
                const match = confTime.match(/^(\d{2})(\d{2})(\d{2})T(\d{2})(\d{2})$/);
                if (match) {
                    const [_, yy, mm, dd, hh, min] = match;
                    const year = 2000 + parseInt(yy);
                    const month = parseInt(mm);
                    const day = parseInt(dd);
                    const hour = parseInt(hh);
                    const minute = parseInt(min);
                    // Convert to absolute minutes
                    return datetimeToMin(`${year}-${String(month).padStart(2,'0')}-${String(day).padStart(2,'0')}T${String(hour).padStart(2,'0')}:${String(minute).padStart(2,'0')}`);
                }
            }
            return null;
        }
        
        function finalizeBreakers() {
            
            // First, set startMin/endMin on all breakers in cache
            for (const id in breakerCache) {
                const d = breakerCache[id];
                if (d.events.length > 0) {
                    d.events.sort((a, b) => a.absMin - b.absMin);
                    
                    // Try to get confirmation time from breaker ID
                    const confirmMin = parseConfirmationTime(id);
                    if (confirmMin) {
                        d.startMin = confirmMin;
                    } else {
                        // Fallback to first observation
                        d.startMin = d.events[0]?.absMin || 0;
                    }
                    d.endMin = d.events[d.events.length - 1]?.absMin || 0;
                    
                    // Ensure startMin <= endMin
                    if (d.startMin > d.endMin) {
                        d.endMin = d.startMin;
                    }
                }
            }
            
            const beforePrune = Object.keys(breakerCache).length;
            
            // Prune old data (needs endMin to be set first)
            pruneOldData();
            
            const afterPrune = Object.keys(breakerCache).length;
            if (beforePrune !== afterPrune) {
                console.log(`📊 Pruned ${beforePrune - afterPrune} old breakers`);
            }
            
            allData = Object.values(breakerCache);
            allData.forEach(d => {
                // Limit events per breaker to prevent huge fib charts
                if (d.events.length > 500) {
                    d.events = d.events.slice(-500);
                }
                // Use symbol from cache (parsed from ID during load)
                if (!d.symbol) {
                    d.symbol = d.id.toUpperCase().includes('NQ') ? 'NQ' : 'ES';
                }
            });
            
            // Extract 1M NQ Bull entry times
            entryTimes = allData
                .filter(d => d.symbol === 'NQ' && d.tf === '1m' && d.dir === 'bull')
                .map(d => d.startMin);
            
            updateStats();
            renderChart();
            
            // Refresh confluence modal if open
            if (confluenceModalOpen) {
                // Save scroll position before re-rendering
                const scroll = document.getElementById('confluence-scroll');
                const savedScrollLeft = scroll ? scroll.scrollLeft : 0;
                
                renderConfluenceModal();
                
                // Restore scroll position (or scroll to end in live mode on first load only)
                setTimeout(() => {
                    const scrollEl = document.getElementById('confluence-scroll');
                    if (scrollEl) {
                        scrollEl.scrollLeft = savedScrollLeft;
                    }
                }, 10);
            }
            
            // In live mode: always scroll to latest and show live confluence
            // In explore mode: only scroll on first load
            if (isLive || isFirstLoad) {
                setTimeout(() => {
                    const container = document.getElementById('scroll-container');
                    container.scrollLeft = container.scrollWidth;
                    updateViewportIndicator();
                    // Only show live confluence if nothing locked
                    if (isLive && lockedConfluenceMin === null) {
                        showLiveConfluence();
                    }
                }, 50);
                isFirstLoad = false;
            }
        }
        
        // ===== STATS =====
        function updateStats() {
            // Calculate overall stats (NQ Bull 1M only - the primary trading signal)
            const primary = { success: 0, fail: 0 };
            
            // Calculate stats per tf/symbol/direction
            laneStats = {};
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    ['bull', 'bear'].forEach(dir => {
                        laneStats[`${tf}-${symbol}-${dir}`] = { success: 0, fail: 0 };
                    });
                });
            });
            
            allData.forEach(d => {
                const status = d.status.toLowerCase();
                const tf = d.tf.replace('hr', 'h');
                const key = `${tf}-${d.symbol}-${d.dir}`;
                const isFailed = status?.startsWith('failed:');
                
                // Primary stats: NQ Bull 1M only
                if (tf === '1m' && d.symbol === 'NQ' && d.dir === 'bull') {
                    if (status === 'success') primary.success++;
                    else if (isFailed) primary.fail++;
                }
                
                // Per-lane stats
                if (laneStats[key]) {
                    if (status === 'success') laneStats[key].success++;
                    else if (isFailed) laneStats[key].fail++;
                }
            });
            
            const completed = primary.success + primary.fail;
            const winRate = completed > 0 ? Math.round(primary.success / completed * 100) : 0;
            
            document.getElementById('stat-success').textContent = primary.success;
            document.getElementById('stat-fail').textContent = primary.fail;
            document.getElementById('stat-winrate').textContent = winRate + '%';
        }
        
        function getLaneStats(tf, symbol, dir) {
            const key = `${tf}-${symbol}-${dir}`;
            const stats = laneStats[key] || { success: 0, fail: 0 };
            const total = stats.success + stats.fail;
            const pct = total > 0 ? Math.round(stats.success / total * 100) : 0;
            return { wins: stats.success, losses: stats.fail, total, pct };
        }
        
        // ===== RENDERING =====
        function renderChart() {
            // Clean up previous event listeners
            if (chartAbortController) {
                chartAbortController.abort();
                chartAbortController = null;
            }
            chartAbortController = new AbortController();
            const signal = chartAbortController.signal;
            
            const leftPanel = document.getElementById('left-panel');
            const chartInner = document.getElementById('chart-inner');
            const timeHeader = document.getElementById('time-header');
            
            leftPanel.innerHTML = '';
            chartInner.innerHTML = '';
            timeHeader.innerHTML = '';
            
            // Clear cached element arrays
            renderedBars = [];
            renderedLaneLabels = [];
            
            // Preserve selections across re-renders (both explore and live mode)
            const preservedEntryMin = selectedEntryMin;
            const preservedBreakerId = selectedBreakerId;
            const preservedSmtId = selectedSmtId;
            
            selectedEntryMin = null;
            selectedBreakerId = null;
            selectedSmtId = null;
            
            // Calculate chart width based on data, add padding for future fade effect
            const chartWidth = (windowEndMin - windowStartMin) * PIXELS_PER_MINUTE + (PIXELS_PER_MINUTE * 2);
            
            chartInner.style.width = chartWidth + 'px';
            timeHeader.style.width = chartWidth + 'px';
            
            // Time header ticks - snap to 5-minute boundaries
            const tickInterval = 5;
            const firstTick = Math.ceil(windowStartMin / tickInterval) * tickInterval;
            
            // Track dates for separators
            let lastDateKey = null;
            const dateSeparators = []; // Store positions for chart separators
            
            // For multi-day views, show date in time labels
            const loadHours = getLoadHours();
            const showDateInLabels = loadHours >= 24;
            
            for (let m = firstTick; m <= windowEndMin; m += tickInterval) {
                const x = (m - windowStartMin) * PIXELS_PER_MINUTE;
                const currentDateKey = minToDateKey(m);
                
                // Add date separator when day changes
                if (lastDateKey !== null && currentDateKey !== lastDateKey) {
                    // Store for chart vertical line
                    dateSeparators.push({ x: x, date: minToDateStr(m) });
                }
                lastDateKey = currentDateKey;
                
                const tick = document.createElement('div');
                tick.className = 'time-tick-label';
                tick.style.left = x + 'px';
                
                // Show date+time for multi-day views, just time for single day
                if (showDateInLabels) {
                    tick.textContent = minToShortDateTime(m);
                } else {
                    tick.textContent = minToTime(m);
                }
                timeHeader.appendChild(tick);
            }
            
            // Add date separators to chart (vertical lines spanning full height)
            dateSeparators.forEach(sep => {
                const line = document.createElement('div');
                line.className = 'date-separator';
                line.style.left = sep.x + 'px';
                chartInner.appendChild(line);
            });
            
            // Store date separators for sticky date calculation
            window.dateSeparatorPositions = dateSeparators;
            
            // Filter data for window
            let windowData = allData.filter(d => {
                if (d.endMin < windowStartMin || d.startMin > windowEndMin) return false;
                if (d.symbol === 'NQ' && !filters.nq) return false;
                if (d.symbol === 'ES' && !filters.es) return false;
                if (d.dir === 'bull' && !filters.bull) return false;
                if (d.dir === 'bear' && !filters.bear) return false;
                return true;
            });
            
            // Limit total bars to prevent browser crash (prioritize recent)
            const MAX_BARS = 500;
            if (windowData.length > MAX_BARS) {
                windowData.sort((a, b) => b.endMin - a.endMin);
                windowData = windowData.slice(0, MAX_BARS);
            }
            
            // Group by TF → Symbol
            const grouped = {};
            TF_ORDER.forEach(tf => {
                grouped[tf] = { NQ: [], ES: [] };
            });
            
            windowData.forEach(d => {
                const tf = d.tf.replace('hr', 'h');
                if (grouped[tf] && grouped[tf][d.symbol]) {
                    grouped[tf][d.symbol].push(d);
                }
            });
            
            // Determine which symbols are visible
            const visibleSymbols = SYMBOLS.filter(s => filters[s.toLowerCase()]);
            
            let totalHeight = 0;
            
            // Render TF sections
            TF_ORDER.forEach((tf, tfIndex) => {
                // TF divider spacer for left panel (matches chart divider height)
                const tfSpacer = document.createElement('div');
                tfSpacer.className = 'tf-spacer';
                tfSpacer.dataset.tf = tf;
                leftPanel.appendChild(tfSpacer);
                
                // TF divider - chart
                const tfHeaderChart = document.createElement('div');
                tfHeaderChart.className = 'tf-header-chart';
                // Width set via CSS to be viewport-based
                tfHeaderChart.dataset.tf = tf;
                chartInner.appendChild(tfHeaderChart);
                
                // TF_HEADER_HEIGHT for divider
                totalHeight += TF_HEADER_HEIGHT;
                
                // Calculate lane heights for all symbols in this TF first
                const laneHeights = {};
                let tfGroupHeight = 0;
                
                visibleSymbols.forEach((symbol, idx) => {
                    const breakers = grouped[tf][symbol];
                    const stackedBreakers = assignStackPositions(breakers);
                    const maxStack = stackedBreakers.length > 0 
                        ? Math.max(...stackedBreakers.map(b => b.stackIdx)) + 1 
                        : 1;
                    
                    // Calculate height needed for breaker stacking
                    const breakerStackHeight = LANE_PADDING * 2 + maxStack * (BAR_HEIGHT + BAR_GAP) - BAR_GAP;
                    
                    // Use the larger of left panel minimum or breaker stack needs
                    const laneHeight = Math.max(LEFT_PANEL_MIN_HEIGHT, breakerStackHeight);
                    
                    laneHeights[symbol] = laneHeight;
                    tfGroupHeight += laneHeight;
                });
                
                // Create TF group container for left panel
                const tfGroup = document.createElement('div');
                tfGroup.className = 'tf-group';
                // Height determined by children via flexbox
                tfGroup.dataset.tf = tf;
                
                // TF accent bar spanning all symbols
                const tfLabel = tf.toUpperCase();
                const tfAccent = document.createElement('div');
                tfAccent.className = 'tf-group-accent';
                tfAccent.dataset.tf = tf;
                tfAccent.textContent = tfLabel;
                tfGroup.appendChild(tfAccent);
                
                // Lanes container
                const tfLanes = document.createElement('div');
                tfLanes.className = 'tf-group-lanes';
                
                // Symbol lanes within this TF
                visibleSymbols.forEach((symbol, symbolIdx) => {
                    const breakers = grouped[tf][symbol];
                    const stackedBreakers = assignStackPositions(breakers);
                    const laneHeight = laneHeights[symbol];
                    
                    // Get stats for this lane
                    const bullStats = getLaneStats(tf, symbol, 'bull');
                    const bearStats = getLaneStats(tf, symbol, 'bear');
                    
                    // Lane row
                    const laneRow = document.createElement('div');
                    laneRow.className = 'lane-row';
                    // Only set explicit height if breakers need more than minimum
                    if (laneHeight > LEFT_PANEL_MIN_HEIGHT) {
                        laneRow.style.height = laneHeight + 'px';
                    }
                    laneRow.dataset.tf = tf;
                    laneRow.dataset.symbol = symbol;
                    
                    // Horizontal layout: symbol left, stats right
                    laneRow.innerHTML = `
                        <span class="symbol-badge ${symbol.toLowerCase()}">${symbol}</span>
                        <div class="lane-stats">
                            <div class="lane-stat-row">
                                <span class="lane-stat-dir bull"></span>
                                <span class="lane-stat-counts">${bullStats.wins}/${bullStats.losses}</span>
                                <div class="lane-stat-bar">
                                    <div class="lane-stat-fill bull" style="width: ${bullStats.pct}%"></div>
                                </div>
                                <span class="lane-stat-pct ${bullStats.total > 0 ? 'bull' : 'neutral'}">${bullStats.total > 0 ? bullStats.pct + '%' : '-'}</span>
                            </div>
                            <div class="lane-stat-row">
                                <span class="lane-stat-dir bear"></span>
                                <span class="lane-stat-counts">${bearStats.wins}/${bearStats.losses}</span>
                                <div class="lane-stat-bar">
                                    <div class="lane-stat-fill bear" style="width: ${bearStats.pct}%"></div>
                                </div>
                                <span class="lane-stat-pct ${bearStats.total > 0 ? 'bear' : 'neutral'}">${bearStats.total > 0 ? bearStats.pct + '%' : '-'}</span>
                            </div>
                        </div>
                    `;
                    
                    tfLanes.appendChild(laneRow);
                    
                    // Cache lane row for highlighting
                    renderedLaneLabels.push({ el: laneRow, tf: tf, symbol: symbol });
                    
                    // Swimlane
                    const swimlane = document.createElement('div');
                    swimlane.className = 'swimlane';
                    swimlane.style.width = chartWidth + 'px';
                    // Only set explicit height if breakers need more than minimum
                    if (laneHeight > LEFT_PANEL_MIN_HEIGHT) {
                        swimlane.style.height = laneHeight + 'px';
                    }
                    swimlane.dataset.symbol = symbol;
                    swimlane.dataset.tf = tf;
                    
                    // Render breaker bars with stacking
                    stackedBreakers.forEach(b => {
                        const bar = createBreakerBar(b, laneHeight);
                        swimlane.appendChild(bar);
                        // Cache bar with its time data for fast highlight
                        renderedBars.push({
                            el: bar,
                            startMin: b.startMin,
                            endMin: b.endMin,
                            tf: tf,
                            symbol: symbol
                        });
                    });
                    
                    // Render SMT markers in defensive asset lane
                    const tfNorm = tf.replace('hr', 'h').toLowerCase();
                    const smtForLane = smtData.filter(smt => {
                        const smtTfNorm = smt.tf.replace('m', 'm').replace('h', 'h').toLowerCase();
                        return smtTfNorm === tfNorm && 
                               smt.defensiveAsset === symbol &&
                               smt.smtMin >= windowStartMin && 
                               smt.smtMin <= windowEndMin;
                    });
                    
                    smtForLane.forEach(smt => {
                        const marker = createSmtMarker(smt, 0, laneHeight);
                        swimlane.appendChild(marker);
                    });
                    
                    chartInner.appendChild(swimlane);
                    totalHeight += laneHeight;
                });
                
                tfGroup.appendChild(tfLanes);
                leftPanel.appendChild(tfGroup);
            });
            
            // Render entry lines spanning full chart height
            // Subtract a few pixels for perfect alignment
            totalHeight -= 3;
            
            const windowEntries = entryTimes
                .filter(t => t >= windowStartMin && t <= windowEndMin)
                .slice(-100); // Limit entry lines
            
            windowEntries.forEach(entryMin => {
                const x = (entryMin - windowStartMin) * PIXELS_PER_MINUTE;
                
                // Entry line in chart
                const entryLine = document.createElement('div');
                entryLine.className = 'entry-line';
                entryLine.style.left = x + 'px';
                entryLine.style.height = totalHeight + 'px';
                entryLine.dataset.entryMin = entryMin;
                entryLine.title = 'Entry: ' + minToTime(entryMin);
                entryLine.onclick = () => selectEntry(entryMin);
                chartInner.appendChild(entryLine);
            });
            
            // Add cursor line
            const cursorLine = document.createElement('div');
            cursorLine.className = 'cursor-line';
            cursorLine.id = 'cursor-line';
            cursorLine.style.height = totalHeight + 'px';
            chartInner.appendChild(cursorLine);
            
            // Set chart inner height so absolute positioned elements span correctly
            chartInner.style.height = totalHeight + 'px';
            
            // Add cursor time tooltip to body (so it's not clipped)
            let cursorTime = document.getElementById('cursor-time');
            if (!cursorTime) {
                cursorTime = document.createElement('div');
                cursorTime.className = 'cursor-time';
                cursorTime.id = 'cursor-time';
                document.body.appendChild(cursorTime);
            }
            
            // Cursor line event handlers on scroll container
            const scrollContainer = document.getElementById('scroll-container');
            let lastClientX = null;
            let lastCursorMin = null;
            let cursorUpdatePending = false;
            
            function updateCursorPosition(clientX, isScroll = false) {
                const scrollRect = scrollContainer.getBoundingClientRect();
                const leftPanelWidth = 195; // matches .left-panel width
                
                // Check if mouse is actually over the chart area (not left panel)
                const mouseOverChart = clientX > scrollRect.left + leftPanelWidth;
                
                const x = clientX - scrollRect.left - leftPanelWidth + scrollContainer.scrollLeft;
                if (mouseOverChart && x >= 0 && x <= chartWidth) {
                    cursorLine.style.left = x + 'px';
                    cursorLine.classList.add('visible');
                    
                    // Calculate cursor time
                    const cursorMin = Math.round(windowStartMin + x / PIXELS_PER_MINUTE);
                    
                    // Always update tooltip position
                    cursorTime.textContent = minToTime(cursorMin);
                    cursorTime.style.display = 'block';
                    cursorTime.style.left = (clientX - 30) + 'px';
                    cursorTime.style.top = (scrollRect.top - 30) + 'px';
                    
                    // Only update panel and highlights if cursor minute changed
                    // Skip heavy operations during scroll - only update on mousemove
                    if (cursorMin !== lastCursorMin && !isScroll) {
                        lastCursorMin = cursorMin;
                        
                        // Show confluence at cursor position in right panel (only if not locked)
                        if (lockedConfluenceMin === null && !selectedSmtId) {
                            showCursorConfluence(cursorMin);
                        }
                        
                        // Highlight bars at cursor (yellow)
                        highlightCursorActive(cursorMin);
                    }
                } else {
                    cursorLine.classList.remove('visible');
                    cursorTime.style.display = 'none';
                    
                    // Clear cursor highlights when leaving chart area
                    if (!isScroll) {
                        clearCursorHighlight();
                    }
                }
            }
            
            scrollContainer.addEventListener('mousemove', (e) => {
                lastClientX = e.clientX;
                updateCursorPosition(e.clientX, false);
            }, { signal });
            
            scrollContainer.addEventListener('scroll', () => {
                if (lastClientX !== null && !cursorUpdatePending) {
                    cursorUpdatePending = true;
                    requestAnimationFrame(() => {
                        updateCursorPosition(lastClientX, true);
                        cursorUpdatePending = false;
                    });
                }
            }, { signal });
            
            scrollContainer.addEventListener('mouseleave', () => {
                lastClientX = null;
                cursorLine.classList.remove('visible');
                cursorTime.style.display = 'none';
                
                // Clear cursor highlights
                clearCursorHighlight();
                
                // Restore appropriate panel state
                if (lockedConfluenceMin !== null) {
                    // Keep locked confluence view
                    showCursorConfluence(lockedConfluenceMin);
                } else if (selectedSmtId) {
                    showSmtDetail(selectedSmtId);
                } else if (isLive) {
                    showLiveConfluence();
                } else {
                    showEmptyPanel();
                }
            }, { signal });
            
            // Click on chart to select time (but not on breakers or entry lines)
            chartInner.addEventListener('click', (e) => {
                // Only handle clicks directly on chart or swimlanes
                if (e.target.classList.contains('breaker-bar') || 
                    e.target.classList.contains('entry-line') ||
                    e.target.classList.contains('smt-marker') ||
                    e.target.closest('.breaker-bar') ||
                    e.target.closest('.entry-line') ||
                    e.target.closest('.smt-marker')) {
                    return;
                }
                
                const rect = chartInner.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const clickedMin = Math.round(windowStartMin + x / PIXELS_PER_MINUTE);
                selectTimeContext(clickedMin);
            }, { signal });
            
            // Update scroll listener
            const container = document.getElementById('scroll-container');
            container.removeEventListener('scroll', onScroll);
            container.addEventListener('scroll', onScroll, { signal });
            
            // Setup viewport drag handlers
            setupViewportHandlers();
            
            // Restore selections (both explore and live mode)
            if (preservedBreakerId) {
                selectedBreakerId = preservedBreakerId;
                document.querySelectorAll(`.breaker-bar[data-breaker-id="${preservedBreakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                // Keep confluence view
                if (lockedConfluenceMin !== null) {
                    highlightActiveAtEntry(lockedConfluenceMin);
                    showCursorConfluence(lockedConfluenceMin);
                } else if (isLive) {
                    showLiveConfluence();
                }
            } else if (lockedConfluenceMin !== null) {
                highlightActiveAtEntry(lockedConfluenceMin);
                showCursorConfluence(lockedConfluenceMin);
            } else if (preservedEntryMin) {
                selectedEntryMin = preservedEntryMin;
                lockedConfluenceMin = preservedEntryMin;
                highlightActiveAtEntry(preservedEntryMin);
                showCursorConfluence(preservedEntryMin);
                // Highlight entry line and markers if they exist
                document.querySelectorAll('.entry-line').forEach(el => {
                    if (parseInt(el.dataset.entryMin) === preservedEntryMin) {
                        el.classList.add('selected');
                    }
                });
            } else if (preservedSmtId) {
                selectedSmtId = preservedSmtId;
                document.querySelectorAll(`.smt-marker[data-smt-id="${preservedSmtId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                showSmtDetail(preservedSmtId);
            } else if (isLive) {
                // In live mode, show current confluence
                showLiveConfluence();
            } else {
                // In explore mode with no selection, show empty panel
                clearEntryHighlight();
                showEmptyPanel();
            }
            
            // Update viewport indicator after DOM is ready
            setTimeout(updateViewportIndicator, 50);
        }
        
        // ===== SMT DATA LOADING =====
        function loadSmtData(incremental = false) {
            return fetch(SMT_FIREBASE_URL)
                .then(r => r.json())
                .then(data => {
                    if (!data) {
                        if (!incremental) smtData = [];
                        return;
                    }
                    
                    // For full load, clear cache
                    if (!incremental) {
                        smtData = [];
                        smtCache = {};
                    }
                    
                    const errors = [];
                    let newCount = 0;
                    let updatedCount = 0;
                    
                    Object.entries(data).forEach(([key, smt]) => {
                        // STRICT VALIDATION - all fields required
                        const missing = [];
                        if (!smt.smt_id) missing.push('smt_id');
                        if (!smt.dir) missing.push('dir');
                        if (!smt.tf) missing.push('tf');
                        if (!smt.smt_time) missing.push('smt_time');
                        if (!smt.last_detected) missing.push('last_detected');
                        if (!smt.methods) missing.push('methods');
                        if (smt.strength === undefined) missing.push('strength');
                        if (!smt.roles) missing.push('roles');
                        if (!smt.es) missing.push('es');
                        if (!smt.nq) missing.push('nq');
                        if (!smt.criteria) missing.push('criteria');
                        if (smt.quality === undefined) missing.push('quality');
                        if (!smt.status) missing.push('status');
                        
                        if (missing.length > 0) {
                            errors.push(`${key}: Missing fields: ${missing.join(', ')}`);
                            return;
                        }
                        
                        // Validate nested required fields
                        const nestedMissing = [];
                        if (!smt.roles.defensive) nestedMissing.push('roles.defensive');
                        if (!smt.roles.sweep) nestedMissing.push('roles.sweep');
                        if (smt.es.prev_price === undefined) nestedMissing.push('es.prev_price');
                        if (smt.es.curr_price === undefined) nestedMissing.push('es.curr_price');
                        if (!smt.es.structure) nestedMissing.push('es.structure');
                        if (!smt.es.prev_time) nestedMissing.push('es.prev_time');
                        if (!smt.es.curr_time) nestedMissing.push('es.curr_time');
                        if (smt.nq.prev_price === undefined) nestedMissing.push('nq.prev_price');
                        if (smt.nq.curr_price === undefined) nestedMissing.push('nq.curr_price');
                        if (!smt.nq.structure) nestedMissing.push('nq.structure');
                        if (!smt.nq.prev_time) nestedMissing.push('nq.prev_time');
                        if (!smt.nq.curr_time) nestedMissing.push('nq.curr_time');
                        
                        // Validate criteria fields
                        if (smt.criteria.has_fvg === undefined) nestedMissing.push('criteria.has_fvg');
                        if (smt.criteria.is_sync === undefined) nestedMissing.push('criteria.is_sync');
                        if (smt.criteria.sweep_magnitude_ok === undefined) nestedMissing.push('criteria.sweep_magnitude_ok');
                        if (smt.criteria.defensive_held === undefined) nestedMissing.push('criteria.defensive_held');
                        
                        if (nestedMissing.length > 0) {
                            errors.push(`${key}: Missing nested fields: ${nestedMissing.join(', ')}`);
                            return;
                        }
                        
                        // For incremental updates, skip if unchanged
                        if (incremental && smtCache[smt.smt_id]) {
                            const cached = smtCache[smt.smt_id];
                            if (cached.lastDetected === smt.last_detected && cached.status === smt.status) {
                                return;
                            }
                        }
                        
                        // Parse smt_time to minutes
                        const smtMin = datetimeToMin(smt.smt_time);
                        if (isNaN(smtMin)) {
                            errors.push(`${key}: Invalid smt_time format: ${smt.smt_time}`);
                            return;
                        }
                        
                        // Normalize direction: L/long/bull → 'bull', S/short/bear → 'bear'
                        let rawDir = (smt.dir || '').toLowerCase();
                        if (!rawDir && smt.smt_id) {
                            const lastChar = smt.smt_id.slice(-1).toLowerCase();
                            rawDir = lastChar;
                        }
                        const normalizedDir = (rawDir === 'l' || rawDir === 'long' || rawDir === 'bull' || rawDir === 'bullish') ? 'bull' : 'bear';
                        
                        const parsed = {
                            id: key,
                            smtId: smt.smt_id,
                            dir: normalizedDir,
                            tf: smt.tf.toLowerCase(),
                            smtTime: smt.smt_time,
                            smtMin: smtMin,
                            barIndex: smt.bar_index || 0,
                            lastDetected: smt.last_detected,
                            
                            // Methods and strength
                            methods: smt.methods,
                            strength: smt.strength,
                            
                            // Roles
                            defensiveAsset: smt.roles.defensive,
                            sweepAsset: smt.roles.sweep,
                            leadingAsset: smt.roles.leading || smt.roles.defensive,
                            
                            // ES swing data
                            es: {
                                prevPrice: smt.es.prev_price,
                                currPrice: smt.es.curr_price,
                                structure: smt.es.structure,
                                prevTime: smt.es.prev_time,
                                currTime: smt.es.curr_time
                            },
                            
                            // NQ swing data
                            nq: {
                                prevPrice: smt.nq.prev_price,
                                currPrice: smt.nq.curr_price,
                                structure: smt.nq.structure,
                                prevTime: smt.nq.prev_time,
                                currTime: smt.nq.curr_time
                            },
                            
                            // Criteria
                            criteria: {
                                sweptLevel: smt.criteria.swept_level || null,
                                isDaily: smt.criteria.is_daily || false,
                                isWeekly: smt.criteria.is_weekly || false,
                                isMidnight: smt.criteria.is_midnight || false,
                                isSession: smt.criteria.is_session || false,
                                hasFvg: smt.criteria.has_fvg,
                                isHtf: smt.criteria.is_htf || false,
                                isSync: smt.criteria.is_sync,
                                sweepMagnitudeOk: smt.criteria.sweep_magnitude_ok,
                                defensiveHeld: smt.criteria.defensive_held
                            },
                            
                            // Quality score (0-10)
                            quality: smt.quality,
                            
                            // Status
                            status: smt.status
                        };
                        
                        // For incremental updates, update or add
                        if (incremental) {
                            const existingIdx = smtData.findIndex(s => s.smtId === parsed.smtId);
                            if (existingIdx >= 0) {
                                smtData[existingIdx] = parsed;
                                updatedCount++;
                            } else {
                                smtData.push(parsed);
                                newCount++;
                            }
                        } else {
                            smtData.push(parsed);
                        }
                        
                        // Update cache
                        smtCache[parsed.smtId] = { lastDetected: parsed.lastDetected, status: parsed.status };
                    });
                    
                    // Log errors if any
                    if (errors.length > 0) {
                        console.warn(`SMT validation errors: ${errors.length}`);
                    }
                    
                    // Check for duplicates
                    const smtIds = smtData.map(s => s.smtId);
                    const duplicates = smtIds.filter((id, idx) => smtIds.indexOf(id) !== idx);
                    if (duplicates.length > 0) {
                        console.warn(`Duplicate SMT IDs: ${duplicates.length}`);
                    }
                    
                    if (incremental) {
                        console.log(`SMT incremental: ${newCount} new, ${updatedCount} updated (total: ${smtData.length})`);
                    } else {
                        console.log(`Loaded ${smtData.length} SMT signals`);
                    }
                    
                    lastSmtFetchTime = new Date().toISOString();
                })
                .catch(err => {
                    console.error('Error loading SMT data:', err);
                    smtData = [];
                });
        }
        
        function createSmtMarker(smt, laneTop, laneHeight) {
            const x = (smt.smtMin - windowStartMin) * PIXELS_PER_MINUTE;
            
            const marker = document.createElement('div');
            // Add status class for visual differentiation
            const statusClass = smt.status !== 'ACTIVE' ? ' smt-' + smt.status.toLowerCase() : '';
            marker.className = 'smt-marker ' + smt.dir + statusClass;
            marker.style.left = x + 'px';
            marker.style.top = laneTop + 'px';
            marker.style.height = laneHeight + 'px';
            marker.dataset.smtId = smt.smtId;
            
            // Diamond in center
            const diamond = document.createElement('div');
            diamond.className = 'smt-diamond';
            marker.appendChild(diamond);
            
            // Score at bottom (now single number 0-10)
            const score = document.createElement('div');
            score.className = 'smt-score';
            score.textContent = smt.quality.toFixed(1);
            marker.appendChild(score);
            
            // Click handler
            marker.addEventListener('click', (e) => {
                e.stopPropagation();
                selectSmt(smt.smtId);
            });
            
            return marker;
        }
        
        let selectedSmtId = null;
        
        function selectSmt(smtId) {
            // Clear previous selections
            document.querySelectorAll('.breaker-bar.selected').forEach(el => el.classList.remove('selected'));
            document.querySelectorAll('.smt-marker.selected').forEach(el => el.classList.remove('selected'));
            clearEntryHighlight();
            selectedEntryMin = null;
            selectedBreakerId = null;
            lockedConfluenceMin = null;
            
            // Toggle selection
            if (selectedSmtId === smtId) {
                selectedSmtId = null;
                showEmptyPanel();
            } else {
                selectedSmtId = smtId;
                document.querySelectorAll(`.smt-marker[data-smt-id="${smtId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                showSmtDetail(smtId);
            }
        }
        
        function showSmtDetail(smtId) {
            const smt = smtData.find(s => s.smtId === smtId);
            if (!smt) return;
            
            document.getElementById('panel-time').textContent = minToTime(smt.smtMin);
            document.getElementById('panel-type').textContent = 'SMT Signal';
            document.getElementById('panel-type').classList.remove('live');
            
            // Format helpers
            const formatPrice = (asset, p) => {
                if (p === null || p === undefined) return '-';
                return Math.round(p).toLocaleString('en-US');
            };
            const formatDelta = (val) => {
                if (val === null || val === undefined) return '-';
                const sign = val >= 0 ? '+' : '';
                return sign + Math.round(val).toLocaleString('en-US');
            };
            
            // Render mini chart SVG
            const renderSmtMiniChart = (type, data, asset) => {
                const prevPrice = data.prevPrice;
                const currPrice = data.currPrice;
                const prevTime = data.prevTime.split('T')[1].substring(0,5);
                const currTime = data.currTime.split('T')[1].substring(0,5);
                
                const w = 150, h = 60;
                const padL = 38, padR = 38, padT = 10, padB = 14;
                const chartW = w - padL - padR;
                const chartH = h - padT - padB;
                
                const minP = Math.min(prevPrice, currPrice);
                const maxP = Math.max(prevPrice, currPrice);
                const range = maxP - minP || 1;
                const yPad = range * 0.25;
                const yMin = minP - yPad;
                const yMax = maxP + yPad;
                
                const priceToY = (p) => padT + chartH - ((p - yMin) / (yMax - yMin)) * chartH;
                
                const x1 = padL;
                const x2 = w - padR;
                const y1 = priceToY(prevPrice);
                const y2 = priceToY(currPrice);
                
                return `
                    <svg class="smt-div-svg" viewBox="0 0 ${w} ${h}" preserveAspectRatio="xMidYMid meet">
                        <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y1}" stroke="#2a2a2e" stroke-width="1" stroke-dasharray="2,2" />
                        <line class="chart-line" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" />
                        <circle class="chart-point prev" cx="${x1}" cy="${y1}" r="3.5" />
                        <circle class="chart-point curr" cx="${x2}" cy="${y2}" r="4" />
                        <text class="price-label prev" x="${x1 - 6}" y="${y1 + 3}" text-anchor="end" font-size="10">${formatPrice(asset, prevPrice)}</text>
                        <text class="price-label curr" x="${x2 + 6}" y="${y2 + 3}" text-anchor="start" font-size="10">${formatPrice(asset, currPrice)}</text>
                        <text class="time-label" x="${x1}" y="${h - 2}" text-anchor="middle" font-size="9">${prevTime}</text>
                        <text class="time-label" x="${x2}" y="${h - 2}" text-anchor="middle" font-size="9">${currTime}</text>
                    </svg>
                `;
            };
            
            // Get sweep and defensive data
            const sweepAsset = smt.sweepAsset;
            const defAsset = smt.defensiveAsset;
            const sweepData = sweepAsset === 'NQ' ? smt.nq : smt.es;
            const defData = defAsset === 'NQ' ? smt.nq : smt.es;
            
            // Calculate price changes
            const sweepDelta = sweepData.currPrice - sweepData.prevPrice;
            const defDelta = defData.currPrice - defData.prevPrice;
            
            // Direction descriptions
            const dirLabel = smt.dir === 'bull' ? 'BULLISH' : 'BEARISH';
            const dirIcon = smt.dir === 'bull' ? '↑' : '↓';
            const expectation = smt.dir === 'bull' ? 'Expect upward move' : 'Expect downward move';
            
            // Status
            const statusClass = smt.status === 'ACTIVE' ? 'active' : 
                               smt.status === 'INVALIDATED' ? 'invalidated' : 'expired';
            
            // Quality (0-10 scale) - compute color gradient from red to dark green
            const qScore = smt.quality;
            // Color gradient: 0=red(#dc2626), 5=yellow(#fbbf24), 10=dark green(#166534)
            const getQualityColor = (score) => {
                if (score <= 5) {
                    // Red to yellow (0-5)
                    const ratio = score / 5;
                    const r = Math.round(220 - (220 - 251) * ratio);
                    const g = Math.round(38 + (191 - 38) * ratio);
                    const b = Math.round(38 + (36 - 38) * ratio);
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    // Yellow to dark green (5-10)
                    const ratio = (score - 5) / 5;
                    const r = Math.round(251 - (251 - 22) * ratio);
                    const g = Math.round(191 - (191 - 101) * ratio);
                    const b = Math.round(36 + (52 - 36) * ratio);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            };
            const qualityBgColor = getQualityColor(qScore);
            
            // Build all criteria - show checkmark for true, blank for false
            const allCriteria = [
                { label: 'Daily', ok: smt.criteria.isDaily },
                { label: 'Weekly', ok: smt.criteria.isWeekly },
                { label: 'Midnight', ok: smt.criteria.isMidnight },
                { label: 'Session', ok: smt.criteria.isSession },
                { label: 'HTF', ok: smt.criteria.isHtf },
                { label: 'FVG', ok: smt.criteria.hasFvg },
                { label: 'Sync', ok: smt.criteria.isSync },
                { label: 'Sweep', ok: smt.criteria.sweepMagnitudeOk },
                { label: 'Held', ok: smt.criteria.defensiveHeld }
            ];
            
            // Extract detection time from smt_time
            const smtTimeParts = smt.smtTime.split('T');
            const detectionTime = smtTimeParts[1] ? smtTimeParts[1].substring(0, 5) : '';
            
            document.getElementById('panel-content').innerHTML = `
                <!-- Status & Quality Header -->
                <div class="smt-header-row">
                    <div class="smt-status-pill ${statusClass}">${smt.status}</div>
                    <div class="smt-quality-score" style="background: ${qualityBgColor}">
                        <span class="smt-quality-num">${smt.quality.toFixed(1)}</span>
                    </div>
                </div>
                
                <!-- Direction Headline -->
                <div class="smt-direction-block ${smt.dir}">
                    <div class="smt-dir-icon">${dirIcon}</div>
                    <div class="smt-dir-info">
                        <div class="smt-dir-label">${dirLabel}</div>
                        <div class="smt-dir-expect">${expectation}</div>
                    </div>
                    <div class="smt-dir-methods">
                        ${smt.methods.map(m => `<span class="smt-method-pill">${m}</span>`).join('')}
                    </div>
                </div>
                
                <!-- The Divergence Chart -->
                <div class="detail-section">
                    <div class="smt-section-title">The Divergence ${detectionTime ? `@ ${detectionTime}` : ''}</div>
                    <div class="smt-div-chart">
                        <!-- Sweep Panel -->
                        <div class="smt-div-panel sweep">
                            <div class="smt-div-header">
                                <div class="smt-div-title">
                                    <span class="smt-div-role">Sweep</span>
                                    <span class="smt-div-asset ${sweepAsset.toLowerCase()}">${sweepAsset}</span>
                                </div>
                                <span class="smt-div-structure ${sweepData.structure}">${sweepData.structure}</span>
                            </div>
                            <div class="smt-div-chart-area">
                                ${renderSmtMiniChart('sweep', sweepData, sweepAsset)}
                            </div>
                            <div class="smt-div-delta ${sweepDelta >= 0 ? 'positive' : 'negative'}">${formatDelta(sweepDelta)}</div>
                        </div>
                        
                        <!-- VS Divider -->
                        <div class="smt-div-vs">≠</div>
                        
                        <!-- Defender Panel -->
                        <div class="smt-div-panel defender">
                            <div class="smt-div-header">
                                <div class="smt-div-title">
                                    <span class="smt-div-role">Defender</span>
                                    <span class="smt-div-asset ${defAsset.toLowerCase()}">${defAsset}</span>
                                </div>
                                <span class="smt-div-structure ${defData.structure}">${defData.structure}</span>
                            </div>
                            <div class="smt-div-chart-area">
                                ${renderSmtMiniChart('defender', defData, defAsset)}
                            </div>
                            <div class="smt-div-delta ${defDelta >= 0 ? 'positive' : 'negative'}">${formatDelta(defDelta)}</div>
                        </div>
                    </div>
                </div>
                
                <!-- Criteria - Big Rows -->
                <div class="detail-section">
                    <div class="smt-section-title">Signal Criteria</div>
                    <div class="smt-criteria-list">
                        ${allCriteria.map(c => `
                            <div class="smt-criteria-row ${c.ok ? 'ok' : ''}">
                                <span class="smt-criteria-label">${c.label}</span>
                                <span class="smt-criteria-status">${c.ok ? '✓' : '—'}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <!-- Meta Footer -->
                <div class="smt-footer-section">
                    <div class="smt-footer-row">
                        <span class="smt-footer-label">Signal Time</span>
                        <span class="smt-footer-value time">${smt.smtTime}</span>
                    </div>
                    <div class="smt-footer-row">
                        <span class="smt-footer-label">Timeframe</span>
                        <span class="smt-footer-value tf">${smt.tf.toUpperCase()}</span>
                    </div>
                    <div class="smt-footer-row">
                        <span class="smt-footer-label">ID</span>
                        <span class="smt-footer-value id">${smt.smtId}</span>
                    </div>
                </div>
            `;
        }
        
        function createBreakerBar(b, laneHeight) {
            const startX = Math.max(0, (b.startMin - windowStartMin) * PIXELS_PER_MINUTE);
            const endX = (b.endMin - windowStartMin) * PIXELS_PER_MINUTE;
            const barWidth = Math.max(endX - startX + PIXELS_PER_MINUTE, 6);
            
            // Calculate vertical position - top aligned with padding
            const topOffset = LANE_PADDING + b.stackIdx * (BAR_HEIGHT + BAR_GAP);
            
            const bar = document.createElement('div');
            bar.className = 'breaker-bar ' + b.symbol.toLowerCase() + ' ' + b.dir;
            
            if (b.status !== 'active') {
                bar.classList.add('completed');
            }
            
            bar.style.left = startX + 'px';
            bar.style.width = barWidth + 'px';
            bar.style.top = topOffset + 'px';
            bar.style.height = BAR_HEIGHT + 'px';
            bar.dataset.breakerId = b.id;
            bar.dataset.startMin = b.startMin;
            bar.dataset.endMin = b.endMin;
            
            // Right-side container for fib and status
            const rightGroup = document.createElement('div');
            rightGroup.className = 'bar-right-group';
            
            // Show fib on wider bars (right side, before status) - currentFib/maxFib and points
            if (barWidth > 40) {
                const fibSpan = document.createElement('span');
                fibSpan.className = 'bar-fib';
                
                const currFib = (b.currentFib || b.maxFib || 0).toFixed(1);
                const maxFib = (b.maxFib || 0).toFixed(1);
                const points = b.points || 0;
                
                // Fib text
                const fibText = document.createElement('span');
                fibText.className = 'bar-fib-value';
                fibText.textContent = `${currFib}/${maxFib}`;
                fibSpan.appendChild(fibText);
                
                // Points in box
                if (points > 0) {
                    const pointsBox = document.createElement('span');
                    pointsBox.className = 'bar-points';
                    pointsBox.textContent = `${points}p`;
                    fibSpan.appendChild(pointsBox);
                }
                
                rightGroup.appendChild(fibSpan);
            }
            
            // Status dot - only for completed
            const isFailed = b.status?.startsWith('failed:');
            if (b.status === 'success' || isFailed) {
                const dot = document.createElement('div');
                dot.className = 'status-dot ' + (isFailed ? 'fail' : 'success');
                dot.textContent = b.status === 'success' ? 'S' : 'F';
                // Add tooltip for failure reason
                if (isFailed) {
                    dot.title = b.status.replace('failed:', '');
                }
                rightGroup.appendChild(dot);
            }
            
            bar.appendChild(rightGroup);
            
            // Click to show details
            bar.addEventListener('click', (e) => {
                e.stopPropagation();
                selectBreaker(b.id);
            });
            
            return bar;
        }
        
        // ===== DETAIL PANEL =====
        function showEmptyPanel() {
            document.getElementById('panel-time').textContent = '';
            document.getElementById('panel-type').textContent = 'Details';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="panel-empty">
                    <div class="panel-empty-icon">📋</div>
                    <div class="panel-empty-text">
                        Click a breaker bar or entry line to see details
                    </div>
                </div>
            `;
        }
        
        function showCursorConfluence(cursorMin) {
            const activeBreakers = allData.filter(d => 
                d.startMin <= cursorMin && d.endMin >= cursorMin
            );
            
            // Sort: 1m first, then 5m, 15m, 1h, 4h last; within TF: NQ before ES
            const tfOrder = { '1m': 1, '5m': 2, '15m': 3, '1h': 4, '1hr': 4, '4h': 5, '4hr': 5 };
            const symOrder = { 'NQ': 1, 'ES': 2 };
            const sortedActive = [...activeBreakers].sort((a, b) => {
                const tfA = tfOrder[a.tf.replace('hr', 'h')] || 99;
                const tfB = tfOrder[b.tf.replace('hr', 'h')] || 99;
                if (tfA !== tfB) return tfA - tfB;
                const symA = symOrder[a.symbol] || 99;
                const symB = symOrder[b.symbol] || 99;
                if (symA !== symB) return symA - symB;
                return a.dir === 'bull' ? -1 : 1;
            });
            
            document.getElementById('panel-time').textContent = minToTime(cursorMin);
            document.getElementById('panel-type').textContent = 'Confluence';
            document.getElementById('panel-type').classList.remove('live');
            
            if (sortedActive.length === 0) {
                document.getElementById('panel-content').innerHTML = `<div class="confluence-no-active">No active breakers at this time</div>`;
                return;
            }
            
            let html = '<div class="stack-container">';
            sortedActive.forEach(breaker => {
                html += generateStackedBreaker(breaker);
            });
            html += '</div>';
            
            document.getElementById('panel-content').innerHTML = html;
        }
        
        function showLiveConfluence() {
            // Use actual current time, not last data time
            const now = new Date();
            const currentMin = Math.floor(now.getTime() / 60000);
            
            // Extend dataMaxTime to current time if behind (so chart shows current time)
            if (currentMin > dataMaxTime && dataMaxTime > 0) {
                dataMaxTime = currentMin;
            }
            
            highlightLiveActive();
            
            const activeBreakers = allData.filter(d => 
                d.startMin <= currentMin && d.endMin >= currentMin
            );
            
            // Sort: 1m first, then 5m, 15m, 1h, 4h last; within TF: NQ before ES
            const tfOrder = { '1m': 1, '5m': 2, '15m': 3, '1h': 4, '1hr': 4, '4h': 5, '4hr': 5 };
            const symOrder = { 'NQ': 1, 'ES': 2 };
            const sortedActive = [...activeBreakers].sort((a, b) => {
                const tfA = tfOrder[a.tf.replace('hr', 'h')] || 99;
                const tfB = tfOrder[b.tf.replace('hr', 'h')] || 99;
                if (tfA !== tfB) return tfA - tfB;
                const symA = symOrder[a.symbol] || 99;
                const symB = symOrder[b.symbol] || 99;
                if (symA !== symB) return symA - symB;
                return a.dir === 'bull' ? -1 : 1;
            });
            
            document.getElementById('panel-time').textContent = minToTime(currentMin);
            document.getElementById('panel-type').textContent = 'Live Confluence';
            document.getElementById('panel-type').classList.add('live');
            
            if (sortedActive.length === 0) {
                document.getElementById('panel-content').innerHTML = `<div class="confluence-no-active">No active breakers</div>`;
                return;
            }
            
            let html = '<div class="stack-container">';
            sortedActive.forEach(breaker => {
                html += generateStackedBreaker(breaker);
            });
            html += '</div>';
            
            document.getElementById('panel-content').innerHTML = html;
        }
        
        // TF colors matching left panel
        const TF_COLORS = {
            '4h': '#f87171', '4hr': '#f87171',
            '1h': '#fbbf24', '1hr': '#fbbf24',
            '15m': '#4ade80',
            '5m': '#60a5fa',
            '1m': '#c084fc'
        };
        
        function generateStackedBreaker(breaker) {
            const tf = breaker.tf.replace('hr', 'h');
            const tfDisplay = TF_DISPLAY[tf] || breaker.tf;
            const tfColor = TF_COLORS[breaker.tf] || '#888';
            const isBull = breaker.dir === 'bull';
            const dirColor = isBull ? '#4ade80' : '#f87171';
            const events = breaker.events;
            const isSelected = selectedBreakerId === breaker.id ? ' selected' : '';
            
            if (events.length < 2) {
                return `
                    <div class="stack-item${isSelected}" data-breaker-id="${breaker.id}" onclick="selectBreaker('${breaker.id}')">
                        <div class="stack-label" style="border-left-color:${tfColor}">
                            <span class="stack-tf" style="color:${tfColor}">${tfDisplay}</span>
                            <span class="stack-sym">${breaker.symbol}</span>
                            <span class="stack-dir" style="color:${dirColor}">${breaker.dir.toUpperCase()}</span>
                        </div>
                        <div class="stack-empty">No data</div>
                    </div>
                `;
            }
            
            const combinedChart = generateCombinedFibPriceChart(breaker, dirColor);
            
            return `
                <div class="stack-item${isSelected}" data-breaker-id="${breaker.id}" onclick="selectBreaker('${breaker.id}')">
                    <div class="stack-label" style="border-left-color:${tfColor}">
                        <span class="stack-tf" style="color:${tfColor}">${tfDisplay}</span>
                        <span class="stack-sym">${breaker.symbol}</span>
                        <span class="stack-dir" style="color:${dirColor}">${breaker.dir.toUpperCase()}</span>
                        <span class="stack-spacer"></span>
                        <span class="stack-legend">
                            <span class="legend-item"><span class="legend-line" style="background:#888"></span><span style="color:#888">Brkr</span></span>
                            <span class="legend-item"><span class="legend-line dashed" style="border-color:${dirColor}"></span><span style="color:${dirColor}">Peak</span></span>
                            <span class="legend-item"><span class="legend-line" style="background:${dirColor}"></span><span style="color:${dirColor}">Fib</span></span>
                        </span>
                    </div>
                    <div class="stack-charts">
                        ${combinedChart}
                    </div>
                </div>
            `;
        }
        
        function generateCombinedFibPriceChart(breaker, dirColor) {
            const events = breaker.events;
            const width = 400;
            const height = 130;
            const padding = { top: 8, right: 52, bottom: 18, left: 32 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const minTime = events[0].absMin;
            const maxTime = events[events.length - 1].absMin;
            const timeRange = maxTime - minTime || 1;
            
            // Get breaker price and current price
            const breakerPrice = breaker.price || 0;
            const isBull = breaker.dir === 'bull';
            
            // Get current price from last event
            const lastEvent = events[events.length - 1];
            const currentPrice = lastEvent.price || 0;
            const currentFib = lastEvent.fib || 0;
            
            // Dynamic fib scale
            const maxFibCurrent = Math.max(...events.map(e => e.fib || 0), 1);
            const maxFibPeak = Math.max(...events.map(e => e.maxFib || e.fib || 0), 1);
            const fibCeil = Math.ceil(Math.max(maxFibCurrent, maxFibPeak) * 1.15);
            
            // Y-axis helper: Bulls = 0 bottom, 4 top; Bears = 0 top, 4 bottom
            const fibToY = (fib) => {
                if (isBull) {
                    return padding.top + chartHeight - (fib / fibCeil) * chartHeight;
                } else {
                    return padding.top + (fib / fibCeil) * chartHeight;
                }
            };
            
            let sampledEvents = events;
            if (events.length > 100) {
                const step = Math.ceil(events.length / 80);
                sampledEvents = events.filter((e, i) => i === 0 || i === events.length - 1 || i % step === 0);
            }
            
            // Current fib line (direction colored - solid)
            const fibPoints = sampledEvents.map(e => ({
                x: padding.left + ((e.absMin - minTime) / timeRange) * chartWidth,
                y: fibToY(e.fib || 0),
                fib: e.fib || 0,
                price: e.price || 0
            }));
            
            // Peak fib line (direction colored - dashed)
            const peakPoints = sampledEvents.map(e => ({
                x: padding.left + ((e.absMin - minTime) / timeRange) * chartWidth,
                y: fibToY(e.maxFib || e.fib || 0),
                fib: e.maxFib || e.fib || 0
            }));
            
            // Find peak location
            let peakX = fibPoints[0].x;
            let peakY = fibPoints[0].y;
            let peakFib = 0;
            fibPoints.forEach(p => {
                if (p.fib > peakFib) {
                    peakFib = p.fib;
                    peakX = p.x;
                    peakY = p.y;
                }
            });
            
            const fibPath = fibPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            const peakPath = peakPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            
            // Area fill - needs to go to the zero line
            const zeroY = fibToY(0);
            const areaPath = fibPath + ` L ${fibPoints[fibPoints.length-1].x} ${zeroY} L ${fibPoints[0].x} ${zeroY} Z`;
            
            // Breaker line at fib = 1.0 (neutral color)
            const breakerY = fibToY(1.0);
            
            // Y-axis grid and labels
            let yGrid = '';
            const gridVals = [0, 1, 2, 3, 4].filter(v => v <= fibCeil);
            gridVals.forEach(val => {
                const y = fibToY(val);
                const isBreaker = val === 1;
                // Breaker line is neutral gray, others are darker
                yGrid += `<line x1="${padding.left}" y1="${y}" x2="${padding.left + chartWidth}" y2="${y}" stroke="${isBreaker ? '#888' : '#252528'}" stroke-width="${isBreaker ? 1.5 : 0.5}"/>`;
                yGrid += `<text x="${padding.left - 3}" y="${y + 3}" text-anchor="end" fill="${isBreaker ? '#aaa' : '#666'}" font-size="9" font-family="Roboto Mono" font-weight="${isBreaker ? 600 : 400}">${val.toFixed(1)}</text>`;
            });
            
            // Time labels
            const midTime = minTime + Math.floor(timeRange / 2);
            const timeLabels = `
                <text x="${padding.left}" y="${height - 2}" text-anchor="start" fill="#555" font-size="8" font-family="Roboto Mono">${minToTime(minTime)}</text>
                <text x="${padding.left + chartWidth/2}" y="${height - 2}" text-anchor="middle" fill="#555" font-size="8" font-family="Roboto Mono">${minToTime(midTime)}</text>
                <text x="${padding.left + chartWidth}" y="${height - 2}" text-anchor="end" fill="#555" font-size="8" font-family="Roboto Mono">${minToTime(maxTime)}</text>
            `;
            
            // Breaker price on right at fib=1.0 line
            const breakerPriceLabel = `
                <text x="${width - 2}" y="${breakerY + 3}" text-anchor="end" fill="#888" font-size="10" font-family="Roboto Mono">${Math.round(breakerPrice)}</text>
            `;
            
            // Peak dots on maxFib line
            let dots = '';
            let dotPoints = peakPoints;
            if (peakPoints.length > 12) {
                const step = Math.ceil(peakPoints.length / 10);
                dotPoints = peakPoints.filter((p, i) => i === 0 || i === peakPoints.length - 1 || i % step === 0);
            }
            dotPoints.forEach(p => {
                dots += `<circle cx="${p.x}" cy="${p.y}" r="2" fill="${dirColor}"/>`;
            });
            
            // Last point marker with current price
            const lastPoint = fibPoints[fibPoints.length - 1];
            const lastPointY = lastPoint ? lastPoint.y : 0;
            const currentPriceLabel = lastPoint && currentPrice > 0 ? `
                <text x="${width - 2}" y="${lastPointY + 3}" text-anchor="end" fill="#fb923c" font-size="10" font-family="Roboto Mono" font-weight="500">${Math.round(currentPrice)}</text>
            ` : '';
            
            return `
                <svg class="stack-svg-tall" viewBox="0 0 ${width} ${height}">
                    ${yGrid}
                    <path d="${areaPath}" fill="${dirColor}" fill-opacity="0.08"/>
                    <path d="${peakPath}" fill="none" stroke="${dirColor}" stroke-width="1.5" stroke-dasharray="3,2"/>
                    <path d="${fibPath}" fill="none" stroke="${dirColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    ${dots}
                    <circle cx="${peakX}" cy="${peakY}" r="5" fill="${dirColor}" stroke="#111" stroke-width="1"/>
                    <text x="${peakX}" y="${peakY + (isBull ? -7 : 14)}" text-anchor="middle" fill="${dirColor}" font-size="11" font-family="Roboto Mono" font-weight="600">${peakFib.toFixed(2)}</text>
                    ${lastPoint ? `<circle cx="${lastPoint.x}" cy="${lastPoint.y}" r="3" fill="#fb923c"/>` : ''}
                    ${breakerPriceLabel}
                    ${currentPriceLabel}
                    ${timeLabels}
                </svg>
            `;
        }
        
        function generateStackPriceZone(breaker, dirColor) {
            // Kept for compatibility but not used in stacked view
            return '';
        }
        
        function generateStackFibChart(breaker) {
            // Kept for compatibility but not used in stacked view
            return '';
        }
        
        function generateCombinedMiniChart(breaker, cursorMin) {
            return generateStackedBreaker(breaker);
        }
        
        function generateMiniFibChart(breaker) {
            return generateStackedBreaker(breaker);
        }
        
        function showBreakerDetail(breakerId) {
            const b = allData.find(d => d.id === breakerId);
            if (!b) return;
            
            const duration = minToDuration(b.startMin, b.endMin);
            const isFailed = b.status?.startsWith('failed:');
            const statusClass = isFailed ? 'fail' : b.status.toLowerCase();
            let statusText = b.status.charAt(0).toUpperCase() + b.status.slice(1);
            let failureReason = '';
            if (isFailed) {
                failureReason = b.status.replace('failed:', '');
                statusText = 'Failed';
            }
            
            // Parse confirmation time for display
            function formatIdTime(timeStr) {
                if (!timeStr || timeStr.length < 10) return '—';
                const match = timeStr.match(/^(\d{2})(\d{2})(\d{2})T(\d{2})(\d{2})$/);
                if (!match) return timeStr;
                const [_, yy, mm, dd, hh, min] = match;
                const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                return `${months[parseInt(mm)-1]} ${parseInt(dd)} ${hh}:${min}`;
            }
            
            // Generate fib chart
            const fibChart = generateFibChart(b);
            
            // Generate price zone visualization
            const priceZone = generatePriceZone(b);
            
            document.getElementById('panel-time').textContent = minToTime(b.startMin);
            document.getElementById('panel-type').textContent = 'Breaker Detail';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-id">${b.displayId || b.id}</div>
                    <div class="detail-badges">
                        <span class="detail-badge ${b.symbol.toLowerCase()}">${b.symbol}</span>
                        <span class="detail-badge ${b.dir}">${b.dir.toUpperCase()}</span>
                        <span class="detail-badge tf">${TF_DISPLAY[b.tf] || b.tf.toUpperCase()}</span>
                        <span class="detail-badge ${statusClass}">${statusText}</span>
                    </div>
                    ${failureReason ? `<div class="failure-reason">Reason: ${failureReason}</div>` : ''}
                </div>
                
                <div class="detail-section compact-info">
                    <div class="info-item">
                        <span class="info-value">${b.price || '—'}</span>
                        <span class="info-label">Price</span>
                    </div>
                    <div class="info-item">
                        <span class="info-value">${b.points}p</span>
                        <span class="info-label">Range</span>
                    </div>
                    <div class="info-item">
                        <span class="info-value">${b.currentFib.toFixed(1)}/${b.maxFib.toFixed(1)}</span>
                        <span class="info-label">Fib C/P</span>
                    </div>
                    <div class="info-item">
                        <span class="info-value">${duration}</span>
                        <span class="info-label">Duration</span>
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Price Zone</div>
                    <div class="price-zone-container">
                        ${priceZone}
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Fib Progression</div>
                    <div class="fib-chart-legend">
                        <span class="fib-legend-item"><span class="fib-legend-line max"></span>Peak</span>
                        <span class="fib-legend-item"><span class="fib-legend-line current"></span>Current</span>
                    </div>
                    <div class="fib-chart-container">
                        ${fibChart}
                    </div>
                </div>
                
                ${(b.tf === '1m' && b.dir === 'bull' && b.symbol === 'NQ') ? `
                <div class="analysis-link" onclick="showAnalysisModal('${b.id}')" title="View 21-dimension confirmation analysis">
                    📊 View Full Analysis
                </div>
                ` : ''}
            `;
        }
        
        function generateFibChart(breaker) {
            const events = breaker.events;
            if (events.length < 2) {
                return '<div style="color:#666;text-align:center;padding:20px;">Not enough data</div>';
            }
            
            const width = 280;
            const height = 120;
            const padding = { top: 20, right: 15, bottom: 25, left: 35 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Find min/max
            const minTime = events[0].absMin;
            const maxTime = events[events.length - 1].absMin;
            const timeRange = maxTime - minTime || 1;
            
            // Use max of both fib values for scale
            const maxFibCurrent = Math.max(...events.map(e => e.fib || 0), 1);
            const maxFibPeak = Math.max(...events.map(e => e.maxFib || e.fib || 0), 1);
            const maxFibVal = Math.max(maxFibCurrent, maxFibPeak);
            const fibCeil = Math.ceil(maxFibVal * 1.1); // Add 10% padding
            
            // Find peak point (first occurrence of max fib in maxFib line)
            const peakVal = Math.max(...events.map(e => e.maxFib || e.fib || 0));
            const peakIndex = events.findIndex(e => (e.maxFib || e.fib) === peakVal);
            const peakEvent = events[peakIndex];
            
            // Downsample events if too many (keep first, last, peak, and sampled)
            let sampledEvents = events;
            let sampledPeakIndex = peakIndex;
            if (events.length > 100) {
                const step = Math.ceil(events.length / 80);
                sampledEvents = events.filter((e, i) => 
                    i === 0 || i === events.length - 1 || i === peakIndex || i % step === 0
                );
                sampledPeakIndex = sampledEvents.findIndex(e => e === events[peakIndex]);
            }
            
            // Generate points for currentFib line
            const currentPoints = sampledEvents.map((e, i) => {
                const x = padding.left + ((e.absMin - minTime) / timeRange) * chartWidth;
                const y = padding.top + chartHeight - ((e.fib || 0) / fibCeil) * chartHeight;
                return { x, y, fib: e.fib || 0, time: e.absMin };
            });
            
            // Generate points for maxFib line
            const maxPoints = sampledEvents.map((e, i) => {
                const x = padding.left + ((e.absMin - minTime) / timeRange) * chartWidth;
                const fibVal = e.maxFib || e.fib || 0;
                const y = padding.top + chartHeight - (fibVal / fibCeil) * chartHeight;
                return { x, y, fib: fibVal, time: e.absMin, isPeak: i === sampledPeakIndex };
            });
            
            // Create line paths
            const currentLinePath = currentPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            const maxLinePath = maxPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            
            // Create area path (for gradient fill under max line)
            const areaPath = maxLinePath + ` L ${maxPoints[maxPoints.length-1].x} ${padding.top + chartHeight} L ${maxPoints[0].x} ${padding.top + chartHeight} Z`;
            
            // Generate Y-axis labels
            const yLabels = [];
            const ySteps = 4;
            for (let i = 0; i <= ySteps; i++) {
                const val = (fibCeil / ySteps) * i;
                const y = padding.top + chartHeight - (i / ySteps) * chartHeight;
                yLabels.push(`<text class="fib-chart-value-label" x="${padding.left - 5}" y="${y + 3}" text-anchor="end">${val.toFixed(1)}</text>`);
                if (i > 0 && i < ySteps) {
                    yLabels.push(`<line class="fib-chart-grid" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}"/>`);
                }
            }
            
            // Generate time labels (start, middle, end)
            const midTime = minTime + Math.floor(timeRange / 2);
            const timeLabels = [];
            timeLabels.push(`<text class="fib-chart-label" x="${padding.left}" y="${height - 5}" text-anchor="start">${minToTime(minTime)}</text>`);
            timeLabels.push(`<text class="fib-chart-label" x="${padding.left + chartWidth/2}" y="${height - 5}" text-anchor="middle">${minToTime(midTime)}</text>`);
            timeLabels.push(`<text class="fib-chart-label" x="${width - padding.right}" y="${height - 5}" text-anchor="end">${minToTime(maxTime)}</text>`);
            
            // Find peak point coordinates (on maxFib line)
            const peakPoint = maxPoints.find(p => p.isPeak);
            
            // Generate dots for maxFib line (sample if too many)
            let dotPoints = maxPoints;
            if (maxPoints.length > 20) {
                const step = Math.ceil(maxPoints.length / 15);
                dotPoints = maxPoints.filter((p, i) => i === 0 || i === maxPoints.length - 1 || p.isPeak || i % step === 0);
            }
            
            const dots = dotPoints.map(p => {
                return `<circle class="${p.isPeak ? 'fib-chart-peak' : 'fib-chart-dot'}" cx="${p.x}" cy="${p.y}" r="${p.isPeak ? 4 : 3}"/>`;
            }).join('');
            
            // Peak label (show maxFib value)
            const peakLabel = peakPoint ? `
                <text class="fib-peak-label" x="${peakPoint.x}" y="${peakPoint.y - 8}" text-anchor="middle">${peakPoint.fib.toFixed(2)}</text>
            ` : '';
            
            // Store chart data for cursor interaction
            const chartId = 'fib-chart-' + Date.now();
            
            // Schedule cursor setup after DOM update (pass both point sets)
            setTimeout(() => setupFibChartCursor(chartId, maxPoints, padding, chartWidth, chartHeight, fibCeil, minTime, timeRange, currentPoints), 0);
            
            return `
                <svg id="${chartId}" class="fib-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                    <defs>
                        <linearGradient id="fibGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:0.3"/>
                            <stop offset="100%" style="stop-color:#60a5fa;stop-opacity:0"/>
                        </linearGradient>
                    </defs>
                    
                    <!-- Grid lines -->
                    ${yLabels.join('')}
                    
                    <!-- Axes -->
                    <line class="fib-chart-axis" x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${padding.top + chartHeight}"/>
                    <line class="fib-chart-axis" x1="${padding.left}" y1="${padding.top + chartHeight}" x2="${width - padding.right}" y2="${padding.top + chartHeight}"/>
                    
                    <!-- Area fill (under max line) -->
                    <path class="fib-chart-area" d="${areaPath}"/>
                    
                    <!-- Current Fib line (orange, thinner) -->
                    <path class="fib-chart-line-current" d="${currentLinePath}"/>
                    
                    <!-- Max Fib line (blue, thicker) -->
                    <path class="fib-chart-line" d="${maxLinePath}"/>
                    
                    <!-- Dots on max line -->
                    ${dots}
                    
                    <!-- Peak label -->
                    ${peakLabel}
                    
                    <!-- Time labels -->
                    ${timeLabels.join('')}
                    
                    <!-- Cursor elements -->
                    <line class="fib-cursor-line" id="${chartId}-cursor-line" x1="0" y1="${padding.top}" x2="0" y2="${padding.top + chartHeight}"/>
                    <circle class="fib-cursor-dot" id="${chartId}-cursor-dot" cx="0" cy="0" r="5"/>
                    
                    <!-- Hover area -->
                    <rect x="${padding.left}" y="${padding.top}" width="${chartWidth}" height="${chartHeight}" fill="transparent" style="cursor:crosshair"/>
                </svg>
                <div class="fib-cursor-tooltip" id="${chartId}-tooltip">
                    <span class="fib-val">0.00</span>
                    <span class="time-val">00:00</span>
                </div>
            `;
        }
        
        function generatePriceZone(breaker) {
            const events = breaker.events;
            if (events.length < 2 || !breaker.price || !breaker.points) {
                return '<div style="color:#666;text-align:center;padding:20px;">Not enough data</div>';
            }
            
            // Check if we have price data in events
            const hasPrice = events.some(e => e.price > 0);
            if (!hasPrice) {
                return '<div style="color:#666;text-align:center;padding:20px;">No price data</div>';
            }
            
            const width = 280;
            const height = 100;
            const padding = { top: 10, right: 45, bottom: 20, left: 10 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const breakerLevel = breaker.price; // Confirmation price from ID
            const range = breaker.points;
            const isBull = breaker.dir === 'bull';
            
            // Breaker zone:
            // Bull: zone is support BELOW price. Top = breakerLevel, Bottom = breakerLevel - range
            // Bear: zone is resistance ABOVE price. Bottom = breakerLevel, Top = breakerLevel + range
            const zoneTop = isBull ? breakerLevel : breakerLevel + range;
            const zoneBottom = isBull ? breakerLevel - range : breakerLevel;
            
            // Find time range
            const minTime = events[0].absMin;
            const maxTime = events[events.length - 1].absMin;
            const timeRange = maxTime - minTime || 1;
            
            // Get actual prices from events
            const priceData = events.filter(e => e.price > 0).map(e => ({
                time: e.absMin,
                price: e.price
            }));
            
            if (priceData.length < 2) {
                return '<div style="color:#666;text-align:center;padding:20px;">Not enough price data</div>';
            }
            
            // Find price range for scale
            const allPrices = priceData.map(p => p.price);
            allPrices.push(zoneTop, zoneBottom);
            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);
            const priceRange = maxPrice - minPrice || 1;
            const pricePadding = priceRange * 0.15;
            const scaledMinPrice = minPrice - pricePadding;
            const scaledMaxPrice = maxPrice + pricePadding;
            const scaledRange = scaledMaxPrice - scaledMinPrice;
            
            // Convert price to Y coordinate (higher price = lower Y)
            const priceToY = (price) => {
                return padding.top + chartHeight - ((price - scaledMinPrice) / scaledRange) * chartHeight;
            };
            
            // Downsample if too many points
            let sampledData = priceData;
            if (priceData.length > 100) {
                const step = Math.ceil(priceData.length / 80);
                sampledData = priceData.filter((_, i) => i === 0 || i === priceData.length - 1 || i % step === 0);
            }
            
            // Generate price line points
            const pricePoints = sampledData.map(d => {
                const x = padding.left + ((d.time - minTime) / timeRange) * chartWidth;
                const y = priceToY(d.price);
                return { x, y };
            });
            
            // Create price line path
            const pricePath = pricePoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            
            // Zone Y coordinates
            const zoneTopY = priceToY(zoneTop);
            const zoneBottomY = priceToY(zoneBottom);
            const zoneHeight = zoneBottomY - zoneTopY;
            
            // Breaker level line (top of zone for bull, bottom for bear)
            const breakerLineY = priceToY(breakerLevel);
            
            // Price labels
            const priceLabels = `
                <text class="price-chart-price-label" x="${width - 3}" y="${zoneTopY + 3}" text-anchor="end">${Math.round(zoneTop)}</text>
                <text class="price-chart-price-label" x="${width - 3}" y="${zoneBottomY + 3}" text-anchor="end">${Math.round(zoneBottom)}</text>
            `;
            
            return `
                <svg class="price-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                    <!-- Breaker zone (shaded) -->
                    <rect class="price-chart-breaker-zone" x="${padding.left}" y="${zoneTopY}" width="${chartWidth}" height="${zoneHeight}"/>
                    
                    <!-- Breaker level line (solid blue) -->
                    <line class="price-chart-breaker-line" x1="${padding.left}" y1="${breakerLineY}" x2="${padding.left + chartWidth}" y2="${breakerLineY}"/>
                    
                    <!-- Zone bottom line (dashed) -->
                    <line class="price-chart-level" x1="${padding.left}" y1="${zoneBottomY}" x2="${padding.left + chartWidth}" y2="${zoneBottomY}"/>
                    
                    <!-- Price line (orange) -->
                    <path class="price-chart-price-line" d="${pricePath}"/>
                    
                    <!-- Price labels -->
                    ${priceLabels}
                </svg>
            `;
        }
        
        function setupFibChartCursor(chartId, points, padding, chartWidth, chartHeight, fibCeil, minTime, timeRange) {
            const svg = document.getElementById(chartId);
            const cursorLine = document.getElementById(chartId + '-cursor-line');
            const cursorDot = document.getElementById(chartId + '-cursor-dot');
            const tooltip = document.getElementById(chartId + '-tooltip');
            
            // Guard: check if elements exist and listeners not already attached
            if (!svg || !cursorLine || !cursorDot || !tooltip) return;
            if (svg.dataset.listenersAttached) return;
            svg.dataset.listenersAttached = 'true';
            
            const container = svg.closest('.fib-chart-container');
            
            svg.addEventListener('mousemove', (e) => {
                const rect = svg.getBoundingClientRect();
                const scaleX = 280 / rect.width;
                const mouseX = (e.clientX - rect.left) * scaleX;
                
                // Check if within chart area
                if (mouseX < padding.left || mouseX > padding.left + chartWidth) {
                    cursorLine.style.opacity = '0';
                    cursorDot.style.opacity = '0';
                    tooltip.style.opacity = '0';
                    return;
                }
                
                // Find closest point
                let closest = points[0];
                let closestDist = Math.abs(points[0].x - mouseX);
                
                for (const p of points) {
                    const dist = Math.abs(p.x - mouseX);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = p;
                    }
                }
                
                // Update cursor
                cursorLine.setAttribute('x1', closest.x);
                cursorLine.setAttribute('x2', closest.x);
                cursorLine.style.opacity = '1';
                
                cursorDot.setAttribute('cx', closest.x);
                cursorDot.setAttribute('cy', closest.y);
                cursorDot.style.opacity = '1';
                
                // Update tooltip
                tooltip.querySelector('.fib-val').textContent = closest.fib.toFixed(2);
                tooltip.querySelector('.time-val').textContent = minToTime(closest.time);
                tooltip.style.opacity = '1';
                
                // Position tooltip
                const tooltipX = (closest.x / 280) * rect.width;
                const tooltipY = (closest.y / 120) * rect.height;
                
                // Flip tooltip if near right edge
                if (tooltipX > rect.width * 0.6) {
                    tooltip.style.left = (tooltipX - tooltip.offsetWidth - 10) + 'px';
                } else {
                    tooltip.style.left = (tooltipX + 10) + 'px';
                }
                tooltip.style.top = (tooltipY - 10) + 'px';
            });
            
            svg.addEventListener('mouseleave', () => {
                cursorLine.style.opacity = '0';
                cursorDot.style.opacity = '0';
                tooltip.style.opacity = '0';
            });
        }
        
        function showEntryContext(entryMin) {
            // Find all breakers active at this time
            const activeAtEntry = allData.filter(d => 
                d.startMin <= entryMin && d.endMin >= entryMin
            );
            
            // Build context for each TF/Symbol combination
            const contextRows = [];
            let nqBull = 0, nqBear = 0, esBull = 0, esBear = 0;
            
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    const breaker = activeAtEntry.find(d => 
                        d.tf.replace('hr', 'h') === tf && d.symbol === symbol
                    );
                    
                    if (breaker) {
                        // Count for alignment
                        if (symbol === 'NQ') {
                            if (breaker.dir === 'bull') nqBull++; else nqBear++;
                        } else {
                            if (breaker.dir === 'bull') esBull++; else esBear++;
                        }
                        
                        // Get fib at start
                        const startFib = breaker.events[0]?.fib || 1.0;
                        
                        // Get fib at entry time
                        let fibAtEntry = startFib;
                        for (const evt of breaker.events) {
                            if (evt.absMin <= entryMin) {
                                fibAtEntry = evt.fib;
                            }
                        }
                        
                        // Status indicator
                        const isBreakerFailed = breaker.status?.startsWith('failed:');
                        const statusIcon = breaker.status === 'success' ? 'S' : 
                                          isBreakerFailed ? 'F' : '-';
                        const statusClass = isBreakerFailed ? 'fail' : breaker.status;
                        
                        contextRows.push(`
                            <div class="context-row active">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir ${breaker.dir}">${breaker.dir.toUpperCase()}</span>
                                <span class="context-fib">${startFib.toFixed(1)} → ${fibAtEntry.toFixed(1)}</span>
                                <span class="context-status-icon ${statusClass}">${statusIcon}</span>
                            </div>
                        `);
                    } else {
                        contextRows.push(`
                            <div class="context-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir none">-</span>
                                <span class="context-fib">-</span>
                                <span class="context-status-icon none">-</span>
                            </div>
                        `);
                    }
                });
            });
            
            document.getElementById('panel-time').textContent = minToTime(entryMin);
            document.getElementById('panel-type').textContent = 'Entry Confluence';
            document.getElementById('panel-type').classList.remove('live');
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-section-title">Active Breakers</div>
                    <div class="context-header">
                        <span>TF</span>
                        <span>Sym</span>
                        <span>Dir</span>
                        <span>Fib</span>
                        <span>St</span>
                    </div>
                    <div class="context-grid">
                        ${contextRows.join('')}
                    </div>
                </div>
                
                <div class="context-summary">
                    <div class="context-summary-row">
                        <span class="context-summary-label">NQ</span>
                        <span class="context-summary-value"><span class="arrow-bull">${nqBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${nqBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                    <div class="context-summary-row">
                        <span class="context-summary-label">ES</span>
                        <span class="context-summary-value"><span class="arrow-bull">${esBull}<span class="arrow-up-sm"></span></span> <span class="arrow-bear">${esBear}<span class="arrow-down-sm"></span></span></span>
                    </div>
                </div>
            `;
        }
        
        // ===== SELECTION =====
        function selectBreaker(breakerId) {
            // Clear previous selection
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.stack-item.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.smt-marker.selected').forEach(el => {
                el.classList.remove('selected');
            });
            clearEntryHighlight();
            selectedEntryMin = null;
            selectedSmtId = null;
            
            // Toggle selection
            if (selectedBreakerId === breakerId) {
                selectedBreakerId = null;
                // Keep confluence view at locked time or show live
                if (lockedConfluenceMin !== null) {
                    showCursorConfluence(lockedConfluenceMin);
                } else if (isLive) {
                    showLiveConfluence();
                } else {
                    showEmptyPanel();
                }
            } else {
                selectedBreakerId = breakerId;
                
                // Highlight selected bar on chart
                document.querySelectorAll(`.breaker-bar[data-breaker-id="${breakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                
                // Highlight selected item in confluence panel
                document.querySelectorAll(`.stack-item[data-breaker-id="${breakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                
                // Scroll breaker into view
                const bars = document.querySelectorAll(`.breaker-bar[data-breaker-id="${breakerId}"]`);
                if (bars.length > 0) {
                    const bar = bars[0];
                    const container = document.getElementById('scroll-container');
                    const barRect = bar.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    
                    // Check if bar is outside visible area
                    if (barRect.left < containerRect.left || barRect.right > containerRect.right) {
                        const breaker = allData.find(d => d.id === breakerId);
                        if (breaker) {
                            const targetScroll = (breaker.startMin - windowStartMin) * PIXELS_PER_MINUTE - containerRect.width / 3;
                            container.scrollLeft = Math.max(0, targetScroll);
                        }
                    }
                }
                
                // Keep confluence view - don't show breaker detail
                if (lockedConfluenceMin !== null) {
                    showCursorConfluence(lockedConfluenceMin);
                } else if (isLive) {
                    showLiveConfluence();
                }
            }
            
            // Update entry line and marker styling
            document.querySelectorAll('.entry-line').forEach(el => {
                el.classList.remove('selected');
            });
        }
        
        function selectEntry(entryMin) {
            // Clear previous selection
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.smt-marker.selected').forEach(el => {
                el.classList.remove('selected');
            });
            selectedBreakerId = null;
            selectedSmtId = null;
            
            // Toggle selection - use confluence view
            if (selectedEntryMin === entryMin && lockedConfluenceMin === entryMin) {
                selectedEntryMin = null;
                lockedConfluenceMin = null;
                clearEntryHighlight();
                if (isLive) {
                    showLiveConfluence();
                } else {
                    showEmptyPanel();
                }
            } else {
                selectedEntryMin = entryMin;
                lockedConfluenceMin = entryMin;
                highlightActiveAtEntry(entryMin);
                showCursorConfluence(entryMin);
            }
            
            // Update entry line and marker styling
            document.querySelectorAll('.entry-line').forEach(el => {
                if (parseInt(el.dataset.entryMin) === selectedEntryMin) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });
        }
        
        function selectTimeContext(clickedMin) {
            // Clear previous selections
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.smt-marker.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.entry-line').forEach(el => {
                el.classList.remove('selected');
            });
            selectedBreakerId = null;
            selectedSmtId = null;
            selectedEntryMin = null;
            
            // Toggle lock on confluence view
            if (lockedConfluenceMin === clickedMin) {
                // Clicking same time unlocks
                lockedConfluenceMin = null;
                clearEntryHighlight();
                if (isLive) {
                    showLiveConfluence();
                } else {
                    showEmptyPanel();
                }
            } else {
                // Lock confluence at clicked time
                lockedConfluenceMin = clickedMin;
                highlightActiveAtEntry(clickedMin);
                showCursorConfluence(clickedMin);
            }
        }
        
        function highlightActiveAtEntry(entryMin) {
            clearEntryHighlight();
            
            // Track which TF/symbol combinations have active breakers
            const activeLanes = new Set();
            
            // Use cached bars
            for (const bar of renderedBars) {
                if (bar.startMin <= entryMin && bar.endMin >= entryMin) {
                    bar.el.classList.add('active-at-entry');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('has-confluence');
                }
            }
        }
        
        function clearEntryHighlight() {
            for (const bar of renderedBars) {
                bar.el.classList.remove('active-at-entry');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('has-confluence');
            }
        }
        
        // Cursor highlighting (yellow) - separate from live/selected highlighting
        function highlightCursorActive(cursorMin) {
            clearCursorHighlight();
            clearLiveHighlight(); // Clear live highlight when cursor is active
            
            const activeLanes = new Set();
            
            // Use cached bars instead of querySelectorAll
            for (const bar of renderedBars) {
                if (bar.startMin <= cursorMin && bar.endMin >= cursorMin) {
                    bar.el.classList.add('cursor-active');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('cursor-confluence');
                }
            }
        }
        
        function clearCursorHighlight() {
            // Use cached bars instead of querySelectorAll
            for (const bar of renderedBars) {
                bar.el.classList.remove('cursor-active');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('cursor-confluence');
            }
        }
        
        // Live highlighting (green) - for live mode current time
        function highlightLiveActive() {
            clearLiveHighlight();
            
            // Use actual current time, not last data time
            const now = new Date();
            const currentMin = Math.floor(now.getTime() / 60000);
            
            const activeLanes = new Set();
            
            // Use cached bars
            for (const bar of renderedBars) {
                if (bar.startMin <= currentMin && bar.endMin >= currentMin) {
                    bar.el.classList.add('live-active');
                    activeLanes.add(`${bar.tf}-${bar.symbol}`);
                }
            }
            
            // Use cached lane labels
            for (const label of renderedLaneLabels) {
                if (activeLanes.has(`${label.tf}-${label.symbol}`)) {
                    label.el.classList.add('live-confluence');
                }
            }
        }
        
        function clearLiveHighlight() {
            for (const bar of renderedBars) {
                bar.el.classList.remove('live-active');
            }
            for (const label of renderedLaneLabels) {
                label.el.classList.remove('live-confluence');
            }
        }
        
        // ===== VIEWPORT DRAG TO PAN =====
        let vpHandlersSetup = false;
        
        function setupViewportHandlers() {
            if (vpHandlersSetup) return;
            vpHandlersSetup = true;
            
            const track = document.getElementById('timeline-track');
            const viewport = document.getElementById('viewport-indicator');
            
            if (!track || !viewport) return;
            
            let isDragging = false;
            let hasDragged = false;
            let startX = 0;
            let startScrollLeft = 0;
            
            // Drag viewport to scroll chart
            viewport.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                hasDragged = false;
                startX = e.clientX;
                
                const container = document.getElementById('scroll-container');
                startScrollLeft = container ? container.scrollLeft : 0;
                viewport.style.cursor = 'grabbing';
            });
            
            // Click on track to jump
            track.addEventListener('click', (e) => {
                if (e.target !== track || hasDragged) {
                    hasDragged = false;
                    return;
                }
                
                if (dataMinTime === 0 || dataMaxTime === 0) return;
                
                const container = document.getElementById('scroll-container');
                const chartInner = document.getElementById('chart-inner');
                if (!container || !chartInner) return;
                
                const trackRect = track.getBoundingClientRect();
                const clickPct = (e.clientX - trackRect.left) / trackRect.width;
                const totalRange = dataMaxTime - dataMinTime;
                const clickMin = dataMinTime + clickPct * totalRange;
                
                // Calculate scroll position to center on clicked time
                const chartWidth = chartInner.offsetWidth;
                const viewportWidth = container.clientWidth;
                const windowRange = windowEndMin - windowStartMin;
                
                // Map clicked time to scroll position
                const timeInWindow = clickMin - windowStartMin;
                const scrollTarget = (timeInWindow / windowRange) * chartWidth - viewportWidth / 2;
                
                container.scrollLeft = Math.max(0, Math.min(scrollTarget, chartWidth - viewportWidth));
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                if (dataMinTime === 0 || dataMaxTime === 0) return;
                
                hasDragged = true;
                
                const container = document.getElementById('scroll-container');
                const chartInner = document.getElementById('chart-inner');
                const trackEl = document.getElementById('timeline-track');
                if (!container || !chartInner || !trackEl) return;
                
                const trackRect = trackEl.getBoundingClientRect();
                const trackWidth = trackRect.width;
                const chartWidth = chartInner.offsetWidth;
                const viewportWidth = container.clientWidth;
                const maxScroll = chartWidth - viewportWidth;
                
                if (maxScroll <= 0) return;
                
                const totalRange = dataMaxTime - dataMinTime;
                const windowRange = windowEndMin - windowStartMin;
                
                // Map drag distance on track to scroll distance
                const dx = e.clientX - startX;
                const dPctOfTotal = dx / trackWidth;
                const dTime = dPctOfTotal * totalRange;
                const dScroll = (dTime / windowRange) * chartWidth;
                
                container.scrollLeft = Math.max(0, Math.min(startScrollLeft + dScroll, maxScroll));
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    viewport.style.cursor = 'grab';
                }
            });
        }
        
        // ===== SCROLL =====
        let scrollTimeout;
        
        function onScroll() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(updateViewportFromScroll, 30);
            
            const container = document.getElementById('scroll-container');
            const header = document.getElementById('time-header');
            header.style.transform = `translateX(${-container.scrollLeft}px)`;
            
            // Update sticky date indicator
            updateStickyDate(container.scrollLeft);
        }
        
        function updateStickyDate(scrollLeft) {
            // Disabled - using date in time labels instead
            const stickyDate = document.getElementById('sticky-date');
            if (stickyDate) stickyDate.classList.remove('visible');
        }
        
        function updateViewportFromScroll() {
            if (dataMinTime === 0 || dataMaxTime === 0) return;
            
            const container = document.getElementById('scroll-container');
            const chartInner = document.getElementById('chart-inner');
            if (!container || !chartInner) return;
            
            const chartWidth = chartInner.offsetWidth;
            const viewportWidth = container.clientWidth;
            const scrollLeft = container.scrollLeft;
            
            if (chartWidth <= 0) return;
            
            const totalDataRange = dataMaxTime - dataMinTime;
            const windowRange = windowEndMin - windowStartMin;
            
            // Calculate visible time range based on scroll
            const scrollPct = chartWidth > viewportWidth ? scrollLeft / (chartWidth - viewportWidth) : 0;
            const visibleTimeWidth = (viewportWidth / chartWidth) * windowRange;
            const visibleStartMin = windowStartMin + scrollPct * (windowRange - visibleTimeWidth);
            const visibleEndMin = visibleStartMin + visibleTimeWidth;
            
            // Map to viewport bar position
            const startPct = Math.max(0, ((visibleStartMin - dataMinTime) / totalDataRange) * 100);
            const endPct = Math.min(100, ((visibleEndMin - dataMinTime) / totalDataRange) * 100);
            const widthPct = Math.max(2, endPct - startPct);
            
            const vpEl = document.getElementById('viewport-indicator');
            if (vpEl) {
                vpEl.style.left = startPct + '%';
                vpEl.style.width = widthPct + '%';
            }
        }
        
        function updateViewportIndicator() {
            // Update time labels
            if (dataMinTime > 0 && dataMaxTime > 0) {
                document.getElementById('data-start').textContent = minToDateTime(dataMinTime);
            }
            
            // Update viewport bar position based on current scroll
            updateViewportFromScroll();
        }
        
        // ===== AUTO REFRESH =====
        function setRefreshInterval() {
            if (refreshTimer) clearInterval(refreshTimer);
            if (countdownTimer) clearInterval(countdownTimer);
            
            const interval = parseInt(document.getElementById('refresh-interval').value);
            const countdownEl = document.getElementById('countdown');
            
            if (interval === 0) {
                countdownEl.textContent = '';
                return;
            }
            
            countdownSecs = interval;
            countdownEl.textContent = interval + 's';
            
            countdownTimer = setInterval(() => {
                countdownSecs--;
                if (countdownSecs <= 0) countdownSecs = interval;
                countdownEl.textContent = countdownSecs + 's';
            }, 1000);
            
            refreshTimer = setInterval(() => {
                loadData();
                countdownSecs = interval;
            }, interval * 1000);
        }
        
        // ===== ANALYSIS MODAL =====
        const ANALYSIS_DIMENSIONS = {
            direction: [
                { code: 'D1', name: 'NQ Alignment', key: 'd1_nq_alignment' },
                { code: 'D2', name: 'ES Alignment', key: 'd2_es_alignment' },
                { code: 'D3', name: 'Bearish Inversion', key: 'd3_bearish_inversion' }
            ],
            support: [
                { code: 'S1', name: 'Premium/Discount', key: 's1_premium_discount' },
                { code: 'S2', name: 'Stacked Breakers', key: 's2_stacked_breakers' },
                { code: 'S3', name: 'Stacked FVGs', key: 's3_stacked_fvgs' }
            ],
            resistance: [
                { code: 'R1', name: 'Blocking Breakers', key: 'r1_blocking_breakers' },
                { code: 'R2', name: 'Blocking FVGs', key: 'r2_blocking_fvgs' }
            ],
            energy: [
                { code: 'E1', name: 'Formation FVG', key: 'e1_formation_fvg' },
                { code: 'E2', name: 'Formation Sweep', key: 'e2_formation_sweep' },
                { code: 'E3', name: 'Formation SMT', key: 'e3_formation_smt' },
                { code: 'E4', name: 'Bullish Attraction', key: 'e4_bullish_attraction' },
                { code: 'E5', name: 'Bearish Attraction', key: 'e5_bearish_attraction' },
                { code: 'E6', name: 'Daily Burn', key: 'e6_daily_burn' }
            ],
            gate: [
                { code: 'G1', name: 'Trading Hours', key: 'g1_trading_hours' },
                { code: 'G2', name: 'News Blackout', key: 'g2_news_blackout' },
                { code: 'G3', name: 'Price Volatility', key: 'g3_price_volatility' },
                { code: 'G4', name: 'Market Volatility', key: 'g4_market_volatility' },
                { code: 'G5', name: 'Risk/Reward', key: 'g5_risk_reward' },
                { code: 'G6', name: 'Consecutive Losses', key: 'g6_consecutive_losses' },
                { code: 'G7', name: 'SPY Trend', key: 'g7_spy_trend' }
            ]
        };
        
        const CATEGORY_LABELS = {
            direction: 'Direction',
            support: 'Support',
            resistance: 'Resistance',
            energy: 'Energy',
            gate: 'Gate (All Must Pass)'
        };
        
        function showAnalysisModal(breakerId = null) {
            const modal = document.getElementById('analysis-modal');
            const heroId = document.getElementById('analysis-hero-id');
            
            if (!breakerId) {
                heroId.textContent = 'No breaker selected';
                showAnalysisError('Select a 1M Bull NQ breaker to view analysis');
                modal.classList.add('visible');
                document.addEventListener('keydown', handleModalEscape);
                return;
            }
            
            // Find the breaker to get its start time and display_id
            const breaker = allData.find(d => d.id === breakerId);
            if (breaker) {
                heroId.textContent = breaker.displayId || breakerId;
                // Fetch confirmation data from Firebase for this breaker's time
                fetchConfirmationData(breakerId, breaker.startMin);
            } else {
                heroId.textContent = breakerId;
                showAnalysisError('Breaker not found in loaded data');
            }
            
            modal.classList.add('visible');
            document.addEventListener('keydown', handleModalEscape);
        }
        
        function showAnalysisError(message) {
            const contentContainer = document.getElementById('analysis-content');
            const tabsContainer = document.getElementById('analysis-tabs');
            const decisionBadge = document.getElementById('analysis-decision-badge');
            const scoreBig = document.getElementById('analysis-score-big');
            const heroMeta = document.getElementById('analysis-hero-meta');
            
            decisionBadge.textContent = 'ERROR';
            decisionBadge.className = 'analysis-decision-badge fail';
            scoreBig.textContent = '--/21';
            heroMeta.textContent = '';
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = `
                <div style="padding: 40px; text-align: center; color: #f87171;">
                    <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
                    <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">No Confirmation Data</div>
                    <div style="font-size: 13px; color: #888;">${message}</div>
                </div>
            `;
        }
        
        function fetchConfirmationData(breakerId, startMin) {
            // Get display_id for UI
            const breaker = allData.find(d => d.id === breakerId);
            const displayId = breaker?.displayId || breakerId;
            
            console.log(`📊 Fetching confirmation for key: ${breakerId}`);
            
            // Show loading state
            document.getElementById('analysis-hero-id').textContent = displayId + ' · Loading...';
            
            // Query the confirmations collection directly (not inside snapshots)
            const confirmationsUrl = FIREBASE_URL.replace('snapshots.json', 'confirmations.json');
            
            fetch(confirmationsUrl)
                .then(r => r.json())
                .then(data => {
                    if (!data || Object.keys(data).length === 0) {
                        console.warn('No confirmations found');
                        document.getElementById('analysis-hero-id').textContent = displayId;
                        showAnalysisError(`No confirmations in database`);
                        return;
                    }
                    
                    // Find confirmation matching this breaker_id
                    let confirmationData = null;
                    const allBreakderIds = [];
                    
                    for (const [confKey, conf] of Object.entries(data)) {
                        if (conf && conf.breaker_id) {
                            allBreakderIds.push(conf.breaker_id);
                            if (conf.breaker_id === breakerId) {
                                confirmationData = conf;
                                console.log('✓ Found confirmation data:', confirmationData);
                                break;
                            }
                        }
                    }
                    
                    if (confirmationData) {
                        document.getElementById('analysis-hero-id').textContent = displayId;
                        renderAnalysisContent(transformConfirmationData(confirmationData, displayId));
                    } else {
                        console.warn('No confirmation found for this breaker');
                        console.log('📊 Looking for:', breakerId);
                        console.log('📊 Available breaker_ids:', allBreakderIds);
                        
                        document.getElementById('analysis-hero-id').textContent = displayId;
                        showAnalysisError(`No confirmation found for this breaker`);
                    }
                })
                .catch(err => {
                    console.error('Error fetching confirmation:', err);
                    document.getElementById('analysis-hero-id').textContent = displayId;
                    showAnalysisError(`Firebase error: ${err.message}`);
                });
        }
        
        function transformConfirmationData(conf, displayId) {
            // Transform Firebase confirmation structure to analysis modal format
            // Firebase stores confirmation with: breaker_id, confirmation_time, decision, decision_score, dimensions
            // dimensions contains: gate, direction, support, resistance, energy
            const dims = conf.dimensions || {};
            
            return {
                breaker_id: displayId,  // Use displayId for UI
                confirmation_time: conf.confirmation_time || new Date().toISOString(),
                decision: conf.decision || 'PENDING',
                decision_score: conf.decision_score || 0,
                dimensions: {
                    gate: dims.gate || {},
                    direction: dims.direction || {},
                    support: dims.support || {},
                    resistance: dims.resistance || {},
                    energy: dims.energy || {}
                }
            };
        }
        
        function closeAnalysisModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('analysis-modal');
            modal.classList.remove('visible');
            document.removeEventListener('keydown', handleModalEscape);
        }
        
        function handleModalEscape(e) {
            if (e.key === 'Escape') {
                closeAnalysisModal();
            }
        }
        
        function toggleDimension(el) {
            el.closest('.analysis-dimension').classList.toggle('expanded');
        }
        
        function toggleCategory(btn, categoryEl) {
            const dimensions = categoryEl.querySelectorAll('.analysis-dimension');
            const allExpanded = Array.from(dimensions).every(d => d.classList.contains('expanded'));
            
            dimensions.forEach(d => {
                if (allExpanded) {
                    d.classList.remove('expanded');
                } else {
                    d.classList.add('expanded');
                }
            });
            
            btn.textContent = allExpanded ? '▼ Expand All' : '▲ Collapse All';
        }
        
        // ===== CONFLUENCE MODAL =====
        const CONFLUENCE_CARD_HEIGHT = 220; // full chart height, no header
        const CONFLUENCE_CARD_GAP = 8;
        const CONFLUENCE_PPM = 25; // pixels per minute
        
        let confluenceModalOpen = false;
        let confluenceScrollHandler = null;
        let confluenceMoveHandler = null;
        
        function openConfluenceModal() {
            const modal = document.getElementById('confluence-modal');
            modal.classList.add('visible');
            confluenceModalOpen = true;
            
            renderConfluenceModal();
            setupConfluenceHandlers();
            
            // Scroll to show latest content (rightmost)
            setTimeout(() => {
                const scroll = document.getElementById('confluence-scroll');
                scroll.scrollLeft = scroll.scrollWidth - scroll.clientWidth;
            }, 50);
            
            // ESC to close
            document.addEventListener('keydown', handleConfluenceEscape);
        }
        
        function closeConfluenceModal() {
            const modal = document.getElementById('confluence-modal');
            modal.classList.remove('visible');
            confluenceModalOpen = false;
            
            // Clean up cursor labels
            const labelsContainer = document.getElementById('confluence-labels-container');
            if (labelsContainer) labelsContainer.innerHTML = '';
            
            // Remove handlers
            document.removeEventListener('keydown', handleConfluenceEscape);
            
            const scroll = document.getElementById('confluence-scroll');
            if (confluenceScrollHandler) scroll.removeEventListener('scroll', confluenceScrollHandler);
            if (confluenceMoveHandler) scroll.removeEventListener('mousemove', confluenceMoveHandler);
        }
        
        function handleConfluenceEscape(e) {
            if (e.key === 'Escape') {
                closeConfluenceModal();
            }
        }
        
        function renderConfluenceModal() {
            if (allData.length === 0) {
                document.getElementById('confluence-chart-inner').innerHTML = 
                    '<div class="confluence-no-data">No breaker data</div>';
                return;
            }
            
            // Calculate time range
            const minTime = Math.min(...allData.map(d => d.startMin));
            const maxTime = Math.max(...allData.map(d => d.endMin));
            const chartWidth = (maxTime - minTime + 5) * CONFLUENCE_PPM; // +5 min padding
            
            // Render time header
            renderConfluenceTimeHeader(minTime, maxTime, chartWidth);
            
            // Sort breakers by priority (1m→4h, NQ→ES, bull→bear), then by start time
            // Higher priority breakers get first chance at top rows
            const tfOrder = { '1m': 1, '5m': 2, '15m': 3, '1h': 4, '1hr': 4, '4h': 5, '4hr': 5 };
            const symOrder = { 'NQ': 1, 'ES': 2 };
            
            const sortedBreakers = [...allData].sort((a, b) => {
                const tfA = tfOrder[a.tf.replace('hr', 'h')] || 99;
                const tfB = tfOrder[b.tf.replace('hr', 'h')] || 99;
                if (tfA !== tfB) return tfA - tfB;
                const symA = symOrder[a.symbol] || 99;
                const symB = symOrder[b.symbol] || 99;
                if (symA !== symB) return symA - symB;
                if (a.dir !== b.dir) return a.dir === 'bull' ? -1 : 1;
                return a.startMin - b.startMin;
            });
            
            // Position cards - greedy assignment by priority
            // Higher priority breakers are processed first and get top rows
            const cardHeight = CONFLUENCE_CARD_HEIGHT + CONFLUENCE_CARD_GAP;
            const rowRanges = []; // Track occupied time ranges per row: [{start, end}, ...]
            
            const chartInner = document.getElementById('confluence-chart-inner');
            chartInner.style.width = (chartWidth + 40) + 'px';
            
            let html = '';
            let maxY = 0;
            
            sortedBreakers.forEach(breaker => {
                const startX = (breaker.startMin - minTime) * CONFLUENCE_PPM + 20;
                const width = Math.max((breaker.endMin - breaker.startMin) * CONFLUENCE_PPM, 100);
                const endX = startX + width;
                
                // Find first row where this breaker fits (no overlap)
                let row = 0;
                let foundRow = false;
                
                while (!foundRow) {
                    if (!rowRanges[row]) {
                        rowRanges[row] = [];
                        foundRow = true;
                    } else {
                        // Check if any existing range in this row overlaps
                        let overlaps = false;
                        for (const range of rowRanges[row]) {
                            if (!(endX <= range.start || startX >= range.end)) {
                                overlaps = true;
                                break;
                            }
                        }
                        if (!overlaps) {
                            foundRow = true;
                        } else {
                            row++;
                        }
                    }
                }
                
                // Add this breaker's range to the row
                rowRanges[row].push({ start: startX, end: endX + 10 }); // +10 gap
                
                const y = row * cardHeight;
                maxY = Math.max(maxY, y + cardHeight);
                
                html += generateConfluenceCard(breaker, startX, y, width, minTime);
            });
            
            chartInner.innerHTML = html;
            chartInner.style.minHeight = (maxY + 40) + 'px';
        }
        
        function renderConfluenceTimeHeader(minTime, maxTime, chartWidth) {
            const timeInner = document.getElementById('confluence-time-inner');
            timeInner.style.width = (chartWidth + 40) + 'px';
            
            let html = '';
            // Tick every 5 minutes
            for (let t = Math.ceil(minTime / 5) * 5; t <= maxTime + 5; t += 5) {
                const x = (t - minTime) * CONFLUENCE_PPM + 20; // +20 to align with cards
                const timeStr = minToTime(t);
                html += `<span class="confluence-time-tick" style="left:${x}px">${timeStr}</span>`;
            }
            
            timeInner.innerHTML = html;
        }
        
        function generateConfluenceCard(breaker, x, y, width, globalMinTime) {
            const tf = breaker.tf.replace('hr', 'h');
            const tfDisplay = TF_DISPLAY[tf] || breaker.tf;
            const tfColor = TF_COLORS[breaker.tf] || '#888';
            const isBull = breaker.dir === 'bull';
            const dirColor = isBull ? '#4ade80' : '#f87171';
            const dirArrow = isBull ? '▲' : '▼';
            const events = breaker.events;
            
            if (!events || events.length < 2) {
                return `
                    <div class="confluence-card" data-breaker-id="${breaker.id}" style="left:${x}px; top:${y}px; width:${width}px;">
                        <div class="confluence-card-body">
                            <div style="display:flex; align-items:center; justify-content:center; height:100%; color:#333;">No data</div>
                        </div>
                    </div>
                `;
            }
            
            const chart = generateConfluenceChart(breaker, dirColor, width, tfDisplay, tfColor);
            
            return `
                <div class="confluence-card" data-breaker-id="${breaker.id}" style="left:${x}px; top:${y}px; width:${width}px;">
                    <div class="confluence-card-body">
                        ${chart}
                    </div>
                </div>
            `;
        }
        
        function generateConfluenceChart(breaker, dirColor, cardWidth, tfDisplay, tfColor) {
            const events = breaker.events;
            const width = cardWidth;
            const height = 220;
            // Adjust padding for narrow cards - no bottom padding needed without time labels
            const padRight = Math.min(50, cardWidth * 0.13);
            const padLeft = Math.min(32, cardWidth * 0.09);
            const padding = { top: 12, right: padRight, bottom: 8, left: padLeft };
            const chartWidth = Math.max(width - padding.left - padding.right, 20);
            const chartHeight = height - padding.top - padding.bottom;
            
            const minTime = events[0].absMin;
            const maxTime = events[events.length - 1].absMin;
            const timeRange = maxTime - minTime || 1;
            
            const breakerPrice = breaker.price || 0;
            const isBull = breaker.dir === 'bull';
            
            const lastEvent = events[events.length - 1];
            const currentPrice = lastEvent.price || 0;
            
            // Fixed Y-axis: always 0-4
            const fibCeil = 4;
            
            const fibToY = (fib) => {
                if (isBull) {
                    return padding.top + chartHeight - (fib / fibCeil) * chartHeight;
                } else {
                    return padding.top + (fib / fibCeil) * chartHeight;
                }
            };
            
            let sampledEvents = events;
            if (events.length > 100) {
                const step = Math.ceil(events.length / 80);
                sampledEvents = events.filter((e, i) => i === 0 || i === events.length - 1 || i % step === 0);
            }
            
            const fibPoints = sampledEvents.map(e => ({
                x: padding.left + ((e.absMin - minTime) / timeRange) * chartWidth,
                y: fibToY(e.fib || 0),
                fib: e.fib || 0
            }));
            
            const peakPoints = sampledEvents.map(e => ({
                x: padding.left + ((e.absMin - minTime) / timeRange) * chartWidth,
                y: fibToY(e.maxFib || e.fib || 0),
                fib: e.maxFib || e.fib || 0
            }));
            
            let peakX = fibPoints[0].x, peakY = fibPoints[0].y, peakFib = 0;
            fibPoints.forEach(p => {
                if (p.fib > peakFib) { peakFib = p.fib; peakX = p.x; peakY = p.y; }
            });
            
            const fibPath = fibPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            const peakPath = peakPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            const zeroY = fibToY(0);
            const areaPath = fibPath + ` L ${fibPoints[fibPoints.length-1].x} ${zeroY} L ${fibPoints[0].x} ${zeroY} Z`;
            const breakerY = fibToY(1.0);
            
            let yGrid = '';
            const gridVals = [0, 1, 2, 3, 4];
            gridVals.forEach(val => {
                const y = fibToY(val);
                const isBreaker = val === 1;
                const isFib4 = val === 4;
                // Fib 4 uses purple to match cursor, subtle like other lines
                const lineColor = isBreaker ? '#444' : (isFib4 ? '#7c3aed' : '#1e1e21');
                const lineWidth = 0.5;
                const textColor = isBreaker ? '#666' : (isFib4 ? '#9d7aed' : '#3a3a3e');
                const fontWeight = isBreaker ? 500 : 400;
                yGrid += `<line x1="${padding.left}" y1="${y}" x2="${padding.left + chartWidth}" y2="${y}" stroke="${lineColor}" stroke-width="${lineWidth}"/>`;
                yGrid += `<text x="${padding.left - 3}" y="${y + 3}" text-anchor="end" fill="${textColor}" font-size="9" font-family="Roboto Mono" font-weight="${fontWeight}">${val.toFixed(1)}</text>`;
            });
            
            const breakerPriceLabel = `<text x="${width - 2}" y="${breakerY + 3}" text-anchor="end" fill="#666" font-size="10" font-family="Roboto Mono">${Math.round(breakerPrice)}</text>`;
            
            let dots = '';
            let dotPoints = peakPoints;
            if (peakPoints.length > 12) {
                const step = Math.ceil(peakPoints.length / 10);
                dotPoints = peakPoints.filter((p, i) => i === 0 || i === peakPoints.length - 1 || i % step === 0);
            }
            dotPoints.forEach(p => { dots += `<circle cx="${p.x}" cy="${p.y}" r="2" fill="${dirColor}"/>`; });
            
            const lastPoint = fibPoints[fibPoints.length - 1];
            const lastPointY = lastPoint ? lastPoint.y : 0;
            const currentPriceLabel = lastPoint && currentPrice > 0 ? 
                `<text x="${width - 2}" y="${lastPointY + 3}" text-anchor="end" fill="#fb923c" font-size="10" font-family="Roboto Mono" font-weight="500">${Math.round(currentPrice)}</text>` : '';
            
            return `
                <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="display:block; width:100%; height:220px;">
                    ${yGrid}
                    <path d="${areaPath}" fill="${dirColor}" fill-opacity="0.15"/>
                    <path d="${peakPath}" fill="none" stroke="${dirColor}" stroke-width="1.5" stroke-dasharray="3,2"/>
                    <path d="${fibPath}" fill="none" stroke="${dirColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    ${dots}
                    <circle cx="${peakX}" cy="${peakY}" r="5" fill="${dirColor}" stroke="#131416" stroke-width="1.5"/>
                    <text x="${peakX}" y="${peakY + (isBull ? -7 : 14)}" text-anchor="middle" fill="${dirColor}" font-size="11" font-family="Roboto Mono" font-weight="600">${peakFib.toFixed(2)}</text>
                    ${lastPoint ? `<circle cx="${lastPoint.x}" cy="${lastPoint.y}" r="3" fill="#fb923c"/>` : ''}
                    ${breakerPriceLabel}
                    ${currentPriceLabel}
                </svg>
            `;
        }
        
        function setupConfluenceHandlers() {
            const scroll = document.getElementById('confluence-scroll');
            const timeHeader = document.getElementById('confluence-time-header');
            const cursorLine = document.getElementById('confluence-cursor-line');
            const cursorTime = document.getElementById('confluence-cursor-time');
            const labelsContainer = document.getElementById('confluence-labels-container');
            
            let lastMouseX = null;
            let lastMouseY = null;
            
            // Function to update cursor labels
            function updateCursorLabels(x, y) {
                const rect = scroll.getBoundingClientRect();
                const timeHeaderRect = timeHeader.getBoundingClientRect();
                
                // Clear all existing cursor labels
                labelsContainer.innerHTML = '';
                
                if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                    cursorLine.style.left = x + 'px';
                    cursorLine.classList.add('visible');
                    
                    // Calculate time
                    const scrollX = scroll.scrollLeft + (x - rect.left) - 20;
                    const minTime = allData.length > 0 ? Math.min(...allData.map(d => d.startMin)) : 0;
                    const cursorMin = Math.round(minTime + Math.max(0, scrollX) / CONFLUENCE_PPM);
                    
                    // Show time badge - align with time header
                    cursorTime.textContent = minToTime(cursorMin);
                    cursorTime.style.left = x + 'px';
                    cursorTime.style.top = (timeHeaderRect.top + timeHeaderRect.height / 2 - 10) + 'px';
                    cursorTime.style.display = 'block';
                    
                    // Find all cards that the cursor line passes through
                    const cards = document.querySelectorAll('.confluence-card');
                    cards.forEach(card => {
                        const cardRect = card.getBoundingClientRect();
                        
                        // Check if cursor X is within this card's horizontal bounds
                        if (x >= cardRect.left && x <= cardRect.right) {
                            const breakerId = card.dataset.breakerId;
                            const breaker = allData.find(b => b.id === breakerId);
                            
                            if (breaker && breaker.events && breaker.events.length > 0) {
                                const tf = breaker.tf.replace('hr', 'h').toUpperCase();
                                const tfColor = TF_COLORS[breaker.tf] || '#888';
                                const dirColor = breaker.dir === 'bull' ? '#4ade80' : '#f87171';
                                const dirArrow = breaker.dir === 'bull' ? '▲' : '▼';
                                
                                // Find fib value at cursor time
                                const events = breaker.events;
                                let fibAtCursor = 0;
                                let peakAtCursor = 0;
                                let priceAtCursor = 0;
                                
                                for (let i = 0; i < events.length; i++) {
                                    if (events[i].absMin <= cursorMin) {
                                        fibAtCursor = events[i].fib || 0;
                                        peakAtCursor = events[i].maxFib || events[i].fib || 0;
                                        priceAtCursor = events[i].price || 0;
                                    }
                                }
                                
                                const breakerPrice = breaker.price || 0;
                                
                                // Create label with fixed positioning
                                const label = document.createElement('div');
                                label.className = 'confluence-cursor-label';
                                label.style.borderRight = `2px solid ${dirColor}`;
                                
                                // Format: TF SYM DIR | Fib: x.xx/x.xx | Brkr: xxxxx | Now: xxxxx
                                label.innerHTML = `<span style="color:${tfColor}">${tf}</span> <span style="color:#666">${breaker.symbol}</span> <span style="color:${dirColor}">${dirArrow}</span> <span style="color:#555">|</span> <span style="color:${dirColor}">${fibAtCursor.toFixed(2)}</span><span style="color:#555">/</span><span style="color:#888">${peakAtCursor.toFixed(2)}</span> <span style="color:#555">|</span> <span style="color:#888">B:</span><span style="color:#aaa">${Math.round(breakerPrice)}</span> <span style="color:#555">|</span> <span style="color:#888">P:</span><span style="color:#fb923c">${Math.round(priceAtCursor)}</span>`;
                                
                                // Position label to left of cursor at card's top
                                // Use fixed positioning relative to viewport
                                label.style.top = (cardRect.top + 4) + 'px';
                                
                                // Temporarily add to measure width
                                label.style.visibility = 'hidden';
                                labelsContainer.appendChild(label);
                                const labelWidth = label.offsetWidth;
                                label.style.visibility = 'visible';
                                
                                // Position to left of cursor
                                label.style.left = (x - labelWidth - 6) + 'px';
                            }
                        }
                    });
                } else {
                    cursorLine.classList.remove('visible');
                    cursorTime.style.display = 'none';
                }
            }
            
            // Sync time header scroll AND update cursor labels
            confluenceScrollHandler = () => {
                timeHeader.scrollLeft = scroll.scrollLeft;
                // Update labels on scroll using last known mouse position
                // Use requestAnimationFrame to ensure DOM has updated
                if (lastMouseX !== null && lastMouseY !== null) {
                    requestAnimationFrame(() => {
                        updateCursorLabels(lastMouseX, lastMouseY);
                    });
                }
            };
            scroll.addEventListener('scroll', confluenceScrollHandler);
            
            // Cursor line and on-card labels
            confluenceMoveHandler = (e) => {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                updateCursorLabels(e.clientX, e.clientY);
            };
            scroll.addEventListener('mousemove', confluenceMoveHandler);
            
            scroll.addEventListener('mouseleave', () => {
                lastMouseX = null;
                lastMouseY = null;
                cursorLine.classList.remove('visible');
                cursorTime.style.display = 'none';
                labelsContainer.innerHTML = '';
            });
            
            // Also update on wheel for Mac trackpad
            scroll.addEventListener('wheel', () => {
                if (lastMouseX !== null && lastMouseY !== null) {
                    // Double requestAnimationFrame for Mac compatibility
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            updateCursorLabels(lastMouseX, lastMouseY);
                        });
                    });
                }
            }, { passive: true });
        }
        
        function renderZoneChart(dimData, isSupport) {
            if (!dimData.zones || dimData.zones.length === 0) {
                if (dimData.target) {
                    // Resistance with no obstacles - show clear path
                    return `
                        <div class="analysis-zone-chart">
                            <div class="analysis-zone-chart-title">Visual: Entry to Target</div>
                            <div style="height: 100px; position: relative; display: flex; align-items: center; justify-content: center;">
                                <svg width="100%" height="100" viewBox="0 0 400 100">
                                    <defs>
                                        <linearGradient id="clearPath" x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:0.8" />
                                            <stop offset="100%" style="stop-color:#4ade80;stop-opacity:0.8" />
                                        </linearGradient>
                                    </defs>
                                    <line x1="50" y1="50" x2="350" y2="50" stroke="url(#clearPath)" stroke-width="3" stroke-dasharray="8,4"/>
                                    <circle cx="50" cy="50" r="8" fill="#60a5fa"/>
                                    <text x="50" y="75" text-anchor="middle" fill="#60a5fa" font-size="10" font-family="Roboto Mono">Entry</text>
                                    <polygon points="350,50 340,44 340,56" fill="#4ade80"/>
                                    <circle cx="350" cy="50" r="8" fill="#4ade80"/>
                                    <text x="350" y="75" text-anchor="middle" fill="#4ade80" font-size="10" font-family="Roboto Mono">Target</text>
                                    <text x="200" y="30" text-anchor="middle" fill="#4ade80" font-size="11" font-family="Roboto Mono">✓ Clear Path</text>
                                </svg>
                            </div>
                        </div>
                    `;
                }
                return '';
            }
            
            // Calculate price range for chart
            const entry = dimData.entry;
            const target = dimData.target;
            const stop = dimData.stop || (isSupport ? entry - 20 : null);
            
            let allPrices = [entry];
            if (target) allPrices.push(target);
            if (stop) allPrices.push(stop);
            dimData.zones.forEach(z => {
                allPrices.push(z.high, z.low);
            });
            
            const minPrice = Math.min(...allPrices) - 5;
            const maxPrice = Math.max(...allPrices) + 5;
            const priceRange = maxPrice - minPrice;
            const chartHeight = 250;
            
            const priceToY = (price) => {
                return chartHeight - ((price - minPrice) / priceRange * chartHeight);
            };
            
            let zonesHtml = '';
            dimData.zones.forEach(zone => {
                const topY = priceToY(zone.high);
                const bottomY = priceToY(zone.low);
                const height = Math.max(bottomY - topY, 8);
                const isBull = zone.type.toLowerCase().includes('bull');
                const tfClass = 'tf-' + zone.tf.toLowerCase();
                
                zonesHtml += `
                    <div class="analysis-zone-chart-zone ${isBull ? 'bull' : 'bear'} ${tfClass}" 
                         style="top: ${topY}px; height: ${height}px;">
                        <span class="analysis-zone-chart-zone-tf">${zone.tf.toUpperCase()}</span>
                        <span style="margin-left: 8px; opacity: 0.7;">${zone.low.toLocaleString()}-${zone.high.toLocaleString()}</span>
                    </div>
                `;
            });
            
            // Entry line
            const entryY = priceToY(entry);
            zonesHtml += `
                <div class="analysis-zone-chart-line entry" style="top: ${entryY}px;"></div>
                <div class="analysis-zone-chart-current" style="top: ${entryY}px;"></div>
                <div class="analysis-zone-chart-label entry" style="top: ${entryY}px;">► Entry ${entry.toLocaleString()}</div>
            `;
            
            // Target line
            if (target) {
                const targetY = priceToY(target);
                zonesHtml += `
                    <div class="analysis-zone-chart-line target" style="top: ${targetY}px;"></div>
                    <div class="analysis-zone-chart-label target" style="top: ${targetY}px;">◆ Target ${target.toLocaleString()}</div>
                `;
            }
            
            // Stop line (for support)
            if (stop && isSupport) {
                const stopY = priceToY(stop);
                zonesHtml += `
                    <div class="analysis-zone-chart-line stop" style="top: ${stopY}px;"></div>
                    <div class="analysis-zone-chart-label stop" style="top: ${stopY}px;">■ Stop ${stop.toLocaleString()}</div>
                `;
            }
            
            // Price axis labels
            const priceSteps = 5;
            let axisHtml = '';
            for (let i = 0; i <= priceSteps; i++) {
                const price = maxPrice - (priceRange * i / priceSteps);
                const isEntry = Math.abs(price - entry) < priceRange * 0.05;
                const isTarget = target && Math.abs(price - target) < priceRange * 0.05;
                let priceClass = '';
                if (isEntry) priceClass = 'entry';
                else if (isTarget) priceClass = 'target';
                axisHtml += `<div class="analysis-zone-chart-price ${priceClass}">${price.toFixed(0)}</div>`;
            }
            
            return `
                <div class="analysis-zone-chart">
                    <div class="analysis-zone-chart-title">Visual: ${isSupport ? 'Support Zones Below Entry' : 'Resistance Zones to Target'}</div>
                    <div class="analysis-zone-chart-inner">
                        <div class="analysis-zone-chart-axis">
                            ${axisHtml}
                        </div>
                        <div class="analysis-zone-chart-body" style="height: ${chartHeight}px;">
                            ${zonesHtml}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function getExampleData() {
            // Complete Firebase schema from QuantConnect
            return {
                breaker_id: "NQ_1m_20250115_1205",
                confirmation_time: "2025-01-15T12:05",
                decision: "EXECUTE",
                decision_score: 18,
                dimensions: {
                    gate: {
                        g1_trading_hours: {
                            status: "PASS",
                            current_time: "12:05 PM ET",
                            session: "NY_LUNCH",
                            is_tradeable: true,
                            in_no_trade_window: false,
                            no_trade_window_name: null,
                            reason: "Within trading hours"
                        },
                        g2_news_blackout: {
                            status: "PASS",
                            is_clear: true,
                            next_event: null,
                            minutes_until: null,
                            reason: "No scheduled events"
                        },
                        g3_price_volatility: {
                            status: "PASS",
                            nq: { atr_ratio: 1.2, status: "NORMAL" },
                            es: { atr_ratio: 1.1, status: "NORMAL" },
                            combined_status: "NORMAL",
                            reason: "ATR within normal range"
                        },
                        g4_market_volatility: {
                            status: "PASS",
                            current_vix: 15.2,
                            vix_sma: 16.0,
                            vix_ratio: 0.95,
                            vix_status: "STABLE",
                            reason: "VIX stable at 0.95x SMA"
                        },
                        g5_risk_reward: {
                            status: "PASS",
                            entry_price: 21500.0,
                            stop_price: 21480.0,
                            target_price: 21550.0,
                            risk_points: 20.0,
                            reward_points: 50.0,
                            rr_ratio: 2.5,
                            reason: "R:R 2.50 exceeds minimum 2.0"
                        },
                        g6_consecutive_losses: {
                            status: "PASS",
                            losses_1m: 0,
                            losses_5m: 1,
                            max_allowed: 3,
                            reason: "1M: 0 losses, 5M: 1 loss (max 3)"
                        },
                        g7_spy_trend: {
                            status: "PASS",
                            spy_price: 598.50,
                            spy_sma: 595.20,
                            is_above_sma: true,
                            is_near_sma: false,
                            recent_touch: true,
                            bounce_up: false,
                            trend_status: "BULLISH",
                            reason: "SPY bullish: above SMA"
                        }
                    },
                    direction: {
                        d1_nq_alignment: {
                            value: "ALIGNED",
                            bias_4h: "BULLISH",
                            bias_1h: "BULLISH",
                            bias_15m: "BULLISH",
                            high_tf_bias: "BULLISH",
                            confirms_entry: true,
                            reason: "4H BULLISH, 1H BULLISH, 15M BULLISH = ALIGNED"
                        },
                        d2_es_alignment: {
                            value: "CONVERGED",
                            es_bias_4h: "BULLISH",
                            es_bias_1h: "BULLISH",
                            es_bias_15m: "BULLISH",
                            nq_high_tf_bias: "BULLISH",
                            converges_with_nq: true,
                            reason: "ES BULLISH converges with NQ BULLISH"
                        },
                        d3_bearish_inversion: {
                            value: "STRONG",
                            failed_breakers: {
                                nq_1m_bear: true,
                                nq_5m_bear: false,
                                nq_15m_bear: true,
                                es_bear: false
                            },
                            total_failures: 2,
                            highest_tf_failed: "15m",
                            reason: "NQ 15m+NQ 1m bears failed = STRONG inversion"
                        }
                    },
                    support: {
                        s1_premium_discount: {
                            value: "DISCOUNT",
                            zone: "DISCOUNT",
                            current_price: 21500.0,
                            ranges: {
                                weekly: { high: 21800.0, low: 21200.0, position_pct: 50.0 },
                                daily: { high: 21600.0, low: 21400.0, position_pct: 50.0 },
                                session: { high: 21550.0, low: 21450.0, position_pct: 50.0 }
                            },
                            weighted_composite: 25.0,
                            reason: "At 25% = DISCOUNT"
                        },
                        s2_stacked_breakers: {
                            value: "STRONG",
                            strength: "STRONG",
                            total_layers: 3,
                            by_timeframe: { "4h": 1, "1h": 1, "15m": 1, "5m": 0 },
                            highest_tf: "1h",
                            breakers: [
                                { tf: "4h", high: 21480.0, low: 21450.0, age_bars: 120, energy: 0.8 },
                                { tf: "1h", high: 21470.0, low: 21445.0, age_bars: 45, energy: 0.9 },
                                { tf: "15m", high: 21465.0, low: 21440.0, age_bars: 12, energy: 1.0 }
                            ],
                            reason: "4H+1H+15M breakers below = STRONG support"
                        },
                        s3_stacked_fvgs: {
                            value: "MODERATE",
                            strength: "MODERATE",
                            total_layers: 2,
                            by_timeframe: { "4h": 0, "1h": 0, "15m": 1, "5m": 1 },
                            highest_tf: "15m",
                            fvgs: [
                                { tf: "15m", high: 21490.0, low: 21480.0, fill_pct: 20.0 },
                                { tf: "5m", high: 21485.0, low: 21478.0, fill_pct: 0.0 }
                            ],
                            reason: "15M+5M FVGs below = MODERATE support"
                        }
                    },
                    resistance: {
                        r1_blocking_breakers: {
                            value: "FRICTION",
                            strength: "LOW_TF",
                            total_in_path: 1,
                            by_timeframe: { "4h": 0, "1h": 0, "15m": 0, "5m": 1 },
                            highest_blocking_tf: "5m",
                            breakers: [
                                { tf: "5m", high: 21535.0, low: 21525.0, age_bars: 5, energy: 0.6 }
                            ],
                            reason: "5M bear in path = FRICTION"
                        },
                        r2_blocking_fvgs: {
                            value: "CLEAR",
                            strength: "NONE",
                            total_in_path: 0,
                            by_timeframe: { "4h": 0, "1h": 0, "15m": 0, "5m": 0 },
                            highest_blocking_tf: null,
                            fvgs: [],
                            reason: "No bearish FVGs in path = Clear"
                        }
                    },
                    energy: {
                        e1_formation_fvg: {
                            value: "HIGH",
                            strength: "HIGH",
                            has_fvg: true,
                            fvg_details: {
                                size_pct: 45.0,
                                high: 21510.0,
                                low: 21500.0
                            },
                            reason: "FVG 45% of breaker = HIGH energy"
                        },
                        e2_formation_sweep: {
                            value: "MODERATE",
                            strength: "MODERATE",
                            has_sweep: true,
                            sweep_depth_pct: 30.0,
                            sweep_low: 21475.0,
                            impulse_high: 21520.0,
                            impulse_low: 21480.0,
                            reason: "Sweep 30% of impulse = MODERATE"
                        },
                        e3_formation_smt: {
                            value: "MODERATE",
                            strength: "MODERATE",
                            has_divergence: false,
                            divergence_type: null,
                            nq_swing_price: null,
                            es_swing_price: null,
                            reason: "No divergence detected"
                        },
                        e4_bullish_attraction: {
                            value: "HIGH",
                            level: "HIGH",
                            zone_sd: 1.5,
                            sd_phase: "FRESH",
                            zone_high: 21470.0,
                            zone_low: 21450.0,
                            zone_timeframe: "1h",
                            reason: "Support zone at 1.5 SD (FRESH) = HIGH"
                        },
                        e5_bearish_attraction: {
                            value: "HIGH",
                            level: "HIGH",
                            zone_sd: 3.5,
                            sd_phase: "EXHAUSTED",
                            zone_high: 21600.0,
                            zone_low: 21580.0,
                            zone_timeframe: "4h",
                            reason: "Resistance zone at 3.5 SD (EXHAUSTED) = HIGH"
                        },
                        e6_daily_burn: {
                            value: "AVAILABLE",
                            level: "AVAILABLE",
                            burn_pct: 45.0,
                            nq: { daily_range: 180.0, adr_20: 400.0, burn_pct: 45.0 },
                            es: { daily_range: 20.0, adr_20: 50.0, burn_pct: 40.0 },
                            limiting_symbol: "NQ",
                            reason: "NQ at 45% burn = AVAILABLE"
                        }
                    }
                }
            };
        }
        
        function renderAnalysisContent(data) {
            const tabsContainer = document.getElementById('analysis-tabs');
            const contentContainer = document.getElementById('analysis-content');
            const decisionBadge = document.getElementById('analysis-decision-badge');
            const heroId = document.getElementById('analysis-hero-id');
            const heroMeta = document.getElementById('analysis-hero-meta');
            const scoreBig = document.getElementById('analysis-score-big');
            
            // Get nested dimensions
            const dims = data.dimensions || data;
            
            // Update hero section
            const decision = data.decision || 'EXECUTE';
            decisionBadge.textContent = decision;
            decisionBadge.className = 'analysis-decision-badge ' + decision.toLowerCase();
            
            heroId.textContent = data.breaker_id || 'NQ_1m_bull';
            
            // Extract time from confirmation_time
            if (data.confirmation_time) {
                const time = data.confirmation_time.split('T')[1] || '';
                heroMeta.textContent = time + ' ET';
            }
            
            const score = data.decision_score || 18;
            scoreBig.textContent = score + '/21';
            
            // Build tabs
            let tabsHtml = '';
            let contentHtml = '';
            let isFirst = true;
            
            console.log('📊 Dimensions data:', dims);
            
            Object.entries(ANALYSIS_DIMENSIONS).forEach(([category, dimensions]) => {
                const categoryData = dims[category] || {};
                const categoryMissing = !dims[category];
                
                console.log(`📊 Category ${category}:`, categoryMissing ? 'MISSING' : categoryData);
                console.log(`📊 Expected keys:`, dimensions.map(d => d.key));
                console.log(`📊 Available keys:`, Object.keys(categoryData));
                
                // Count pass/warn/fail for tab indicator
                let passCount = 0, warnCount = 0, failCount = 0, missingCount = 0;
                dimensions.forEach(dim => {
                    const dimData = categoryData[dim.key];
                    if (dimData) {
                        const val = (dimData.value || dimData.status || '').toUpperCase();
                        const cls = getValueClass(val);
                        if (cls === 'pass') passCount++;
                        else if (cls === 'warn') warnCount++;
                        else if (cls === 'fail') failCount++;
                    } else {
                        missingCount++;
                    }
                });
                
                const countClass = missingCount > 0 ? 'has-error' : failCount > 0 ? 'has-fail' : warnCount > 0 ? 'has-warn' : 'all-pass';
                const countText = missingCount > 0 ? `${passCount}/${dimensions.length} (${missingCount} missing)` : `${passCount}/${dimensions.length}`;
                
                // Tab
                tabsHtml += `
                    <div class="analysis-tab ${isFirst ? 'active' : ''}" onclick="switchTab('${category}')">
                        ${CATEGORY_LABELS[category]}
                        <span class="analysis-tab-count ${countClass}">${countText}</span>
                    </div>
                `;
                
                // Content panel
                const categoryMissingMsg = categoryMissing ? 
                    `<div style="background:rgba(248,113,113,0.15);border:1px solid rgba(248,113,113,0.4);padding:12px;border-radius:8px;margin-bottom:16px;color:#f87171;">
                        <strong>⚠️ Category "${category}" not found in confirmation data</strong><br>
                        <span style="font-size:12px;color:#888;">Available categories: ${Object.keys(dims).join(', ') || 'none'}</span>
                    </div>` : '';
                
                contentHtml += `
                    <div class="analysis-panel ${isFirst ? 'active' : ''}" id="panel-${category}">
                        ${categoryMissingMsg}
                        <div class="analysis-cards">
                            ${dimensions.map(dim => {
                                const dimData = categoryData[dim.key];
                                let value = '—';
                                let valueClass = '';
                                let errorMsg = '';
                                
                                if (dimData) {
                                    value = dimData.value || dimData.status || '—';
                                    valueClass = getValueClass(value);
                                } else {
                                    value = 'KEY NOT FOUND';
                                    valueClass = 'error';
                                    errorMsg = `<div style="color:#f87171;font-size:11px;margin-top:8px;">Expected key: <code style="background:#2a2a2a;padding:2px 6px;border-radius:3px;">${dim.key}</code><br>In category: <code style="background:#2a2a2a;padding:2px 6px;border-radius:3px;">${category}</code><br>Available: ${Object.keys(categoryData).join(', ') || 'none'}</div>`;
                                }
                                
                                return `
                                    <div class="analysis-card ${dimData ? '' : 'error-card'}">
                                        <div class="analysis-card-header">
                                            <div class="analysis-card-title">
                                                <span class="analysis-card-code">${dim.code}</span>
                                                <span class="analysis-card-name">${dim.name}</span>
                                            </div>
                                            <span class="analysis-card-value ${valueClass}">${value}</span>
                                        </div>
                                        <div class="analysis-card-visual">
                                            ${dimData ? renderDimensionVisual(dim.key, dimData) : errorMsg}
                                        </div>
                                        <div class="analysis-card-calc">
                                            <div class="analysis-calc-title">How it's calculated</div>
                                            <div class="analysis-calc-text">${dimData?.reason || 'No calculation data'}</div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
                
                isFirst = false;
            });
            
            tabsContainer.innerHTML = tabsHtml;
            contentContainer.innerHTML = contentHtml;
        }
        
        // Helper function to render price ladder for support/resistance zones
        function renderPriceLadder(data, zoneType) {
            const zones = data.breakers || data.fvgs || [];
            const isSupport = zoneType.includes('support');
            const isBreaker = zoneType.includes('breaker');
            
            if (zones.length === 0) {
                const statusText = isSupport ? 
                    (isBreaker ? 'No support breakers below' : 'No support FVGs below') :
                    (isBreaker ? 'No blocking breakers' : 'No blocking FVGs');
                const statusClass = isSupport ? 'warn' : 'pass';
                
                return `
                    <div style="text-align: center; padding: 20px; color: ${isSupport ? '#fbbf24' : '#4ade80'};">
                        <div style="font-size: 24px; margin-bottom: 8px;">${isSupport ? '—' : '✓'}</div>
                        <div style="font-size: 12px;">${statusText}</div>
                    </div>
                    <div class="analysis-metric-row">
                        <div class="analysis-metric">
                            <div class="analysis-metric-label">Total</div>
                            <div class="analysis-metric-value">${isSupport ? data.total_layers || 0 : data.total_in_path || 0}</div>
                        </div>
                        <div class="analysis-metric">
                            <div class="analysis-metric-label">${isSupport ? 'Highest TF' : 'Blocking TF'}</div>
                            <div class="analysis-metric-value">${(isSupport ? data.highest_tf : data.highest_blocking_tf)?.toUpperCase() || 'None'}</div>
                        </div>
                        <div class="analysis-metric">
                            <div class="analysis-metric-label">Strength</div>
                            <div class="analysis-metric-value ${getStrengthClass(data.strength || data.value)}">${data.strength || data.value || '—'}</div>
                        </div>
                    </div>
                `;
            }
            
            // Build zone list
            let zonesHtml = zones.map((z, i) => {
                const tfClass = 'tf-' + (z.tf || '').toLowerCase();
                const extraInfo = isBreaker ? 
                    `${z.age_bars || 0} bars · ${((z.energy || 0) * 100).toFixed(0)}% energy` :
                    `${(z.fill_pct || 0).toFixed(0)}% filled`;
                    
                return `
                    <div class="price-ladder-zone ${zoneType} ${tfClass}" style="position: relative; margin-bottom: 6px;">
                        <span class="zone-tf">${(z.tf || '').toUpperCase()}</span>
                        <span>${z.high?.toLocaleString()} - ${z.low?.toLocaleString()}</span>
                        <span class="zone-info">${extraInfo}</span>
                    </div>
                `;
            }).join('');
            
            return `
                <div style="max-height: 150px; overflow-y: auto; margin-bottom: 12px;">
                    ${zonesHtml}
                </div>
                <div class="analysis-metric-row">
                    <div class="analysis-metric">
                        <div class="analysis-metric-label">Total</div>
                        <div class="analysis-metric-value">${isSupport ? data.total_layers || 0 : data.total_in_path || 0}</div>
                    </div>
                    <div class="analysis-metric">
                        <div class="analysis-metric-label">${isSupport ? 'Highest TF' : 'Blocking TF'}</div>
                        <div class="analysis-metric-value ${(isSupport ? data.highest_tf : data.highest_blocking_tf) ? (isSupport ? 'pass' : 'fail') : ''}">${(isSupport ? data.highest_tf : data.highest_blocking_tf)?.toUpperCase() || 'None'}</div>
                    </div>
                    <div class="analysis-metric">
                        <div class="analysis-metric-label">Strength</div>
                        <div class="analysis-metric-value ${getStrengthClass(data.strength || data.value)}">${data.strength || data.value || '—'}</div>
                    </div>
                </div>
            `;
        }
        
        function renderDimensionVisual(key, data) {
            switch(key) {
                // Direction - Flow chart with arrows
                case 'd1_nq_alignment':
                    const nqAligned = data.bias_4h === 'BULLISH' && data.bias_1h === 'BULLISH' && data.bias_15m === 'BULLISH';
                    const nqArrow = nqAligned ? 'aligned' : 'mixed';
                    return `
                        <div class="direction-flow">
                            <div class="direction-flow-row">
                                <div class="direction-flow-symbol">NQ</div>
                                <div class="direction-flow-tfs">
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">4H</div>
                                        <div class="direction-flow-tf-box ${(data.bias_4h || '').toLowerCase()}">${data.bias_4h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${nqArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">1H</div>
                                        <div class="direction-flow-tf-box ${(data.bias_1h || '').toLowerCase()}">${data.bias_1h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${nqArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">15M</div>
                                        <div class="direction-flow-tf-box ${(data.bias_15m || '').toLowerCase()}">${data.bias_15m === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                </div>
                                <div class="direction-flow-result ${data.value?.toLowerCase() || ''}">${data.value || 'ALIGNED'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'd2_es_alignment':
                    const esAligned = data.es_bias_4h === 'BULLISH' && data.es_bias_1h === 'BULLISH' && data.es_bias_15m === 'BULLISH';
                    const esArrow = esAligned ? 'aligned' : 'mixed';
                    return `
                        <div class="direction-flow">
                            <div class="direction-flow-row">
                                <div class="direction-flow-symbol">ES</div>
                                <div class="direction-flow-tfs">
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">4H</div>
                                        <div class="direction-flow-tf-box ${(data.es_bias_4h || '').toLowerCase()}">${data.es_bias_4h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${esArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">1H</div>
                                        <div class="direction-flow-tf-box ${(data.es_bias_1h || '').toLowerCase()}">${data.es_bias_1h === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                    <div class="direction-flow-arrow ${esArrow}"></div>
                                    <div class="direction-flow-tf">
                                        <div class="direction-flow-tf-label">15M</div>
                                        <div class="direction-flow-tf-box ${(data.es_bias_15m || '').toLowerCase()}">${data.es_bias_15m === 'BULLISH' ? '▲' : '▼'}</div>
                                    </div>
                                </div>
                                <div class="direction-flow-result ${data.converges_with_nq ? 'aligned' : 'diverged'}">${data.value || 'CONVERGED'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'd3_bearish_inversion':
                    const fb = data.failed_breakers || {};
                    return `
                        <div class="inversion-grid">
                            <div class="inversion-cell ${fb.nq_1m_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">NQ 1M Bear</div>
                                <div class="inversion-cell-icon">${fb.nq_1m_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.nq_1m_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                            <div class="inversion-cell ${fb.nq_5m_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">NQ 5M Bear</div>
                                <div class="inversion-cell-icon">${fb.nq_5m_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.nq_5m_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                            <div class="inversion-cell ${fb.nq_15m_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">NQ 15M Bear</div>
                                <div class="inversion-cell-icon">${fb.nq_15m_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.nq_15m_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                            <div class="inversion-cell ${fb.es_bear ? 'failed' : 'active'}">
                                <div class="inversion-cell-label">ES Bear</div>
                                <div class="inversion-cell-icon">${fb.es_bear ? '✓' : '—'}</div>
                                <div class="inversion-cell-status">${fb.es_bear ? 'FAILED' : 'Active'}</div>
                            </div>
                        </div>
                        <div class="analysis-metric-row" style="margin-top: 10px;">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Bears Failed</div>
                                <div class="analysis-metric-value ${data.total_failures > 0 ? 'pass' : ''}">${data.total_failures || 0}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Highest TF</div>
                                <div class="analysis-metric-value">${data.highest_tf_failed?.toUpperCase() || 'None'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.value)}">${data.value || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                // Support - Premium/Discount gauge
                case 's1_premium_discount':
                    const composite = data.weighted_composite || 50;
                    const ranges = data.ranges || {};
                    const pdZone = composite < 35 ? 'DISCOUNT' : composite > 65 ? 'PREMIUM' : 'EQUILIBRIUM';
                    
                    return `
                        <div class="pd-gauge">
                            <div class="pd-gauge-bar">
                                <div class="pd-gauge-marker" style="left: ${composite}%;"></div>
                            </div>
                            <div class="pd-gauge-labels">
                                <span>Discount (0%)</span>
                                <span>Equilibrium</span>
                                <span>Premium (100%)</span>
                            </div>
                        </div>
                        <div class="analysis-metric-row" style="margin-top: 16px;">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Weekly</div>
                                <div class="analysis-metric-value">${ranges.weekly?.position_pct?.toFixed(0) || '—'}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Daily</div>
                                <div class="analysis-metric-value">${ranges.daily?.position_pct?.toFixed(0) || '—'}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Session</div>
                                <div class="analysis-metric-value">${ranges.session?.position_pct?.toFixed(0) || '—'}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Composite</div>
                                <div class="analysis-metric-value ${composite < 40 ? 'pass' : composite > 65 ? 'fail' : 'warn'}">${composite.toFixed(0)}%</div>
                            </div>
                        </div>
                    `;
                    
                // Support - Price ladder with actual zones
                case 's2_stacked_breakers':
                    return renderPriceLadder(data, 'support-breaker');
                    
                case 's3_stacked_fvgs':
                    return renderPriceLadder(data, 'support-fvg');
                    
                case 'r1_blocking_breakers':
                    return renderPriceLadder(data, 'resist-breaker');
                    
                case 'r2_blocking_fvgs':
                    return renderPriceLadder(data, 'resist-fvg');
                    
                // Energy dimensions
                case 'e1_formation_fvg':
                    const fvgPct = data.fvg_details?.size_pct || 0;
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Has FVG</div>
                                <div class="analysis-metric-value ${data.has_fvg ? 'pass' : 'fail'}">${data.has_fvg ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">FVG Size</div>
                                <div class="analysis-metric-value">${fvgPct.toFixed(0)}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.strength)}">${data.strength || '—'}</div>
                            </div>
                        </div>
                        <div class="analysis-progress">
                            <div class="analysis-progress-fill ${fvgPct > 30 ? 'good' : fvgPct > 15 ? 'warn' : 'bad'}" style="width: ${Math.min(fvgPct, 100)}%;"></div>
                        </div>
                    `;
                    
                case 'e2_formation_sweep':
                    const sweepPct = data.sweep_depth_pct || 0;
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Has Sweep</div>
                                <div class="analysis-metric-value ${data.has_sweep ? 'pass' : ''}">${data.has_sweep ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Sweep Depth</div>
                                <div class="analysis-metric-value">${sweepPct.toFixed(0)}%</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.strength)}">${data.strength || '—'}</div>
                            </div>
                        </div>
                        <div class="analysis-progress">
                            <div class="analysis-progress-fill ${sweepPct > 40 ? 'good' : sweepPct > 20 ? 'warn' : 'bad'}" style="width: ${Math.min(sweepPct, 100)}%;"></div>
                        </div>
                    `;
                    
                case 'e3_formation_smt':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Divergence</div>
                                <div class="analysis-metric-value ${data.has_divergence ? 'pass' : ''}">${data.has_divergence ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Type</div>
                                <div class="analysis-metric-value">${data.divergence_type || 'None'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Strength</div>
                                <div class="analysis-metric-value ${getStrengthClass(data.strength)}">${data.strength || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'e4_bullish_attraction':
                    const bullPhase = (data.sd_phase || 'FRESH').toLowerCase();
                    const bullLevel = Math.min(100, (4 - (data.zone_sd || 0)) / 4 * 100);
                    return `
                        <div class="attraction-visual">
                            <div class="attraction-visual-header">
                                <div class="attraction-visual-tf bullish">${data.zone_timeframe?.toUpperCase() || '—'} Support Zone</div>
                                <div class="attraction-visual-phase ${bullPhase}">${data.sd_phase || '—'}</div>
                            </div>
                            <div class="attraction-visual-sd">
                                <div class="attraction-visual-sd-value" style="color: #4ade80;">${data.zone_sd?.toFixed(1) || '—'}</div>
                                <div class="attraction-visual-sd-label">SD from Mean</div>
                            </div>
                            <div class="attraction-visual-bar">
                                <div class="attraction-visual-bar-fill bullish" style="width: ${bullLevel}%;"></div>
                            </div>
                            <div class="analysis-metric-row" style="margin-top: 10px;">
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone High</div>
                                    <div class="analysis-metric-value">${data.zone_high?.toLocaleString() || '—'}</div>
                                </div>
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone Low</div>
                                    <div class="analysis-metric-value">${data.zone_low?.toLocaleString() || '—'}</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                case 'e5_bearish_attraction':
                    const bearPhase = (data.sd_phase || 'EXHAUSTED').toLowerCase();
                    const bearLevel = Math.min(100, (data.zone_sd || 0) / 4 * 100);
                    return `
                        <div class="attraction-visual">
                            <div class="attraction-visual-header">
                                <div class="attraction-visual-tf bearish">${data.zone_timeframe?.toUpperCase() || '—'} Resistance Zone</div>
                                <div class="attraction-visual-phase ${bearPhase}">${data.sd_phase || '—'}</div>
                            </div>
                            <div class="attraction-visual-sd">
                                <div class="attraction-visual-sd-value" style="color: #f87171;">${data.zone_sd?.toFixed(1) || '—'}</div>
                                <div class="attraction-visual-sd-label">SD from Mean</div>
                            </div>
                            <div class="attraction-visual-bar">
                                <div class="attraction-visual-bar-fill bearish" style="width: ${bearLevel}%;"></div>
                            </div>
                            <div class="analysis-metric-row" style="margin-top: 10px;">
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone High</div>
                                    <div class="analysis-metric-value">${data.zone_high?.toLocaleString() || '—'}</div>
                                </div>
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Zone Low</div>
                                    <div class="analysis-metric-value">${data.zone_low?.toLocaleString() || '—'}</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                case 'e6_daily_burn':
                    const nqBurn = data.nq?.burn_pct || 0;
                    const esBurn = data.es?.burn_pct || 0;
                    const nqClass = nqBurn < 70 ? 'available' : nqBurn < 100 ? 'limited' : 'exhausted';
                    const esClass = esBurn < 70 ? 'available' : esBurn < 100 ? 'limited' : 'exhausted';
                    const circumf = 188; // 2 * PI * 30
                    const nqOff = circumf - (circumf * Math.min(nqBurn, 100) / 100);
                    const esOff = circumf - (circumf * Math.min(esBurn, 100) / 100);
                    
                    return `
                        <div class="burn-gauges">
                            <div class="burn-gauge">
                                <div class="burn-gauge-label">NQ</div>
                                <div class="burn-gauge-ring">
                                    <svg width="80" height="80" viewBox="0 0 80 80">
                                        <circle class="burn-gauge-bg" cx="40" cy="40" r="30"/>
                                        <circle class="burn-gauge-fill ${nqClass}" cx="40" cy="40" r="30" 
                                                stroke-dasharray="${circumf}" stroke-dashoffset="${nqOff}"/>
                                    </svg>
                                    <div class="burn-gauge-value ${nqClass}">${nqBurn.toFixed(0)}%</div>
                                </div>
                                <div class="burn-gauge-status ${nqClass}">${nqBurn < 70 ? 'Available' : nqBurn < 100 ? 'Limited' : 'Exhausted'}</div>
                            </div>
                            <div class="burn-gauge">
                                <div class="burn-gauge-label">ES</div>
                                <div class="burn-gauge-ring">
                                    <svg width="80" height="80" viewBox="0 0 80 80">
                                        <circle class="burn-gauge-bg" cx="40" cy="40" r="30"/>
                                        <circle class="burn-gauge-fill ${esClass}" cx="40" cy="40" r="30" 
                                                stroke-dasharray="${circumf}" stroke-dashoffset="${esOff}"/>
                                    </svg>
                                    <div class="burn-gauge-value ${esClass}">${esBurn.toFixed(0)}%</div>
                                </div>
                                <div class="burn-gauge-status ${esClass}">${esBurn < 70 ? 'Available' : esBurn < 100 ? 'Limited' : 'Exhausted'}</div>
                            </div>
                        </div>
                        <div class="analysis-metric-row" style="margin-top: 12px;">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">NQ Range</div>
                                <div class="analysis-metric-value">${data.nq?.daily_range?.toFixed(0) || '—'} pts</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">NQ ADR</div>
                                <div class="analysis-metric-value">${data.nq?.adr_20?.toFixed(0) || '—'} pts</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Limiting</div>
                                <div class="analysis-metric-value">${data.limiting_symbol || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                // Gate dimensions
                case 'g1_trading_hours':
                    return `
                        <div class="session-visual">
                            <div class="session-visual-time">${data.current_time || '—'}</div>
                            <div class="session-visual-badge ${data.is_tradeable ? 'active' : 'inactive'}">${data.session?.replace('_', ' ') || 'OFF HOURS'}</div>
                            ${data.in_no_trade_window ? `<div class="session-visual-badge inactive">${data.no_trade_window_name || 'No Trade'}</div>` : ''}
                        </div>
                    `;
                    
                case 'g2_news_blackout':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Clear</div>
                                <div class="analysis-metric-value ${data.is_clear ? 'pass' : 'fail'}">${data.is_clear ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Next Event</div>
                                <div class="analysis-metric-value">${data.next_event || 'None'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Minutes Until</div>
                                <div class="analysis-metric-value">${data.minutes_until || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'g3_price_volatility':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">NQ ATR Ratio</div>
                                <div class="analysis-metric-value ${getVolatilityClass(data.nq?.status)}">${data.nq?.atr_ratio?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">ES ATR Ratio</div>
                                <div class="analysis-metric-value ${getVolatilityClass(data.es?.status)}">${data.es?.atr_ratio?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Combined</div>
                                <div class="analysis-metric-value ${getVolatilityClass(data.combined_status)}">${data.combined_status || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                case 'g4_market_volatility':
                    const vixStatus = data.vix_status || 'STABLE';
                    const vixClass = vixStatus === 'STABLE' ? 'stable' : vixStatus === 'ELEVATED' ? 'elevated' : 'high';
                    // Map VIX ratio to position (0.7 = 0%, 1.3 = 100%)
                    const vixPos = Math.min(100, Math.max(0, ((data.vix_ratio || 1) - 0.7) / 0.6 * 100));
                    
                    return `
                        <div class="vix-gauge">
                            <div class="vix-gauge-header">
                                <div class="vix-gauge-value ${vixClass}">${data.current_vix?.toFixed(1) || '—'}</div>
                                <div class="vix-gauge-ratio ${vixClass}">${data.vix_ratio?.toFixed(2) || '—'}x SMA</div>
                            </div>
                            <div class="vix-gauge-bar">
                                <div class="vix-gauge-marker" style="left: ${vixPos}%;"></div>
                            </div>
                            <div class="analysis-metric-row" style="margin-top: 12px;">
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">VIX SMA</div>
                                    <div class="analysis-metric-value">${data.vix_sma?.toFixed(1) || '—'}</div>
                                </div>
                                <div class="analysis-metric">
                                    <div class="analysis-metric-label">Status</div>
                                    <div class="analysis-metric-value ${vixClass}">${vixStatus}</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                case 'g5_risk_reward':
                    const entry = data.entry_price || 0;
                    const stop = data.stop_price || 0;
                    const target = data.target_price || 0;
                    const risk = data.risk_points || 1;
                    const reward = data.reward_points || 1;
                    const total = risk + reward;
                    const riskPct = (risk / total) * 100;
                    const rewardPct = (reward / total) * 100;
                    
                    return `
                        <div class="rr-visual">
                            <div class="rr-visual-prices">
                                <div class="rr-visual-price stop">
                                    <div class="rr-visual-price-label">Stop</div>
                                    <div class="rr-visual-price-value">${stop.toLocaleString()}</div>
                                </div>
                                <div class="rr-visual-price entry">
                                    <div class="rr-visual-price-label">Entry</div>
                                    <div class="rr-visual-price-value">${entry.toLocaleString()}</div>
                                </div>
                                <div class="rr-visual-price target">
                                    <div class="rr-visual-price-label">Target</div>
                                    <div class="rr-visual-price-value">${target.toLocaleString()}</div>
                                </div>
                            </div>
                            <div class="rr-visual-bar">
                                <div class="rr-visual-bar-risk" style="width: ${riskPct}%;">${risk.toFixed(0)} pts</div>
                                <div class="rr-visual-bar-entry" style="left: ${riskPct}%;"></div>
                                <div class="rr-visual-bar-reward" style="width: ${rewardPct}%;">${reward.toFixed(0)} pts</div>
                            </div>
                            <div class="rr-visual-ratio ${data.rr_ratio >= 2 ? 'pass' : 'fail'}">${data.rr_ratio?.toFixed(2) || '—'}:1 R:R</div>
                        </div>
                    `;
                    
                case 'g6_consecutive_losses':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">1M Losses</div>
                                <div class="analysis-metric-value ${data.losses_1m < 3 ? 'pass' : 'fail'}">${data.losses_1m || 0}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">5M Losses</div>
                                <div class="analysis-metric-value ${data.losses_5m < 3 ? 'pass' : 'fail'}">${data.losses_5m || 0}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Max Allowed</div>
                                <div class="analysis-metric-value">${data.max_allowed || 3}</div>
                            </div>
                        </div>
                    `;
                    
                case 'g7_spy_trend':
                    return `
                        <div class="analysis-metric-row">
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">SPY Price</div>
                                <div class="analysis-metric-value">${data.spy_price?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">SPY SMA</div>
                                <div class="analysis-metric-value">${data.spy_sma?.toFixed(2) || '—'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Above SMA</div>
                                <div class="analysis-metric-value ${data.is_above_sma ? 'pass' : 'fail'}">${data.is_above_sma ? 'YES' : 'NO'}</div>
                            </div>
                            <div class="analysis-metric">
                                <div class="analysis-metric-label">Trend</div>
                                <div class="analysis-metric-value ${data.trend_status === 'BULLISH' ? 'pass' : 'fail'}">${data.trend_status || '—'}</div>
                            </div>
                        </div>
                    `;
                    
                default:
                    return `<div class="analysis-calc-text">Visual not available for this dimension</div>`;
            }
        }
        
        function getValueClass(value) {
            const v = (value || '').toString().toUpperCase();
            // Positive values
            if (['PASS', 'ALIGNED', 'CONVERGED', 'STRONG', 'HIGH', 'DISCOUNT', 'CLEAR', 'AVAILABLE'].includes(v)) {
                return 'pass';
            }
            // Neutral/moderate values
            if (['PARTIAL', 'MODERATE', 'FRICTION', 'EQUILIBRIUM', 'LIMITED'].includes(v)) {
                return 'warn';
            }
            // Negative values
            if (['FAIL', 'OPPOSED', 'DIVERGED', 'WEAK', 'NONE', 'LOW', 'PREMIUM', 'BLOCKED', 'EXHAUSTED'].includes(v)) {
                return 'fail';
            }
            return '';
        }
        
        function switchTab(category) {
            // Update tabs
            document.querySelectorAll('.analysis-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent.includes(CATEGORY_LABELS[category])) {
                    tab.classList.add('active');
                }
            });
            
            // Update panels
            document.querySelectorAll('.analysis-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById('panel-' + category).classList.add('active');
        }
        
        function getBiasClass(bias) {
            if (bias === 'BULLISH') return 'pass';
            if (bias === 'BEARISH') return 'fail';
            return 'warn';
        }
        
        function getStrengthClass(strength) {
            const s = (strength || '').toUpperCase();
            if (['STRONG', 'HIGH'].includes(s)) return 'pass';
            if (['MODERATE'].includes(s)) return 'warn';
            if (['WEAK', 'LOW', 'NONE'].includes(s)) return 'fail';
            return '';
        }
        
        function getVolatilityClass(status) {
            if (status === 'NORMAL') return 'pass';
            if (status === 'HOT' || status === 'DEAD') return 'fail';
            return 'warn';
        }
        
        function getSDPhaseClass(phase) {
            if (phase === 'FRESH') return 'pass';
            if (phase === 'TESTED') return 'warn';
            if (phase === 'EXHAUSTED') return 'fail';
            return '';
        }
        
        // ===== INIT =====
        window.onload = function() {
            // Start in Live mode (buttons already set in HTML)
            isLive = true;
            loadSmtData().then(() => {
                loadData();
            });
            setRefreshInterval();
            
            // Update viewport indicator on resize
            window.addEventListener('resize', updateViewportIndicator);
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (lockedConfluenceMin !== null) {
                        lockedConfluenceMin = null;
                        clearEntryHighlight();
                        if (isLive) {
                            showLiveConfluence();
                        } else {
                            showEmptyPanel();
                        }
                    } else if (selectedEntryMin !== null) {
                        selectEntry(selectedEntryMin);
                    } else if (selectedBreakerId !== null) {
                        selectBreaker(selectedBreakerId);
                    } else if (selectedSmtId !== null) {
                        selectSmt(selectedSmtId);
                    }
                }
            });
        };
    </script>
</body>
</html>
