<!DOCTYPE html>
<html>
<head>
    <title>SigXFlow</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0f0f10;
            color: #e0e0e0;
            font-size: 13px;
        }
        
        /* ===== HEADER ===== */
        .header {
            background: #1a1a1c;
            border-bottom: 1px solid #2a2a2e;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .logo {
            font-size: 16px;
            font-weight: 600;
            color: #60a5fa;
        }
        
        /* Stats */
        .stats-row {
            display: flex;
            gap: 8px;
        }
        
        .stat {
            padding: 8px 16px;
            background: #1f1f22;
            border: 1px solid #2a2a2e;
            border-radius: 6px;
            text-align: center;
            min-width: 70px;
        }
        
        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 600;
        }
        
        .stat-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .stat.active .stat-value { color: #60a5fa; }
        .stat.success .stat-value { color: #22c55e; }
        .stat.fail .stat-value { color: #ef4444; }
        .stat.win .stat-value { color: #fbbf24; }
        
        /* Navigation */
        .nav-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .btn {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 500;
            padding: 8px 14px;
            border-radius: 6px;
            border: 1px solid #3a3a3e;
            background: #252528;
            color: #bbb;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .btn:hover {
            background: #303035;
            border-color: #4a4a4e;
        }
        
        .btn.primary {
            background: #2563eb;
            border-color: #2563eb;
            color: #fff;
        }
        
        .btn.primary:hover {
            background: #1d4ed8;
        }
        
        .btn.live {
            background: #dc2626;
            border-color: #dc2626;
            color: #fff;
        }
        
        .btn.inactive {
            background: #1a1a1c;
            border-color: #2a2a2e;
            color: #555;
        }
        
        .btn.explore-active {
            background: rgba(251, 191, 36, 0.2);
            border-color: #fbbf24;
            color: #fbbf24;
        }
        
        .select-styled {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #3a3a3e;
            background: #252528;
            color: #bbb;
            cursor: pointer;
        }
        
        .divider {
            width: 1px;
            height: 24px;
            background: #3a3a3e;
            margin: 0 8px;
        }
        
        /* ===== TOOLBAR ===== */
        .toolbar {
            background: #1a1a1c;
            border-bottom: 1px solid #2a2a2e;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .filter-group {
            display: flex;
            gap: 4px;
            background: #252528;
            padding: 3px;
            border-radius: 6px;
        }
        
        .filter-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            padding: 5px 10px;
            border-radius: 4px;
            border: none;
            background: transparent;
            color: #666;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .filter-btn:hover {
            color: #999;
        }
        
        .filter-btn.active {
            background: #333;
            color: #ddd;
        }
        
        .filter-btn.nq.active { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .filter-btn.es.active { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        .filter-btn.bull.active { color: #22c55e; background: rgba(22, 163, 74, 0.2); }
        .filter-btn.bear.active { color: #f87171; background: rgba(220, 38, 38, 0.2); }
        
        .toolbar-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .visible-count {
            font-size: 12px;
            color: #666;
        }
        
        .status-msg {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
            padding: 2px 8px;
            border-radius: 4px;
            transition: opacity 0.3s;
        }
        
        .status-msg.success {
            color: #4ade80;
        }
        
        .status-msg.error {
            color: #f87171;
        }
        
        .refresh-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .countdown {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #666;
            min-width: 30px;
        }
        
        /* ===== TIMELINE BAR ===== */
        .timeline-bar {
            background: #1a1a1c;
            padding: 8px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #2a2a2e;
        }
        
        .time-label-bar {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #888;
            min-width: 110px;
        }
        
        .time-label-bar.end { text-align: right; }
        
        .timeline-track {
            flex-grow: 1;
            height: 8px;
            background: #252528;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
        }
        
        .timeline-viewport {
            position: absolute;
            height: 100%;
            background: #3b82f6;
            border-radius: 4px;
            cursor: grab;
            transition: background 0.15s;
        }
        
        .timeline-viewport:hover {
            background: #60a5fa;
        }
        
        .timeline-viewport:active {
            cursor: grabbing;
            background: #93c5fd;
        }
        
        /* ===== MAIN WRAPPER ===== */
        .main-wrapper {
            display: flex;
            height: calc(100vh - 170px);
            margin: 10px;
            gap: 10px;
        }
        
        /* ===== CHART AREA ===== */
        .chart-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #131315;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
            overflow: hidden;
            min-width: 0;
        }
        
        /* Fixed Header Row */
        .header-row {
            display: flex;
            flex-shrink: 0;
            background: #1a1a1c;
            border-bottom: 1px solid #2a2a2e;
        }
        
        .left-header {
            width: 100px;
            min-width: 100px;
            height: 36px;
            padding: 0 12px;
            display: flex;
            align-items: center;
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-right: 1px solid #2a2a2e;
            box-sizing: border-box;
        }
        
        .time-header-wrapper {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }
        
        .time-header {
            height: 36px;
            position: relative;
            white-space: nowrap;
        }
        
        /* Unified Scroll Container */
        .scroll-container {
            flex-grow: 1;
            overflow: auto;
        }
        
        .scroll-inner {
            display: flex;
            min-width: fit-content;
        }
        
        /* Left Panel - labels */
        .left-panel {
            width: 100px;
            min-width: 100px;
            background: #151517;
            border-right: 1px solid #2a2a2e;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 30;
        }
        
        /* TF section header */
        .tf-header {
            height: 28px;
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 700;
            margin-top: 4px;
            position: sticky;
            top: 0;
            z-index: 5;
        }
        
        .tf-header.tf-4h {
            background: linear-gradient(90deg, rgba(239, 68, 68, 0.25) 0%, #151517 100%);
            color: #f87171;
            border-left: 4px solid #f87171;
        }
        .tf-header.tf-1h {
            background: linear-gradient(90deg, rgba(251, 191, 36, 0.25) 0%, #151517 100%);
            color: #fbbf24;
            border-left: 4px solid #fbbf24;
        }
        .tf-header.tf-15m {
            background: linear-gradient(90deg, rgba(34, 197, 94, 0.25) 0%, #151517 100%);
            color: #4ade80;
            border-left: 4px solid #4ade80;
        }
        .tf-header.tf-5m {
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.25) 0%, #151517 100%);
            color: #60a5fa;
            border-left: 4px solid #60a5fa;
        }
        .tf-header.tf-1m {
            background: linear-gradient(90deg, rgba(168, 85, 247, 0.25) 0%, #151517 100%);
            color: #c084fc;
            border-left: 4px solid #c084fc;
        }
        
        .tf-header-chart {
            height: 28px;
            margin-top: 4px;
        }
        
        /* TF background tints for chart header */
        .tf-header-chart[data-tf="1m"] { background: rgba(192, 132, 252, 0.06); }
        .tf-header-chart[data-tf="5m"] { background: rgba(96, 165, 250, 0.06); }
        .tf-header-chart[data-tf="15m"] { background: rgba(74, 222, 128, 0.06); }
        .tf-header-chart[data-tf="1h"] { background: rgba(251, 191, 36, 0.06); }
        .tf-header-chart[data-tf="4h"] { background: rgba(248, 113, 113, 0.06); }
        
        /* Symbol Lane rows */
        .lane-label {
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-sizing: border-box;
        }
        
        .lane-label.has-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-label.has-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Timeframe background tints for left panel */
        .lane-label[data-tf="1m"] { border-left: 4px solid #c084fc; background: rgba(192, 132, 252, 0.06); }
        .lane-label[data-tf="5m"] { border-left: 4px solid #60a5fa; background: rgba(96, 165, 250, 0.06); }
        .lane-label[data-tf="15m"] { border-left: 4px solid #4ade80; background: rgba(74, 222, 128, 0.06); }
        .lane-label[data-tf="1h"] { border-left: 4px solid #fbbf24; background: rgba(251, 191, 36, 0.06); }
        .lane-label[data-tf="4h"] { border-left: 4px solid #f87171; background: rgba(248, 113, 113, 0.06); }
        
        .symbol-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 4px;
            min-width: 32px;
            text-align: center;
        }
        
        .symbol-badge.nq { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .symbol-badge.es { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        
        /* Right Panel - chart */
        .right-panel {
            flex-grow: 1;
            position: relative;
        }
        
        .time-tick-label {
            position: absolute;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #555;
            top: 50%;
            transform: translateY(-50%);
            white-space: nowrap;
        }
        
        .chart-inner {
            position: relative;
            overflow: visible;
        }
        
        /* Future edge fade - bright glow into future */
        .chart-inner::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            width: 35px;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.25) 60%, rgba(255, 255, 255, 0.5) 100%);
            pointer-events: none;
            z-index: 20;
        }
        
        /* Swimlane row */
        .swimlane {
            position: relative;
            box-sizing: border-box;
        }
        
        /* Timeframe background tints for swimlanes */
        .swimlane[data-tf="1m"] { background: rgba(192, 132, 252, 0.06); }
        .swimlane[data-tf="5m"] { background: rgba(96, 165, 250, 0.06); }
        .swimlane[data-tf="15m"] { background: rgba(74, 222, 128, 0.06); }
        .swimlane[data-tf="1h"] { background: rgba(251, 191, 36, 0.06); }
        .swimlane[data-tf="4h"] { background: rgba(248, 113, 113, 0.06); }
        
        /* ===== BREAKER BARS ===== */
        .breaker-bar {
            position: absolute;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: rgba(255,255,255,0.95);
            overflow: hidden;
            min-width: 6px;
        }
        
        .bar-right-group {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .breaker-bar:hover {
            z-index: 20;
            filter: brightness(1.15);
            box-shadow: 0 0 12px rgba(255,255,255,0.2);
        }
        
        .breaker-bar.selected {
            box-shadow: 0 0 0 2px #fff;
            z-index: 21;
        }
        
        /* NQ Bull = Forest Green */
        .breaker-bar.nq.bull { background: #16a34a; }
        /* NQ Bear = Crimson Red */
        .breaker-bar.nq.bear { background: #dc2626; }
        /* ES Bull = Forest Green with bottom stripe */
        .breaker-bar.es.bull { background: #16a34a; }
        /* ES Bear = Crimson Red with bottom stripe */
        .breaker-bar.es.bear { background: #dc2626; }
        
        /* ES indicator - white bottom stripe */
        .breaker-bar.es::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 0 0 4px 4px;
        }
        
        /* Completed = slightly faded */
        .breaker-bar.completed {
            opacity: 0.75;
        }
        
        .breaker-bar.completed:hover {
            opacity: 1;
        }
        
        /* Fib label */
        .bar-fib {
            flex-shrink: 0;
        }
        
        /* Status dot */
        .status-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            flex-shrink: 0;
            border: 2px solid rgba(255,255,255,0.95);
            color: #fff;
        }
        
        .status-dot.success {
            background: #16a34a;
        }
        
        .status-dot.fail {
            background: #dc2626;
        }
        
        /* Active at entry highlight (for selection - yellow crisp) */
        .breaker-bar.active-at-entry {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 25;
            opacity: 1 !important;
        }
        
        /* Cursor hover highlight (yellow - crisp) */
        .breaker-bar.cursor-active {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 8px rgba(251, 191, 36, 0.5) !important;
            z-index: 24;
            opacity: 1 !important;
        }
        
        .lane-label.cursor-confluence {
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.12) !important;
        }
        
        .lane-label.cursor-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }
        
        /* Live mode highlight (blue - crisp) */
        .breaker-bar.live-active {
            box-shadow: 0 0 0 2px #60a5fa, 0 0 8px rgba(96, 165, 250, 0.5) !important;
            z-index: 23;
            opacity: 1 !important;
        }
        
        .lane-label.live-confluence {
            box-shadow: inset 0 0 15px rgba(96, 165, 250, 0.4);
            background: rgba(96, 165, 250, 0.12) !important;
        }
        
        .lane-label.live-confluence .symbol-badge {
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.6);
        }
        
        /* Entry lines */
        .entry-line {
            position: absolute;
            top: 0;
            width: 2px;
            background: rgba(251, 191, 36, 0.5);
            z-index: 15;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .entry-line:hover {
            background: #fbbf24;
            width: 3px;
        }
        
        .entry-line.selected {
            background: #fbbf24;
            width: 3px;
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.6);
        }
        
        .entry-line::before {
            content: '‚ñº';
            position: absolute;
            top: -14px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #fbbf24;
        }
        
        /* Cursor line */
        .cursor-line {
            position: absolute;
            top: 0;
            width: 1px;
            border-left: 1px dashed rgba(255, 255, 255, 0.5);
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        .cursor-line.visible {
            opacity: 1;
        }
        
        .cursor-time {
            position: fixed;
            display: none;
            background: #fbbf24;
            color: #000;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
        }
        
        /* ===== DETAIL PANEL ===== */
        .detail-panel {
            width: 320px;
            min-width: 320px;
            background: #1a1a1c;
            border-radius: 8px;
            border: 1px solid #2a2a2e;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-header {
            padding: 12px 16px;
            background: #1f1f22;
            border-bottom: 1px solid #2a2a2e;
            font-weight: 600;
            font-size: 13px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .panel-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #555;
            text-align: center;
            padding: 20px;
        }
        
        .panel-empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        
        .panel-empty-text {
            font-size: 13px;
            line-height: 1.5;
        }
        
        /* Breaker Detail View */
        .detail-section {
            margin-bottom: 20px;
        }
        
        .detail-section:last-child {
            margin-bottom: 0;
        }
        
        .detail-section-title {
            font-size: 10px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #2a2a2e;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .live-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #60a5fa;
            animation: pulse-live 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-live {
            0%, 100% { opacity: 1; box-shadow: 0 0 6px #60a5fa; }
            50% { opacity: 0.6; box-shadow: 0 0 3px #60a5fa; }
        }
        
        .detail-id {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
        }
        
        .detail-badges {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .detail-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 4px;
        }
        
        .detail-badge.nq { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .detail-badge.es { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        .detail-badge.bull { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .detail-badge.bear { background: rgba(249, 115, 22, 0.2); color: #fb923c; }
        .detail-badge.active { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .detail-badge.success { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
        .detail-badge.fail { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #222;
        }
        
        .detail-row:last-child {
            border-bottom: none;
        }
        
        .detail-label {
            color: #888;
            font-size: 12px;
        }
        
        .detail-value {
            font-family: 'JetBrains Mono', monospace;
            color: #ddd;
            font-size: 12px;
            font-weight: 500;
        }
        
        .detail-value.large {
            font-size: 18px;
            color: #fff;
        }
        
        /* Entry Context View */
        .context-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: 16px;
        }
        
        .context-grid {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .context-row {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            background: #151517;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .context-row.active {
            background: rgba(251, 191, 36, 0.12);
            box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4);
        }
        
        .context-row.live-active-row {
            background: rgba(96, 165, 250, 0.12);
            box-shadow: inset 0 0 15px rgba(96, 165, 250, 0.4);
        }
        
        .context-tf {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 700;
            width: 36px;
            color: #888;
        }
        
        .context-symbol {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            width: 28px;
            padding: 2px 4px;
            border-radius: 3px;
            text-align: center;
            margin-right: 10px;
        }
        
        .context-symbol.nq { background: rgba(37, 99, 235, 0.3); color: #60a5fa; }
        .context-symbol.es { background: rgba(6, 182, 212, 0.3); color: #22d3ee; }
        
        .context-dir {
            font-size: 11px;
            font-weight: 600;
            width: 50px;
        }
        
        .context-dir.bull { color: #60a5fa; }
        .context-dir.bear { color: #fb923c; }
        .context-dir.none { color: #555; }
        
        .context-header {
            display: flex;
            align-items: center;
            padding: 4px 10px;
            font-size: 9px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #2a2a2e;
            margin-bottom: 4px;
        }
        
        .context-header span:nth-child(1) { width: 36px; }
        .context-header span:nth-child(2) { width: 38px; }
        .context-header span:nth-child(3) { width: 50px; }
        .context-header span:nth-child(4) { flex: 1; }
        .context-header span:nth-child(5) { width: 24px; text-align: center; }
        
        .context-fib {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #aaa;
            flex: 1;
        }
        
        .context-status-icon {
            font-size: 11px;
            width: 24px;
            text-align: center;
        }
        
        .context-status-icon.active { color: #60a5fa; }
        .context-status-icon.success { color: #4ade80; }
        .context-status-icon.fail { color: #f87171; }
        .context-status-icon.none { color: #444; }
        
        .context-age {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #666;
            margin-left: auto;
        }
        
        .arrow-bull { color: #4ade80; }
        .arrow-bear { color: #f87171; }
        
        .context-summary {
            margin-top: 16px;
            padding: 12px;
            background: #151517;
            border-radius: 6px;
        }
        
        .context-summary-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }
        
        .context-summary-label {
            color: #888;
            font-size: 12px;
        }
        
        .context-summary-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 12px;
        }
        
        .context-summary-value.good { color: #4ade80; }
        .context-summary-value.bad { color: #f87171; }
        .context-summary-value.neutral { color: #fbbf24; }
        
        /* Fib Chart */
        .fib-chart-container {
            margin-top: 8px;
            background: #151517;
            border-radius: 6px;
            padding: 12px;
        }
        
        .fib-chart {
            width: 100%;
            height: 120px;
        }
        
        .fib-chart-axis {
            stroke: #333;
            stroke-width: 1;
        }
        
        .fib-chart-grid {
            stroke: #222;
            stroke-width: 1;
            stroke-dasharray: 2, 4;
        }
        
        .fib-chart-line {
            fill: none;
            stroke: #60a5fa;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        .fib-chart-area {
            fill: url(#fibGradient);
            opacity: 0.3;
        }
        
        .fib-chart-dot {
            fill: #60a5fa;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .fib-chart-dot:hover {
            fill: #fff;
            r: 5;
        }
        
        .fib-chart-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            fill: #666;
        }
        
        .fib-chart-value-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            fill: #888;
        }
        
        .fib-chart-peak {
            fill: #4ade80;
            stroke: #1a1a1c;
            stroke-width: 2;
        }
        
        .fib-peak-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            fill: #4ade80;
            font-weight: 600;
        }
        
        .fib-chart-container {
            position: relative;
        }
        
        .fib-cursor-line {
            stroke: #fbbf24;
            stroke-width: 1;
            stroke-dasharray: 3, 3;
            opacity: 0;
            pointer-events: none;
        }
        
        .fib-cursor-dot {
            fill: #fbbf24;
            opacity: 0;
            pointer-events: none;
        }
        
        .fib-cursor-tooltip {
            position: absolute;
            background: #252528;
            border: 1px solid #3a3a3e;
            border-radius: 4px;
            padding: 6px 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 10;
            white-space: nowrap;
        }
        
        .fib-cursor-tooltip .fib-val {
            color: #60a5fa;
            font-weight: 600;
        }
        
        .fib-cursor-tooltip .time-val {
            color: #888;
            margin-left: 8px;
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .toast.error { background: #dc2626; }
        .toast.success { background: #16a34a; }
        
        /* Legend */
        .legend {
            display: flex;
            gap: 12px;
            align-items: center;
            font-size: 11px;
            color: #888;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-swatch {
            width: 18px;
            height: 14px;
            border-radius: 3px;
            position: relative;
        }
        
        .legend-swatch.nq-bull { background: #16a34a; }
        .legend-swatch.nq-bear { background: #dc2626; }
        .legend-swatch.es-bull { background: #16a34a; }
        .legend-swatch.es-bear { background: #dc2626; }
        
        /* ES legend swatches get bottom stripe */
        .legend-swatch.es-bull::after,
        .legend-swatch.es-bear::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 0 0 3px 3px;
        }
        
        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 700;
            border: 2px solid rgba(255,255,255,0.8);
            color: #fff;
        }
        
        .legend-dot.win { 
            background: #16a34a;
        }
        .legend-dot.loss { 
            background: #dc2626;
        }
        
        .legend-swatch.entry { 
            background: #fbbf24; 
            width: 3px; 
            height: 16px;
        }
        
        .legend-divider {
            width: 1px;
            height: 16px;
            background: #3a3a3e;
            margin: 0 4px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1c;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #3a3a3e;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a4e;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-left">
            <div class="logo">üìä SigXFlow</div>
        </div>
        
        <div class="stats-row">
            <div class="stat active">
                <div class="stat-value" id="stat-active">-</div>
                <div class="stat-label">Active</div>
            </div>
            <div class="stat success">
                <div class="stat-value" id="stat-success">-</div>
                <div class="stat-label">Win</div>
            </div>
            <div class="stat fail">
                <div class="stat-value" id="stat-fail">-</div>
                <div class="stat-label">Loss</div>
            </div>
            <div class="stat win">
                <div class="stat-value" id="stat-winrate">-</div>
                <div class="stat-label">Win%</div>
            </div>
        </div>
        
        <div class="nav-group">
            <button class="btn" id="mode-explore" onclick="setMode('explore')">üîç Explore</button>
            <button class="btn live inactive" id="mode-live" onclick="setMode('live')">üî¥ Live</button>
            <div class="divider"></div>
            <button class="btn primary" onclick="goToLatest()">Latest ‚Üí|</button>
            <div class="divider"></div>
            <select class="select-styled" id="load-limit" onchange="loadData(true)">
                <option value="8">Load 8hr</option>
                <option value="12" selected>Load 12hr</option>
                <option value="24">Load 24hr</option>
                <option value="48">Load 48hr</option>
            </select>
        </div>
    </div>
    
    <!-- Toolbar -->
    <div class="toolbar">
        <div class="filter-group">
            <button class="filter-btn nq active" id="filter-nq" onclick="toggleFilter('nq')">NQ</button>
            <button class="filter-btn es active" id="filter-es" onclick="toggleFilter('es')">ES</button>
        </div>
        
        <div class="filter-group">
            <button class="filter-btn bull active" id="filter-bull" onclick="toggleFilter('bull')">‚ñ≤ Bull</button>
            <button class="filter-btn bear active" id="filter-bear" onclick="toggleFilter('bear')">‚ñº Bear</button>
        </div>
        
        <div class="legend">
            <div class="legend-item"><div class="legend-swatch nq-bull"></div>NQ Bull</div>
            <div class="legend-item"><div class="legend-swatch nq-bear"></div>NQ Bear</div>
            <div class="legend-item"><div class="legend-swatch es-bull"></div>ES Bull</div>
            <div class="legend-item"><div class="legend-swatch es-bear"></div>ES Bear</div>
            <div class="legend-divider"></div>
            <div class="legend-item"><div class="legend-dot win">‚úì</div>Win</div>
            <div class="legend-item"><div class="legend-dot loss">‚úó</div>Loss</div>
            <div class="legend-divider"></div>
            <div class="legend-item"><div class="legend-swatch entry"></div>Entry</div>
        </div>
        
        <div class="toolbar-right">
            <span class="visible-count" id="visible-count"></span>
            <span class="status-msg" id="status-msg"></span>
            <div class="refresh-group">
                <select class="select-styled" id="refresh-interval" onchange="setRefreshInterval()">
                    <option value="0">Auto: Off</option>
                    <option value="30">Auto: 30s</option>
                    <option value="60" selected>Auto: 1m</option>
                    <option value="300">Auto: 5m</option>
                </select>
                <span class="countdown" id="countdown"></span>
                <button class="btn primary" onclick="loadData(true)">‚Üª Reload</button>
            </div>
        </div>
    </div>
    
    <!-- Timeline Bar -->
    <div class="timeline-bar">
        <span class="time-label-bar" id="data-start">--</span>
        <div class="timeline-track" id="timeline-track">
            <div class="timeline-viewport" id="viewport-indicator"></div>
        </div>
        <span class="time-label-bar end" id="data-end">--</span>
    </div>
    
    <!-- Main Wrapper -->
    <div class="main-wrapper">
        <!-- Chart Area -->
        <div class="chart-area">
            <div class="header-row">
                <div class="left-header">TF</div>
                <div class="time-header-wrapper">
                    <div class="time-header" id="time-header"></div>
                </div>
            </div>
            <div class="scroll-container" id="scroll-container">
                <div class="scroll-inner">
                    <div class="left-panel" id="left-panel"></div>
                    <div class="right-panel">
                        <div class="chart-inner" id="chart-inner"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Detail Panel -->
        <div class="detail-panel">
            <div class="panel-header">Details</div>
            <div class="panel-content" id="panel-content">
                <div class="panel-empty">
                    <div class="panel-empty-icon">üìã</div>
                    <div class="panel-empty-text">
                        Click a breaker bar or entry line to see details
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        // ===== CONFIG =====
        const FIREBASE_URL = "https://sigxflow-default-rtdb.firebaseio.com/snapshots.json";
        const PIXELS_PER_MINUTE = 30;
        const BAR_HEIGHT = 32;
        const BAR_GAP = 3;
        const LANE_PADDING = 5;
        const TF_HEADER_HEIGHT = 28;
        const MIN_LANE_HEIGHT = 42;
        const WINDOW_HOURS = 8;
        
        const TF_ORDER = ['1m', '5m', '15m', '1h', '4h'];
        const TF_DISPLAY = { '4h': '4H', '1h': '1H', '15m': '15m', '5m': '5m', '1m': '1m' };
        const SYMBOLS = ['NQ', 'ES'];
        
        // ===== STATE =====
        let allData = [];
        let breakerCache = {}; // For incremental updates
        let windowStartMin = 0;
        let windowEndMin = 0;
        let dataMinTime = 0;
        let dataMaxTime = 0;
        let isLive = false;
        let isFirstLoad = true;
        let lastFetchedTime = null; // Track last observation_time for incremental fetch
        let lastLoadLimit = null; // Track if limit changed (requires full reload)
        let refreshTimer = null;
        let countdownTimer = null;
        let countdownSecs = 0;
        let selectedEntryMin = null;
        let selectedBreakerId = null;
        let entryTimes = [];
        let chartAbortController = null; // For cleaning up event listeners
        
        const filters = {
            nq: true, es: true,
            bull: true, bear: true
        };
        
        // ===== UTILITIES =====
        function datetimeToMin(datetime) {
            const parts = datetime.replace('T', ' ').split(' ');
            const dateParts = parts[0].split('-');
            const timeParts = (parts[1] || '00:00').split(':');
            const d = new Date(
                parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]),
                parseInt(timeParts[0]), parseInt(timeParts[1])
            );
            return Math.floor(d.getTime() / 60000);
        }
        
        function minToTime(m) {
            const d = new Date(m * 60000);
            return d.getHours().toString().padStart(2, '0') + ':' + 
                   d.getMinutes().toString().padStart(2, '0');
        }
        
        function minToDateTime(m) {
            const d = new Date(m * 60000);
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            return months[d.getMonth()] + ' ' + d.getDate() + ', ' + minToTime(m);
        }
        
        function minToDuration(startMin, endMin) {
            const mins = endMin - startMin;
            if (mins < 60) return mins + 'm';
            const hrs = Math.floor(mins / 60);
            const rem = mins % 60;
            return rem > 0 ? `${hrs}h ${rem}m` : `${hrs}h`;
        }
        
        function showToast(msg, type = '') {
            const el = document.getElementById('status-msg');
            el.textContent = msg;
            el.className = 'status-msg ' + type;
            // Clear after 5 seconds for non-error messages
            if (type !== 'error') {
                setTimeout(() => el.textContent = '', 5000);
            }
        }
        
        // ===== STACKING ALGORITHM =====
        function assignStackPositions(breakers) {
            if (!breakers.length) return [];
            
            const sorted = [...breakers].sort((a, b) => a.startMin - b.startMin);
            const stackEnds = [];
            
            sorted.forEach(b => {
                let stackIdx = 0;
                while (stackIdx < stackEnds.length && stackEnds[stackIdx] > b.startMin) {
                    stackIdx++;
                }
                
                b.stackIdx = stackIdx;
                stackEnds[stackIdx] = b.endMin + 1;
            });
            
            return sorted;
        }
        
        // ===== WINDOW MANAGEMENT =====
        function setWindow(startMin, endMin, label) {
            windowStartMin = startMin;
            windowEndMin = endMin;
            
            updateViewportIndicator();
        }
        
        function updateMiniTimeline() {
            updateViewportIndicator();
        }
        
        function setMode(mode) {
            isLive = (mode === 'live');
            
            const exploreBtn = document.getElementById('mode-explore');
            const liveBtn = document.getElementById('mode-live');
            
            if (isLive) {
                liveBtn.classList.remove('inactive');
                exploreBtn.classList.remove('explore-active');
                exploreBtn.classList.add('inactive');
                // Immediately show live confluence if data exists
                if (allData.length > 0) {
                    showLiveConfluence();
                }
            } else {
                exploreBtn.classList.remove('inactive');
                exploreBtn.classList.add('explore-active');
                liveBtn.classList.add('inactive');
                // Clear live highlights and show empty panel
                clearLiveHighlight();
                showEmptyPanel();
            }
            
            loadData();
        }
        
        function goToLatest() {
            if (dataMaxTime === 0) {
                showToast('No data loaded', 'error');
                return;
            }
            
            const container = document.getElementById('scroll-container');
            container.scrollLeft = container.scrollWidth;
        }
        
        function shiftWindow(direction) {
            if (dataMinTime === 0 || dataMaxTime === 0) {
                showToast('No data loaded', 'error');
                return;
            }
            
            const shift = direction * WINDOW_HOURS * 60;
            let newStart = windowStartMin + shift;
            let newEnd = windowEndMin + shift;
            
            if (newStart < dataMinTime) {
                newStart = dataMinTime;
                newEnd = newStart + WINDOW_HOURS * 60;
            }
            if (newEnd > dataMaxTime) {
                newEnd = dataMaxTime;
                newStart = newEnd - WINDOW_HOURS * 60;
            }
            
            if (newStart === windowStartMin && newEnd === windowEndMin) {
                showToast('No more data in that direction', 'error');
                return;
            }
            
            windowStartMin = newStart;
            windowEndMin = newEnd;
            setWindow(windowStartMin, windowEndMin, 'Custom ' + WINDOW_HOURS + 'hr');
            renderChart();
            
            setTimeout(() => {
                const container = document.getElementById('scroll-container');
                if (direction > 0) {
                    container.scrollLeft = 0;
                } else {
                    container.scrollLeft = container.scrollWidth;
                }
            }, 50);
        }
        
        function advanceLiveWindow() {
            // Get current time in minutes (matching how datetimeToMin works)
            const now = new Date();
            const nowMin = Math.floor(now.getTime() / 60000);
            
            // Extend dataMaxTime to now if it's behind
            if (nowMin > dataMaxTime) {
                dataMaxTime = nowMin;
            }
            
            // In live mode, keep window at the latest edge
            const windowSize = windowEndMin - windowStartMin;
            windowEndMin = dataMaxTime;
            windowStartMin = Math.max(dataMinTime, dataMaxTime - windowSize);
            
            setWindow(windowStartMin, windowEndMin, 'Live');
            renderChart();
            
            // Scroll to right edge and show live confluence
            setTimeout(() => {
                const container = document.getElementById('scroll-container');
                container.scrollLeft = container.scrollWidth;
                showLiveConfluence();
            }, 50);
        }
        
        // ===== FILTERS =====
        function toggleFilter(key) {
            filters[key] = !filters[key];
            const btn = document.getElementById('filter-' + key);
            if (btn) btn.classList.toggle('active', filters[key]);
            renderChart();
        }
        
        // ===== DATA LOADING =====
        function getLoadHours() {
            const el = document.getElementById('load-limit');
            return el ? parseInt(el.value) : 12;
        }
        
        function loadData(forceFullLoad = false) {
            const currentHours = getLoadHours();
            const needsFullLoad = forceFullLoad || 
                                  !lastFetchedTime || 
                                  lastLoadLimit !== currentHours ||
                                  Object.keys(breakerCache).length === 0;
            
            lastLoadLimit = currentHours;
            
            if (needsFullLoad) {
                // Full load
                showToast('Loading...', '');
                
                fetch(FIREBASE_URL)
                    .then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.json();
                    })
                    .then(data => {
                        if (!data) throw new Error('No data');
                        
                        let entries = Object.entries(data)
                            .filter(([k, v]) => v && v.observation_time);
                        
                        if (entries.length === 0) throw new Error('No valid data');
                        
                        // Find the latest observation time
                        let latestTime = '';
                        entries.forEach(([k, v]) => {
                            if (v.observation_time > latestTime) {
                                latestTime = v.observation_time;
                            }
                        });
                        
                        // Calculate cutoff time (X hours before latest)
                        const latestMin = datetimeToMin(latestTime);
                        const cutoffMin = latestMin - (currentHours * 60);
                        
                        // Filter to only include snapshots within time range
                        entries = entries.filter(([k, v]) => {
                            const snapMin = datetimeToMin(v.observation_time);
                            return snapMin >= cutoffMin;
                        });
                        
                        // Sort by time
                        entries.sort((a, b) => {
                            const tsA = a[1].observation_time || '';
                            const tsB = b[1].observation_time || '';
                            return tsA.localeCompare(tsB);
                        });
                        
                        const limited = {};
                        entries.forEach(([k, v]) => limited[k] = v);
                        
                        processFirebaseData(limited, true);
                    })
                    .catch(err => {
                        showToast('Error: ' + err.message, 'error');
                        console.error(err);
                    });
            } else {
                // Incremental load - only fetch newer data from Firebase
                const url = FIREBASE_URL + 
                    '?orderBy="observation_time"&startAfter="' + lastFetchedTime + '"';
                
                console.log('Incremental fetch:', url);
                
                fetch(url)
                    .then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.json();
                    })
                    .then(data => {
                        if (!data || Object.keys(data).length === 0) {
                            // In Live mode, advance window to current time even if no data
                            if (isLive) {
                                advanceLiveWindow();
                                showToast('Live - no new data', '');
                            } else {
                                showToast('No new data', '');
                            }
                            return;
                        }
                        
                        console.log('Incremental data:', Object.keys(data).length, 'snapshots');
                        processIncrementalData(data);
                    })
                    .catch(err => {
                        // If query fails (no index), show error with instructions
                        console.error('Incremental fetch failed:', err);
                        showToast('Index needed - see console', 'error');
                    });
            }
        }
        
        function processFirebaseData(snapshots, isFullLoad = true) {
            if (isFullLoad) {
                breakerCache = {}; // Reset cache on full load
            }
            
            let snapshotList = Array.isArray(snapshots) 
                ? snapshots 
                : Object.values(snapshots).filter(s => s);
            
            if (snapshotList.length === 0) {
                showToast('No data', 'error');
                return;
            }
            
            snapshotList.sort((a, b) => {
                const tsA = a.observation_time || '';
                const tsB = b.observation_time || '';
                return tsA.localeCompare(tsB);
            });
            
            // Track the latest observation time for incremental fetches
            const latestSnap = snapshotList[snapshotList.length - 1];
            lastFetchedTime = latestSnap.observation_time;
            
            let minTime = Infinity, maxTime = 0;
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                if (ts) {
                    const min = datetimeToMin(ts);
                    if (min < minTime) minTime = min;
                    if (min > maxTime) maxTime = min;
                }
            });
            
            dataMinTime = minTime;
            dataMaxTime = maxTime;
            
            // Show all loaded data
            windowStartMin = dataMinTime;
            windowEndMin = dataMaxTime;
            
            setWindow(windowStartMin, windowEndMin, 'Latest');
            
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                const datetime = ts.replace('T', ' ');
                const absMin = datetimeToMin(ts);
                
                Object.entries(snap.breakers || {}).forEach(([id, b]) => {
                    if (!breakerCache[id]) {
                        breakerCache[id] = {
                            id,
                            tf: b.tf.toLowerCase(),
                            dir: b.dir.toLowerCase(),
                            status: 'active',
                            events: [],
                            maxFib: 0
                        };
                    }
                    
                    const fib = b.fib || 1;
                    // Avoid duplicate events (same timestamp)
                    if (!breakerCache[id].events.some(e => e.absMin === absMin)) {
                        breakerCache[id].events.push({ datetime, absMin, fib });
                    }
                    breakerCache[id].maxFib = Math.max(breakerCache[id].maxFib, fib);
                    
                    if (b.status === 'success' || b.status === 'fail') {
                        breakerCache[id].status = b.status;
                    }
                });
            });
            
            finalizeBreakers();
            
            showToast('Loaded ' + allData.length + ' breakers', 'success');
        }
        
        function processIncrementalData(snapshots) {
            let snapshotList = Array.isArray(snapshots) 
                ? snapshots 
                : Object.values(snapshots).filter(s => s);
            
            if (snapshotList.length === 0) {
                showToast('No new data', '');
                return;
            }
            
            snapshotList.sort((a, b) => {
                const tsA = a.observation_time || '';
                const tsB = b.observation_time || '';
                return tsA.localeCompare(tsB);
            });
            
            // Update lastFetchedTime
            const latestSnap = snapshotList[snapshotList.length - 1];
            lastFetchedTime = latestSnap.observation_time;
            
            // Update max time
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                if (ts) {
                    const min = datetimeToMin(ts);
                    if (min > dataMaxTime) dataMaxTime = min;
                }
            });
            
            // Merge into cache
            let newBreakers = 0;
            
            snapshotList.forEach(snap => {
                const ts = snap.observation_time || '';
                const datetime = ts.replace('T', ' ');
                const absMin = datetimeToMin(ts);
                
                Object.entries(snap.breakers || {}).forEach(([id, b]) => {
                    if (!breakerCache[id]) {
                        breakerCache[id] = {
                            id,
                            tf: b.tf.toLowerCase(),
                            dir: b.dir.toLowerCase(),
                            status: 'active',
                            events: [],
                            maxFib: 0
                        };
                        newBreakers++;
                    }
                    
                    const fib = b.fib || 1;
                    // Avoid duplicate events (same timestamp)
                    if (!breakerCache[id].events.some(e => e.absMin === absMin)) {
                        breakerCache[id].events.push({ datetime, absMin, fib });
                    }
                    breakerCache[id].maxFib = Math.max(breakerCache[id].maxFib, fib);
                    
                    if (b.status === 'success' || b.status === 'fail') {
                        breakerCache[id].status = b.status;
                    }
                });
            });
            
            // Update window to include new data
            // In live mode, keep window size fixed and slide it
            if (isLive) {
                const windowSize = windowEndMin - windowStartMin;
                windowEndMin = dataMaxTime;
                windowStartMin = Math.max(dataMinTime, dataMaxTime - windowSize);
            } else {
                windowEndMin = dataMaxTime;
            }
            setWindow(windowStartMin, windowEndMin, 'Latest');
            
            finalizeBreakers();
            
            showToast(`+${snapshotList.length} snapshots, ${newBreakers} new breakers`, 'success');
        }
        
        function finalizeBreakers() {
            allData = Object.values(breakerCache);
            allData.forEach(d => {
                d.events.sort((a, b) => a.absMin - b.absMin);
                d.startMin = d.events[0]?.absMin || 0;
                d.endMin = d.events[d.events.length - 1]?.absMin || 0;
                d.symbol = d.id.toUpperCase().includes('NQ') ? 'NQ' : 'ES';
            });
            
            // Extract 1M NQ Bull entry times
            entryTimes = allData
                .filter(d => d.symbol === 'NQ' && d.tf === '1m' && d.dir === 'bull')
                .map(d => d.startMin);
            
            updateStats();
            renderChart();
            
            // In live mode: always scroll to latest and show live confluence
            // In explore mode: only scroll on first load
            if (isLive || isFirstLoad) {
                setTimeout(() => {
                    const container = document.getElementById('scroll-container');
                    container.scrollLeft = container.scrollWidth;
                    updateViewportIndicator();
                    if (isLive) {
                        showLiveConfluence();
                    }
                }, 50);
                isFirstLoad = false;
            }
        }
        
        // ===== STATS =====
        function updateStats() {
            const stats = { active: 0, success: 0, fail: 0 };
            allData.forEach(d => {
                const status = d.status.toLowerCase();
                if (stats[status] !== undefined) stats[status]++;
            });
            
            const completed = stats.success + stats.fail;
            const winRate = completed > 0 ? Math.round(stats.success / completed * 100) : 0;
            
            document.getElementById('stat-active').textContent = stats.active;
            document.getElementById('stat-success').textContent = stats.success;
            document.getElementById('stat-fail').textContent = stats.fail;
            document.getElementById('stat-winrate').textContent = winRate + '%';
        }
        
        // ===== RENDERING =====
        function renderChart() {
            // Clean up previous event listeners
            if (chartAbortController) {
                chartAbortController.abort();
            }
            chartAbortController = new AbortController();
            const signal = chartAbortController.signal;
            
            const leftPanel = document.getElementById('left-panel');
            const chartInner = document.getElementById('chart-inner');
            const timeHeader = document.getElementById('time-header');
            
            leftPanel.innerHTML = '';
            chartInner.innerHTML = '';
            timeHeader.innerHTML = '';
            
            // In explore mode, preserve selections; in live mode, clear them
            const preservedEntryMin = !isLive ? selectedEntryMin : null;
            const preservedBreakerId = !isLive ? selectedBreakerId : null;
            
            selectedEntryMin = null;
            selectedBreakerId = null;
            
            // Calculate chart width based on data, add padding for future fade effect
            const chartWidth = (windowEndMin - windowStartMin) * PIXELS_PER_MINUTE + (PIXELS_PER_MINUTE * 2);
            
            chartInner.style.width = chartWidth + 'px';
            timeHeader.style.width = chartWidth + 'px';
            
            // Time header ticks - snap to 5-minute boundaries
            const tickInterval = 5;
            const firstTick = Math.ceil(windowStartMin / tickInterval) * tickInterval;
            for (let m = firstTick; m <= windowEndMin; m += tickInterval) {
                const x = (m - windowStartMin) * PIXELS_PER_MINUTE;
                const tick = document.createElement('div');
                tick.className = 'time-tick-label';
                tick.style.left = x + 'px';
                tick.textContent = minToTime(m);
                timeHeader.appendChild(tick);
            }
            
            // Filter data for window
            const windowData = allData.filter(d => {
                if (d.endMin < windowStartMin || d.startMin > windowEndMin) return false;
                if (d.symbol === 'NQ' && !filters.nq) return false;
                if (d.symbol === 'ES' && !filters.es) return false;
                if (d.dir === 'bull' && !filters.bull) return false;
                if (d.dir === 'bear' && !filters.bear) return false;
                return true;
            });
            
            // Group by TF ‚Üí Symbol
            const grouped = {};
            TF_ORDER.forEach(tf => {
                grouped[tf] = { NQ: [], ES: [] };
            });
            
            windowData.forEach(d => {
                const tf = d.tf.replace('hr', 'h');
                if (grouped[tf] && grouped[tf][d.symbol]) {
                    grouped[tf][d.symbol].push(d);
                }
            });
            
            // Determine which symbols are visible
            const visibleSymbols = SYMBOLS.filter(s => filters[s.toLowerCase()]);
            
            let totalHeight = 0;
            
            // Render TF sections
            TF_ORDER.forEach((tf, tfIndex) => {
                // TF header - left panel
                const tfHeaderLeft = document.createElement('div');
                tfHeaderLeft.className = 'tf-header tf-' + tf;
                tfHeaderLeft.textContent = TF_DISPLAY[tf];
                leftPanel.appendChild(tfHeaderLeft);
                
                // TF header - chart
                const tfHeaderChart = document.createElement('div');
                tfHeaderChart.className = 'tf-header-chart';
                tfHeaderChart.style.width = chartWidth + 'px';
                tfHeaderChart.dataset.tf = tf;
                chartInner.appendChild(tfHeaderChart);
                
                // TF_HEADER_HEIGHT + 4px margin-top
                totalHeight += TF_HEADER_HEIGHT + 4;
                
                // Symbol lanes within this TF
                visibleSymbols.forEach(symbol => {
                    const breakers = grouped[tf][symbol];
                    
                    // Calculate stack positions
                    const stackedBreakers = assignStackPositions(breakers);
                    const maxStack = stackedBreakers.length > 0 
                        ? Math.max(...stackedBreakers.map(b => b.stackIdx)) + 1 
                        : 1;
                    
                    // Dynamic lane height based on stacking
                    const laneHeight = Math.max(MIN_LANE_HEIGHT, LANE_PADDING * 2 + maxStack * (BAR_HEIGHT + BAR_GAP) - BAR_GAP);
                    
                    // Lane label
                    const laneLabel = document.createElement('div');
                    laneLabel.className = 'lane-label';
                    laneLabel.style.height = laneHeight + 'px';
                    laneLabel.dataset.tf = tf;
                    laneLabel.dataset.symbol = symbol;
                    const symbolBadge = document.createElement('span');
                    symbolBadge.className = 'symbol-badge ' + symbol.toLowerCase();
                    symbolBadge.textContent = symbol;
                    laneLabel.appendChild(symbolBadge);
                    leftPanel.appendChild(laneLabel);
                    
                    // Swimlane
                    const swimlane = document.createElement('div');
                    swimlane.className = 'swimlane';
                    swimlane.style.width = chartWidth + 'px';
                    swimlane.style.height = laneHeight + 'px';
                    swimlane.dataset.symbol = symbol;
                    swimlane.dataset.tf = tf;
                    
                    // Render breaker bars with stacking
                    stackedBreakers.forEach(b => {
                        const bar = createBreakerBar(b, laneHeight);
                        swimlane.appendChild(bar);
                    });
                    
                    chartInner.appendChild(swimlane);
                    totalHeight += laneHeight;
                });
            });
            
            // Render entry lines spanning full chart height
            // Subtract a few pixels for perfect alignment
            totalHeight -= 3;
            
            const windowEntries = entryTimes.filter(t => t >= windowStartMin && t <= windowEndMin);
            windowEntries.forEach(entryMin => {
                const x = (entryMin - windowStartMin) * PIXELS_PER_MINUTE;
                const entryLine = document.createElement('div');
                entryLine.className = 'entry-line';
                entryLine.style.left = x + 'px';
                entryLine.style.height = totalHeight + 'px';
                entryLine.dataset.entryMin = entryMin;
                entryLine.title = 'Entry: ' + minToTime(entryMin);
                entryLine.onclick = () => selectEntry(entryMin);
                chartInner.appendChild(entryLine);
            });
            
            // Add cursor line
            const cursorLine = document.createElement('div');
            cursorLine.className = 'cursor-line';
            cursorLine.id = 'cursor-line';
            cursorLine.style.height = totalHeight + 'px';
            chartInner.appendChild(cursorLine);
            
            // Set chart inner height so absolute positioned elements span correctly
            chartInner.style.height = totalHeight + 'px';
            
            // Add cursor time tooltip to body (so it's not clipped)
            let cursorTime = document.getElementById('cursor-time');
            if (!cursorTime) {
                cursorTime = document.createElement('div');
                cursorTime.className = 'cursor-time';
                cursorTime.id = 'cursor-time';
                document.body.appendChild(cursorTime);
            }
            
            // Cursor line event handlers on scroll container
            const scrollContainer = document.getElementById('scroll-container');
            let lastClientX = null;
            
            function updateCursorPosition(clientX) {
                const scrollRect = scrollContainer.getBoundingClientRect();
                const leftPanelWidth = 100; // matches .left-panel width
                const x = clientX - scrollRect.left - leftPanelWidth + scrollContainer.scrollLeft;
                if (x >= 0 && x <= chartWidth) {
                    cursorLine.style.left = x + 'px';
                    cursorLine.classList.add('visible');
                    
                    // Calculate and show time
                    const cursorMin = Math.round(windowStartMin + x / PIXELS_PER_MINUTE);
                    cursorTime.textContent = minToTime(cursorMin);
                    cursorTime.style.display = 'block';
                    cursorTime.style.left = (clientX - 30) + 'px';
                    cursorTime.style.top = (scrollRect.top - 30) + 'px';
                    
                    // Show confluence at cursor position in right panel
                    showCursorConfluence(cursorMin);
                    
                    // Highlight bars at cursor (yellow)
                    highlightCursorActive(cursorMin);
                } else {
                    cursorLine.classList.remove('visible');
                    cursorTime.style.display = 'none';
                }
            }
            
            scrollContainer.addEventListener('mousemove', (e) => {
                lastClientX = e.clientX;
                updateCursorPosition(e.clientX);
            }, { signal });
            
            scrollContainer.addEventListener('scroll', () => {
                if (lastClientX !== null) {
                    updateCursorPosition(lastClientX);
                }
            }, { signal });
            
            scrollContainer.addEventListener('mouseleave', () => {
                lastClientX = null;
                cursorLine.classList.remove('visible');
                cursorTime.style.display = 'none';
                
                // Clear cursor highlights
                clearCursorHighlight();
                
                // Restore appropriate panel state
                if (isLive) {
                    showLiveConfluence();
                } else if (selectedBreakerId) {
                    showBreakerDetail(selectedBreakerId);
                } else if (selectedEntryMin) {
                    showEntryContext(selectedEntryMin);
                } else {
                    showEmptyPanel();
                }
            }, { signal });
            
            // Click on chart to select time (but not on breakers or entry lines)
            chartInner.addEventListener('click', (e) => {
                // Only handle clicks directly on chart or swimlanes
                if (e.target.classList.contains('breaker-bar') || 
                    e.target.classList.contains('entry-line') ||
                    e.target.closest('.breaker-bar') ||
                    e.target.closest('.entry-line')) {
                    return;
                }
                
                const rect = chartInner.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const clickedMin = Math.round(windowStartMin + x / PIXELS_PER_MINUTE);
                selectTimeContext(clickedMin);
            }, { signal });
            
            // Update scroll listener
            const container = document.getElementById('scroll-container');
            container.removeEventListener('scroll', onScroll);
            container.addEventListener('scroll', onScroll, { signal });
            
            // Setup viewport drag handlers
            setupViewportHandlers();
            
            updateVisibleCount(windowData.length);
            
            // Restore selections in explore mode
            if (preservedBreakerId) {
                selectedBreakerId = preservedBreakerId;
                document.querySelectorAll(`.breaker-bar[data-breaker-id="${preservedBreakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                showBreakerDetail(preservedBreakerId);
            } else if (preservedEntryMin) {
                selectedEntryMin = preservedEntryMin;
                highlightActiveAtEntry(preservedEntryMin);
                showEntryContext(preservedEntryMin);
                // Highlight entry line if it exists
                document.querySelectorAll('.entry-line').forEach(el => {
                    if (parseInt(el.dataset.entryMin) === preservedEntryMin) {
                        el.classList.add('selected');
                    }
                });
            } else if (isLive) {
                // In live mode, show current confluence
                showLiveConfluence();
            } else {
                // In explore mode with no selection, show empty panel
                clearEntryHighlight();
                showEmptyPanel();
            }
            
            // Update viewport indicator after DOM is ready
            setTimeout(updateViewportIndicator, 50);
        }
        
        function createBreakerBar(b, laneHeight) {
            const startX = Math.max(0, (b.startMin - windowStartMin) * PIXELS_PER_MINUTE);
            const endX = (b.endMin - windowStartMin) * PIXELS_PER_MINUTE;
            const barWidth = Math.max(endX - startX + PIXELS_PER_MINUTE, 6);
            
            // Calculate vertical position based on stack index
            const topOffset = LANE_PADDING + b.stackIdx * (BAR_HEIGHT + BAR_GAP);
            
            const bar = document.createElement('div');
            bar.className = 'breaker-bar ' + b.symbol.toLowerCase() + ' ' + b.dir;
            
            if (b.status !== 'active') {
                bar.classList.add('completed');
            }
            
            bar.style.left = startX + 'px';
            bar.style.width = barWidth + 'px';
            bar.style.top = topOffset + 'px';
            bar.style.height = BAR_HEIGHT + 'px';
            bar.dataset.breakerId = b.id;
            bar.dataset.startMin = b.startMin;
            bar.dataset.endMin = b.endMin;
            
            // Right-side container for fib and status
            const rightGroup = document.createElement('div');
            rightGroup.className = 'bar-right-group';
            
            // Show fib on wider bars (right side, before status)
            if (barWidth > 50) {
                const fibSpan = document.createElement('span');
                fibSpan.className = 'bar-fib';
                fibSpan.textContent = b.maxFib.toFixed(1);
                rightGroup.appendChild(fibSpan);
            }
            
            // Status dot - only for completed
            if (b.status === 'success' || b.status === 'fail') {
                const dot = document.createElement('div');
                dot.className = 'status-dot ' + b.status;
                dot.textContent = b.status === 'success' ? '‚úì' : '‚úó';
                rightGroup.appendChild(dot);
            }
            
            bar.appendChild(rightGroup);
            
            // Click to show details
            bar.addEventListener('click', (e) => {
                e.stopPropagation();
                selectBreaker(b.id);
            });
            
            return bar;
        }
        
        // ===== DETAIL PANEL =====
        function showEmptyPanel() {
            document.getElementById('panel-content').innerHTML = `
                <div class="panel-empty">
                    <div class="panel-empty-icon">üìã</div>
                    <div class="panel-empty-text">
                        Click a breaker bar or entry line to see details
                    </div>
                </div>
            `;
        }
        
        function showCursorConfluence(cursorMin) {
            // Find all breakers active at cursor time
            const activeAtEntry = allData.filter(d => 
                d.startMin <= cursorMin && d.endMin >= cursorMin
            );
            
            // Build context for each TF/Symbol combination
            const contextRows = [];
            let nqBull = 0, nqBear = 0, esBull = 0, esBear = 0;
            
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    const breaker = activeAtEntry.find(d => 
                        d.tf.replace('hr', 'h') === tf && d.symbol === symbol
                    );
                    
                    if (breaker) {
                        // Count for alignment
                        if (symbol === 'NQ') {
                            if (breaker.dir === 'bull') nqBull++; else nqBear++;
                        } else {
                            if (breaker.dir === 'bull') esBull++; else esBear++;
                        }
                        
                        // Get fib at entry (first event)
                        const entryFib = breaker.events[0]?.fib || 1.0;
                        
                        // Get current fib (event closest to cursor time)
                        let currentFib = entryFib;
                        for (const evt of breaker.events) {
                            if (evt.absMin <= cursorMin) {
                                currentFib = evt.fib;
                            }
                        }
                        
                        // Status indicator
                        const statusIcon = breaker.status === 'success' ? '‚úì' : 
                                          breaker.status === 'fail' ? '‚úó' : '‚óè';
                        const statusClass = breaker.status;
                        
                        contextRows.push(`
                            <div class="context-row active">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir ${breaker.dir}">${breaker.dir.toUpperCase()}</span>
                                <span class="context-fib">${entryFib.toFixed(1)} ‚Üí ${currentFib.toFixed(1)}</span>
                                <span class="context-status-icon ${statusClass}">${statusIcon}</span>
                            </div>
                        `);
                    } else {
                        contextRows.push(`
                            <div class="context-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir none">‚Äî</span>
                                <span class="context-fib">‚Äî</span>
                                <span class="context-status-icon none">‚Äî</span>
                            </div>
                        `);
                    }
                });
            });
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-section-title">Confluence @ Cursor</div>
                    <div class="context-time">${minToTime(cursorMin)}</div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Active Breakers</div>
                    <div class="context-header">
                        <span>TF</span>
                        <span>Sym</span>
                        <span>Dir</span>
                        <span>Fib</span>
                        <span>St</span>
                    </div>
                    <div class="context-grid">
                        ${contextRows.join('')}
                    </div>
                </div>
                
                <div class="context-summary">
                    <div class="context-summary-row">
                        <span class="context-summary-label">NQ</span>
                        <span class="context-summary-value"><span class="arrow-bull">${nqBull}‚ñ≤</span> <span class="arrow-bear">${nqBear}‚ñº</span></span>
                    </div>
                    <div class="context-summary-row">
                        <span class="context-summary-label">ES</span>
                        <span class="context-summary-value"><span class="arrow-bull">${esBull}‚ñ≤</span> <span class="arrow-bear">${esBear}‚ñº</span></span>
                    </div>
                </div>
            `;
        }
        
        function showLiveConfluence() {
            const currentMin = dataMaxTime;
            
            // Highlight active breakers on chart and left panel (green for live)
            highlightLiveActive();
            
            // Find all breakers active at current time
            const activeAtEntry = allData.filter(d => 
                d.startMin <= currentMin && d.endMin >= currentMin
            );
            
            // Build context for each TF/Symbol combination
            const contextRows = [];
            let nqBull = 0, nqBear = 0, esBull = 0, esBear = 0;
            
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    const breaker = activeAtEntry.find(d => 
                        d.tf.replace('hr', 'h') === tf && d.symbol === symbol
                    );
                    
                    if (breaker) {
                        // Count for alignment
                        if (symbol === 'NQ') {
                            if (breaker.dir === 'bull') nqBull++; else nqBear++;
                        } else {
                            if (breaker.dir === 'bull') esBull++; else esBear++;
                        }
                        
                        // Get fib at entry (first event)
                        const entryFib = breaker.events[0]?.fib || 1.0;
                        
                        // Get current fib (latest event)
                        const currentFib = breaker.maxFib;
                        
                        // Status indicator
                        const statusIcon = breaker.status === 'success' ? '‚úì' : 
                                          breaker.status === 'fail' ? '‚úó' : '‚óè';
                        const statusClass = breaker.status;
                        
                        contextRows.push(`
                            <div class="context-row live-active-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir ${breaker.dir}">${breaker.dir.toUpperCase()}</span>
                                <span class="context-fib">${entryFib.toFixed(1)} ‚Üí ${currentFib.toFixed(1)}</span>
                                <span class="context-status-icon ${statusClass}">${statusIcon}</span>
                            </div>
                        `);
                    } else {
                        contextRows.push(`
                            <div class="context-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <span class="context-dir none">‚Äî</span>
                                <span class="context-fib">‚Äî</span>
                                <span class="context-status-icon none">‚Äî</span>
                            </div>
                        `);
                    }
                });
            });
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-section-title">
                        <span class="live-indicator"></span>
                        Live Confluence
                    </div>
                    <div class="context-time">${minToTime(currentMin)}</div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Active Breakers</div>
                    <div class="context-header">
                        <span>TF</span>
                        <span>Sym</span>
                        <span>Dir</span>
                        <span>Fib</span>
                        <span>St</span>
                    </div>
                    <div class="context-grid">
                        ${contextRows.join('')}
                    </div>
                </div>
                
                <div class="context-summary">
                    <div class="context-summary-row">
                        <span class="context-summary-label">NQ</span>
                        <span class="context-summary-value"><span class="arrow-bull">${nqBull}‚ñ≤</span> <span class="arrow-bear">${nqBear}‚ñº</span></span>
                    </div>
                    <div class="context-summary-row">
                        <span class="context-summary-label">ES</span>
                        <span class="context-summary-value"><span class="arrow-bull">${esBull}‚ñ≤</span> <span class="arrow-bear">${esBear}‚ñº</span></span>
                    </div>
                </div>
            `;
        }
        
        function showBreakerDetail(breakerId) {
            const b = allData.find(d => d.id === breakerId);
            if (!b) return;
            
            const duration = minToDuration(b.startMin, b.endMin);
            const statusClass = b.status.toLowerCase();
            const statusText = b.status.charAt(0).toUpperCase() + b.status.slice(1);
            
            // Generate fib chart
            const fibChart = generateFibChart(b);
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-id">${b.id}</div>
                    <div class="detail-badges">
                        <span class="detail-badge ${b.symbol.toLowerCase()}">${b.symbol}</span>
                        <span class="detail-badge ${b.dir}">${b.dir.toUpperCase()}</span>
                        <span class="detail-badge ${statusClass}">${statusText}</span>
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Fib Progression</div>
                    <div class="fib-chart-container">
                        ${fibChart}
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Metrics</div>
                    <div class="detail-row">
                        <span class="detail-label">Max Fib</span>
                        <span class="detail-value large">${b.maxFib.toFixed(2)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Timeframe</span>
                        <span class="detail-value">${TF_DISPLAY[b.tf] || b.tf.toUpperCase()}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Duration</span>
                        <span class="detail-value">${duration}</span>
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Timeline</div>
                    <div class="detail-row">
                        <span class="detail-label">Start</span>
                        <span class="detail-value">${minToDateTime(b.startMin)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">End</span>
                        <span class="detail-value">${minToDateTime(b.endMin)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Snapshots</span>
                        <span class="detail-value">${b.events.length}</span>
                    </div>
                </div>
            `;
        }
        
        function generateFibChart(breaker) {
            const events = breaker.events;
            if (events.length < 2) {
                return '<div style="color:#666;text-align:center;padding:20px;">Not enough data</div>';
            }
            
            const width = 280;
            const height = 120;
            const padding = { top: 20, right: 15, bottom: 25, left: 35 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Find min/max
            const minTime = events[0].absMin;
            const maxTime = events[events.length - 1].absMin;
            const timeRange = maxTime - minTime || 1;
            
            const maxFib = Math.max(...events.map(e => e.fib), 1);
            const fibCeil = Math.ceil(maxFib * 1.1); // Add 10% padding
            
            // Find peak point
            const peakEvent = events.reduce((max, e) => e.fib > max.fib ? e : max, events[0]);
            
            // Generate points
            const points = events.map(e => {
                const x = padding.left + ((e.absMin - minTime) / timeRange) * chartWidth;
                const y = padding.top + chartHeight - (e.fib / fibCeil) * chartHeight;
                return { x, y, fib: e.fib, time: e.absMin };
            });
            
            // Create line path
            const linePath = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
            
            // Create area path (for gradient fill)
            const areaPath = linePath + ` L ${points[points.length-1].x} ${padding.top + chartHeight} L ${points[0].x} ${padding.top + chartHeight} Z`;
            
            // Generate Y-axis labels
            const yLabels = [];
            const ySteps = 4;
            for (let i = 0; i <= ySteps; i++) {
                const val = (fibCeil / ySteps) * i;
                const y = padding.top + chartHeight - (i / ySteps) * chartHeight;
                yLabels.push(`<text class="fib-chart-value-label" x="${padding.left - 5}" y="${y + 3}" text-anchor="end">${val.toFixed(1)}</text>`);
                if (i > 0 && i < ySteps) {
                    yLabels.push(`<line class="fib-chart-grid" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}"/>`);
                }
            }
            
            // Generate time labels (start, middle, end)
            const midTime = minTime + Math.floor(timeRange / 2);
            const timeLabels = [];
            timeLabels.push(`<text class="fib-chart-label" x="${padding.left}" y="${height - 5}" text-anchor="start">${minToTime(minTime)}</text>`);
            timeLabels.push(`<text class="fib-chart-label" x="${padding.left + chartWidth/2}" y="${height - 5}" text-anchor="middle">${minToTime(midTime)}</text>`);
            timeLabels.push(`<text class="fib-chart-label" x="${width - padding.right}" y="${height - 5}" text-anchor="end">${minToTime(maxTime)}</text>`);
            
            // Find peak point coordinates
            const peakPoint = points.find(p => p.fib === peakEvent.fib);
            
            // Generate dots (sample if too many)
            let dotPoints = points;
            if (points.length > 20) {
                const step = Math.ceil(points.length / 15);
                dotPoints = points.filter((p, i) => i === 0 || i === points.length - 1 || p.fib === peakEvent.fib || i % step === 0);
            }
            
            const dots = dotPoints.map(p => {
                const isPeak = p.fib === peakEvent.fib;
                return `<circle class="${isPeak ? 'fib-chart-peak' : 'fib-chart-dot'}" cx="${p.x}" cy="${p.y}" r="${isPeak ? 4 : 3}"/>`;
            }).join('');
            
            // Peak label
            const peakLabel = peakPoint ? `
                <text class="fib-peak-label" x="${peakPoint.x}" y="${peakPoint.y - 8}" text-anchor="middle">${peakEvent.fib.toFixed(2)}</text>
            ` : '';
            
            // Store chart data for cursor interaction
            const chartId = 'fib-chart-' + Date.now();
            
            // Schedule cursor setup after DOM update
            setTimeout(() => setupFibChartCursor(chartId, points, padding, chartWidth, chartHeight, fibCeil, minTime, timeRange), 0);
            
            return `
                <svg id="${chartId}" class="fib-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                    <defs>
                        <linearGradient id="fibGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:0.4"/>
                            <stop offset="100%" style="stop-color:#60a5fa;stop-opacity:0"/>
                        </linearGradient>
                    </defs>
                    
                    <!-- Grid lines -->
                    ${yLabels.join('')}
                    
                    <!-- Axes -->
                    <line class="fib-chart-axis" x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${padding.top + chartHeight}"/>
                    <line class="fib-chart-axis" x1="${padding.left}" y1="${padding.top + chartHeight}" x2="${width - padding.right}" y2="${padding.top + chartHeight}"/>
                    
                    <!-- Area fill -->
                    <path class="fib-chart-area" d="${areaPath}"/>
                    
                    <!-- Line -->
                    <path class="fib-chart-line" d="${linePath}"/>
                    
                    <!-- Dots -->
                    ${dots}
                    
                    <!-- Peak label -->
                    ${peakLabel}
                    
                    <!-- Time labels -->
                    ${timeLabels.join('')}
                    
                    <!-- Cursor elements -->
                    <line class="fib-cursor-line" id="${chartId}-cursor-line" x1="0" y1="${padding.top}" x2="0" y2="${padding.top + chartHeight}"/>
                    <circle class="fib-cursor-dot" id="${chartId}-cursor-dot" cx="0" cy="0" r="5"/>
                    
                    <!-- Hover area -->
                    <rect x="${padding.left}" y="${padding.top}" width="${chartWidth}" height="${chartHeight}" fill="transparent" style="cursor:crosshair"/>
                </svg>
                <div class="fib-cursor-tooltip" id="${chartId}-tooltip">
                    <span class="fib-val">0.00</span>
                    <span class="time-val">00:00</span>
                </div>
            `;
        }
        
        function setupFibChartCursor(chartId, points, padding, chartWidth, chartHeight, fibCeil, minTime, timeRange) {
            const svg = document.getElementById(chartId);
            const cursorLine = document.getElementById(chartId + '-cursor-line');
            const cursorDot = document.getElementById(chartId + '-cursor-dot');
            const tooltip = document.getElementById(chartId + '-tooltip');
            
            if (!svg || !cursorLine || !cursorDot || !tooltip) return;
            
            const container = svg.closest('.fib-chart-container');
            
            svg.addEventListener('mousemove', (e) => {
                const rect = svg.getBoundingClientRect();
                const scaleX = 280 / rect.width;
                const mouseX = (e.clientX - rect.left) * scaleX;
                
                // Check if within chart area
                if (mouseX < padding.left || mouseX > padding.left + chartWidth) {
                    cursorLine.style.opacity = '0';
                    cursorDot.style.opacity = '0';
                    tooltip.style.opacity = '0';
                    return;
                }
                
                // Find closest point
                let closest = points[0];
                let closestDist = Math.abs(points[0].x - mouseX);
                
                for (const p of points) {
                    const dist = Math.abs(p.x - mouseX);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = p;
                    }
                }
                
                // Update cursor
                cursorLine.setAttribute('x1', closest.x);
                cursorLine.setAttribute('x2', closest.x);
                cursorLine.style.opacity = '1';
                
                cursorDot.setAttribute('cx', closest.x);
                cursorDot.setAttribute('cy', closest.y);
                cursorDot.style.opacity = '1';
                
                // Update tooltip
                tooltip.querySelector('.fib-val').textContent = closest.fib.toFixed(2);
                tooltip.querySelector('.time-val').textContent = minToTime(closest.time);
                tooltip.style.opacity = '1';
                
                // Position tooltip
                const tooltipX = (closest.x / 280) * rect.width;
                const tooltipY = (closest.y / 120) * rect.height;
                
                // Flip tooltip if near right edge
                if (tooltipX > rect.width * 0.6) {
                    tooltip.style.left = (tooltipX - tooltip.offsetWidth - 10) + 'px';
                } else {
                    tooltip.style.left = (tooltipX + 10) + 'px';
                }
                tooltip.style.top = (tooltipY - 10) + 'px';
            });
            
            svg.addEventListener('mouseleave', () => {
                cursorLine.style.opacity = '0';
                cursorDot.style.opacity = '0';
                tooltip.style.opacity = '0';
            });
        }
        
        function showEntryContext(entryMin) {
            // Find all breakers active at this time
            const activeAtEntry = allData.filter(d => 
                d.startMin <= entryMin && d.endMin >= entryMin
            );
            
            // Build context for each TF/Symbol combination
            const contextRows = [];
            let bullCount = 0;
            let bearCount = 0;
            
            TF_ORDER.forEach(tf => {
                SYMBOLS.forEach(symbol => {
                    const breaker = activeAtEntry.find(d => 
                        d.tf.replace('hr', 'h') === tf && d.symbol === symbol
                    );
                    
                    if (breaker) {
                        const age = entryMin - breaker.startMin;
                        const ageStr = age < 60 ? `${age}m` : `${Math.floor(age/60)}h ${age%60}m`;
                        
                        if (breaker.dir === 'bull') bullCount++;
                        else bearCount++;
                        
                        contextRows.push(`
                            <div class="context-row active">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <div class="context-status">
                                    <div class="context-indicator active"></div>
                                    <span class="context-dir ${breaker.dir}">${breaker.dir.toUpperCase()}</span>
                                </div>
                                <span class="context-age">${ageStr} old</span>
                            </div>
                        `);
                    } else {
                        contextRows.push(`
                            <div class="context-row">
                                <span class="context-tf">${TF_DISPLAY[tf]}</span>
                                <span class="context-symbol ${symbol.toLowerCase()}">${symbol}</span>
                                <div class="context-status">
                                    <div class="context-indicator none"></div>
                                    <span class="context-dir none">‚Äî</span>
                                </div>
                                <span class="context-age"></span>
                            </div>
                        `);
                    }
                });
            });
            
            // Find the entry breaker to get outcome (only for actual entry times)
            const entryBreaker = allData.find(d => 
                d.symbol === 'NQ' && d.tf === '1m' && d.dir === 'bull' && d.startMin === entryMin
            );
            
            // Build outcome row only if this is an actual entry
            let outcomeRow = '';
            if (entryBreaker) {
                const outcome = entryBreaker.status;
                const outcomeClass = outcome === 'success' ? 'good' : outcome === 'fail' ? 'bad' : 'neutral';
                const outcomeText = outcome.charAt(0).toUpperCase() + outcome.slice(1);
                outcomeRow = `
                    <div class="context-summary-row">
                        <span class="context-summary-label">Outcome</span>
                        <span class="context-summary-value ${outcomeClass}">${outcomeText}${entryBreaker.status !== 'active' ? ` (${entryBreaker.maxFib.toFixed(1)})` : ''}</span>
                    </div>
                `;
            }
            
            document.getElementById('panel-content').innerHTML = `
                <div class="detail-section">
                    <div class="detail-section-title">Selected Time</div>
                    <div class="context-time">${minToTime(entryMin)}</div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Active Breakers</div>
                    <div class="context-grid">
                        ${contextRows.join('')}
                    </div>
                </div>
                
                <div class="context-summary">
                    <div class="context-summary-row">
                        <span class="context-summary-label">Bull Active</span>
                        <span class="context-summary-value">${bullCount} TFs</span>
                    </div>
                    <div class="context-summary-row">
                        <span class="context-summary-label">Bear Active</span>
                        <span class="context-summary-value">${bearCount} TFs</span>
                    </div>
                    ${outcomeRow}
                </div>
            `;
        }
        
        // ===== SELECTION =====
        function selectBreaker(breakerId) {
            // Clear previous selection
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            clearEntryHighlight();
            selectedEntryMin = null;
            
            // Toggle selection
            if (selectedBreakerId === breakerId) {
                selectedBreakerId = null;
                showEmptyPanel();
            } else {
                selectedBreakerId = breakerId;
                
                // Highlight selected bar
                document.querySelectorAll(`.breaker-bar[data-breaker-id="${breakerId}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                
                showBreakerDetail(breakerId);
            }
            
            // Update entry line styling
            document.querySelectorAll('.entry-line').forEach(el => {
                el.classList.remove('selected');
            });
        }
        
        function selectEntry(entryMin) {
            // Clear previous selection
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            selectedBreakerId = null;
            
            // Toggle selection
            if (selectedEntryMin === entryMin) {
                selectedEntryMin = null;
                clearEntryHighlight();
                showEmptyPanel();
            } else {
                selectedEntryMin = entryMin;
                highlightActiveAtEntry(entryMin);
                showEntryContext(entryMin);
            }
            
            // Update entry line styling
            document.querySelectorAll('.entry-line').forEach(el => {
                if (parseInt(el.dataset.entryMin) === selectedEntryMin) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });
        }
        
        function selectTimeContext(clickedMin) {
            // Clear previous selections
            document.querySelectorAll('.breaker-bar.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.entry-line').forEach(el => {
                el.classList.remove('selected');
            });
            selectedBreakerId = null;
            
            // Toggle selection
            if (selectedEntryMin === clickedMin) {
                selectedEntryMin = null;
                clearEntryHighlight();
                showEmptyPanel();
            } else {
                selectedEntryMin = clickedMin;
                highlightActiveAtEntry(clickedMin);
                showEntryContext(clickedMin);
            }
        }
        
        function highlightActiveAtEntry(entryMin) {
            clearEntryHighlight();
            
            // Track which TF/symbol combinations have active breakers
            const activeLanes = new Set();
            
            document.querySelectorAll('.breaker-bar').forEach(el => {
                const startMin = parseInt(el.dataset.startMin);
                const endMin = parseInt(el.dataset.endMin);
                if (startMin <= entryMin && endMin >= entryMin) {
                    el.classList.add('active-at-entry');
                    // Track this lane
                    const tf = el.closest('.swimlane')?.dataset.tf;
                    const symbol = el.closest('.swimlane')?.dataset.symbol;
                    if (tf && symbol) {
                        activeLanes.add(`${tf}-${symbol}`);
                    }
                }
            });
            
            // Highlight corresponding lane labels
            document.querySelectorAll('.lane-label').forEach(el => {
                const tf = el.dataset.tf;
                const symbol = el.dataset.symbol;
                if (activeLanes.has(`${tf}-${symbol}`)) {
                    el.classList.add('has-confluence');
                }
            });
        }
        
        function clearEntryHighlight() {
            document.querySelectorAll('.active-at-entry').forEach(el => {
                el.classList.remove('active-at-entry');
            });
            document.querySelectorAll('.has-confluence').forEach(el => {
                el.classList.remove('has-confluence');
            });
        }
        
        // Cursor highlighting (yellow) - separate from live/selected highlighting
        function highlightCursorActive(cursorMin) {
            clearCursorHighlight();
            clearLiveHighlight(); // Clear live highlight when cursor is active
            
            document.querySelectorAll('.breaker-bar').forEach(el => {
                const startMin = parseInt(el.dataset.startMin);
                const endMin = parseInt(el.dataset.endMin);
                if (startMin <= cursorMin && endMin >= cursorMin) {
                    el.classList.add('cursor-active');
                }
            });
            
            // Highlight corresponding lane labels
            const activeLanes = new Set();
            document.querySelectorAll('.breaker-bar.cursor-active').forEach(el => {
                const tf = el.closest('.swimlane')?.dataset.tf;
                const symbol = el.closest('.swimlane')?.dataset.symbol;
                if (tf && symbol) {
                    activeLanes.add(`${tf}-${symbol}`);
                }
            });
            
            document.querySelectorAll('.lane-label').forEach(el => {
                const tf = el.dataset.tf;
                const symbol = el.dataset.symbol;
                if (activeLanes.has(`${tf}-${symbol}`)) {
                    el.classList.add('cursor-confluence');
                }
            });
        }
        
        function clearCursorHighlight() {
            document.querySelectorAll('.cursor-active').forEach(el => {
                el.classList.remove('cursor-active');
            });
            document.querySelectorAll('.cursor-confluence').forEach(el => {
                el.classList.remove('cursor-confluence');
            });
        }
        
        // Live highlighting (green) - for live mode current time
        function highlightLiveActive() {
            clearLiveHighlight();
            const currentMin = dataMaxTime;
            
            document.querySelectorAll('.breaker-bar').forEach(el => {
                const startMin = parseInt(el.dataset.startMin);
                const endMin = parseInt(el.dataset.endMin);
                if (startMin <= currentMin && endMin >= currentMin) {
                    el.classList.add('live-active');
                }
            });
            
            // Highlight corresponding lane labels
            const activeLanes = new Set();
            document.querySelectorAll('.breaker-bar.live-active').forEach(el => {
                const tf = el.closest('.swimlane')?.dataset.tf;
                const symbol = el.closest('.swimlane')?.dataset.symbol;
                if (tf && symbol) {
                    activeLanes.add(`${tf}-${symbol}`);
                }
            });
            
            document.querySelectorAll('.lane-label').forEach(el => {
                const tf = el.dataset.tf;
                const symbol = el.dataset.symbol;
                if (activeLanes.has(`${tf}-${symbol}`)) {
                    el.classList.add('live-confluence');
                }
            });
        }
        
        function clearLiveHighlight() {
            document.querySelectorAll('.live-active').forEach(el => {
                el.classList.remove('live-active');
            });
            document.querySelectorAll('.live-confluence').forEach(el => {
                el.classList.remove('live-confluence');
            });
        }
        
        // ===== VIEWPORT DRAG TO PAN =====
        let vpHandlersSetup = false;
        
        function setupViewportHandlers() {
            if (vpHandlersSetup) return;
            vpHandlersSetup = true;
            
            const track = document.getElementById('timeline-track');
            const viewport = document.getElementById('viewport-indicator');
            
            if (!track || !viewport) return;
            
            let isDragging = false;
            let hasDragged = false;
            let startX = 0;
            let startScrollLeft = 0;
            
            // Drag viewport to scroll chart
            viewport.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                hasDragged = false;
                startX = e.clientX;
                
                const container = document.getElementById('scroll-container');
                startScrollLeft = container ? container.scrollLeft : 0;
                viewport.style.cursor = 'grabbing';
            });
            
            // Click on track to jump
            track.addEventListener('click', (e) => {
                if (e.target !== track || hasDragged) {
                    hasDragged = false;
                    return;
                }
                
                if (dataMinTime === 0 || dataMaxTime === 0) return;
                
                const container = document.getElementById('scroll-container');
                const chartInner = document.getElementById('chart-inner');
                if (!container || !chartInner) return;
                
                const trackRect = track.getBoundingClientRect();
                const clickPct = (e.clientX - trackRect.left) / trackRect.width;
                const totalRange = dataMaxTime - dataMinTime;
                const clickMin = dataMinTime + clickPct * totalRange;
                
                // Calculate scroll position to center on clicked time
                const chartWidth = chartInner.offsetWidth;
                const viewportWidth = container.clientWidth;
                const windowRange = windowEndMin - windowStartMin;
                
                // Map clicked time to scroll position
                const timeInWindow = clickMin - windowStartMin;
                const scrollTarget = (timeInWindow / windowRange) * chartWidth - viewportWidth / 2;
                
                container.scrollLeft = Math.max(0, Math.min(scrollTarget, chartWidth - viewportWidth));
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                if (dataMinTime === 0 || dataMaxTime === 0) return;
                
                hasDragged = true;
                
                const container = document.getElementById('scroll-container');
                const chartInner = document.getElementById('chart-inner');
                const trackEl = document.getElementById('timeline-track');
                if (!container || !chartInner || !trackEl) return;
                
                const trackRect = trackEl.getBoundingClientRect();
                const trackWidth = trackRect.width;
                const chartWidth = chartInner.offsetWidth;
                const viewportWidth = container.clientWidth;
                const maxScroll = chartWidth - viewportWidth;
                
                if (maxScroll <= 0) return;
                
                const totalRange = dataMaxTime - dataMinTime;
                const windowRange = windowEndMin - windowStartMin;
                
                // Map drag distance on track to scroll distance
                const dx = e.clientX - startX;
                const dPctOfTotal = dx / trackWidth;
                const dTime = dPctOfTotal * totalRange;
                const dScroll = (dTime / windowRange) * chartWidth;
                
                container.scrollLeft = Math.max(0, Math.min(startScrollLeft + dScroll, maxScroll));
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    viewport.style.cursor = 'grab';
                }
            });
        }
        
        // ===== SCROLL =====
        let scrollTimeout;
        
        function onScroll() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {}, 30);
            
            const container = document.getElementById('scroll-container');
            const header = document.getElementById('time-header');
            header.style.transform = `translateX(${-container.scrollLeft}px)`;
            
            // Update viewport indicator based on scroll position
            updateViewportFromScroll();
        }
        
        function updateViewportFromScroll() {
            if (dataMinTime === 0 || dataMaxTime === 0) return;
            
            const container = document.getElementById('scroll-container');
            const chartInner = document.getElementById('chart-inner');
            if (!container || !chartInner) return;
            
            const chartWidth = chartInner.offsetWidth;
            const viewportWidth = container.clientWidth;
            const scrollLeft = container.scrollLeft;
            
            if (chartWidth <= 0) return;
            
            const totalDataRange = dataMaxTime - dataMinTime;
            const windowRange = windowEndMin - windowStartMin;
            
            // Calculate visible time range based on scroll
            const scrollPct = chartWidth > viewportWidth ? scrollLeft / (chartWidth - viewportWidth) : 0;
            const visibleTimeWidth = (viewportWidth / chartWidth) * windowRange;
            const visibleStartMin = windowStartMin + scrollPct * (windowRange - visibleTimeWidth);
            const visibleEndMin = visibleStartMin + visibleTimeWidth;
            
            // Map to viewport bar position
            const startPct = Math.max(0, ((visibleStartMin - dataMinTime) / totalDataRange) * 100);
            const endPct = Math.min(100, ((visibleEndMin - dataMinTime) / totalDataRange) * 100);
            const widthPct = Math.max(2, endPct - startPct);
            
            const vpEl = document.getElementById('viewport-indicator');
            if (vpEl) {
                vpEl.style.left = startPct + '%';
                vpEl.style.width = widthPct + '%';
            }
        }
        
        function updateViewportIndicator() {
            // Update time labels
            if (dataMinTime > 0 && dataMaxTime > 0) {
                document.getElementById('data-start').textContent = minToDateTime(dataMinTime);
                document.getElementById('data-end').textContent = minToDateTime(dataMaxTime);
            }
            
            // Update viewport bar position based on current scroll
            updateViewportFromScroll();
        }
        
        function updateVisibleCount(count) {
            document.getElementById('visible-count').textContent = count + ' breakers in window';
        }
        
        // ===== AUTO REFRESH =====
        function setRefreshInterval() {
            if (refreshTimer) clearInterval(refreshTimer);
            if (countdownTimer) clearInterval(countdownTimer);
            
            const interval = parseInt(document.getElementById('refresh-interval').value);
            const countdownEl = document.getElementById('countdown');
            
            if (interval === 0) {
                countdownEl.textContent = '';
                return;
            }
            
            countdownSecs = interval;
            countdownEl.textContent = interval + 's';
            
            countdownTimer = setInterval(() => {
                countdownSecs--;
                if (countdownSecs <= 0) countdownSecs = interval;
                countdownEl.textContent = countdownSecs + 's';
            }, 1000);
            
            refreshTimer = setInterval(() => {
                console.log('Auto-refresh triggered');
                loadData();
                countdownSecs = interval;
            }, interval * 1000);
            
            console.log('Refresh interval set to', interval, 'seconds');
        }
        
        // ===== INIT =====
        window.onload = function() {
            isLive = false;
            document.getElementById('mode-explore').classList.remove('inactive');
            document.getElementById('mode-explore').classList.add('explore-active');
            document.getElementById('mode-live').classList.add('inactive');
            loadData();
            setRefreshInterval();
            
            // Update viewport indicator on resize
            window.addEventListener('resize', updateViewportIndicator);
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (selectedEntryMin !== null) {
                        selectEntry(selectedEntryMin);
                    } else if (selectedBreakerId !== null) {
                        selectBreaker(selectedBreakerId);
                    }
                }
            });
        };
    </script>
</body>
</html>
